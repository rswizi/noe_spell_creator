<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Inventory</title>
  <link rel="stylesheet" href="/static/style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Vertical, comfy layout */
    .stack { display: grid; gap: 18px; grid-template-columns: 1fr; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .pill{ display:inline-block; border:1px solid #444; border-radius:999px; padding:2px 8px; margin-right:6px }
    .muted{ opacity:.8 }
    .items { display:block; margin-top:8px; }
    .item-row { display:flex; align-items:center; gap:10px; padding:6px 8px; border:1px solid #222; border-radius:10px; margin:6px 0; }
    .item-row .grow { flex:1; min-width:200px; }
    .container-card { padding:10px; border:1px solid #222; border-radius:12px; margin:10px 0; }
    .container-head { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .container-head input[type="text"]{ min-width:180px; }
    .list { border:1px solid #222; border-radius:10px; padding:8px; }
    .searchbar { display:grid; gap:8px; grid-template-columns: 1fr; }
    .search-controls { display:grid; gap:8px; grid-template-columns: 1fr 1fr 1fr 1fr; }
    .purchase-controls { display:grid; gap:8px; grid-template-columns: 1fr 1fr; }
    .modal { position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.45); z-index:1000; padding:16px; }
    .modal.hidden{ display:none; }
    .modal-card { width:min(760px, 96vw); background:#0b0b0b; border:1px solid #222; border-radius:14px; padding:16px; }
    .modal-close { float:right; font-size:22px; border:none; background:transparent; color:#ccc; cursor:pointer; }
    .info-grid { display:grid; gap:10px; grid-template-columns: repeat(auto-fit,minmax(160px,1fr)); margin:10px 0; }
    .info-grid .cell { border:1px solid #1c2637; border-radius:10px; padding:8px; background:#0c111a; }
    .info-grid .label { font-size:.85rem; opacity:.75; }
    .pill-soft { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:10px; background:#111827; border:1px solid #1f2b3f; }
    .upg-list { display:grid; gap:10px; }
    .upg-row { border:1px solid #1c2637; border-radius:10px; padding:8px; background:#0c111a; }
    .upg-row h4 { margin:0 0 4px; font-size:1rem; }
    .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .price-choice-card{ max-width:520px; width:min(520px, 96vw); }
    .price-choice-title{ font-weight:700; line-height:1.2; word-break:break-word; }
    .price-choice-grid{ display:grid; gap:8px; }
    .price-choice-option{ display:flex; flex-direction:column; gap:4px; }
    .price-choice-option select{ width:100%; padding:10px 12px; border-radius:12px; border:1px solid #2a2f3a; background:#0d0f16; color:#f6f6f8; }
    .price-choice-custom{ display:grid; gap:8px; grid-template-columns: minmax(0,1fr) minmax(0,1fr); }
    .price-choice-field{ display:flex; gap:6px; align-items:center; min-width:0; }
    .price-choice-field input{ flex:1; min-width:0; padding:8px 10px; border-radius:10px; border:1px solid #2a2f3a; background:#0d0f16; color:#f3f3f5; }
    .price-choice-actions{ display:flex; justify-content:flex-end; gap:8px; margin-top:6px; }
    .choice-table{ display:grid; gap:8px; margin-top:8px; }
    .choice-row{ display:grid; grid-template-columns: minmax(0,1fr) auto; gap:8px; align-items:center; }
    .choice-row select{ width:100%; }
    .choice-row .choice-remove{ padding:6px 10px; font-size:.8rem; }
    .choice-actions{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .choice-counter{ font-size:.85rem; opacity:.75; }
    @media (min-width: 1100px){
      .container-wide { max-width: 1100px; margin: 0 auto; }
      .searchbar { grid-template-columns: 2fr 1fr; align-items:end; }
    }
  </style>
</head>
<body>
<div class="container container-wide">
  <h1 id="inv-title">Inventory</h1>

  <div class="stack">
    <!-- Inventory Overview -->
    <div class="home-card">
      <h3>Overview</h3>
      <div id="money"></div>
      <div class="row muted">Total Encumbrance: <strong id="enc-total">0</strong></div>

      <!-- Add Funds -->
      <div class="row" style="margin-top:10px;">
        <label class="muted">Add Funds</label>
        <select id="fund-cur" style="min-width:120px;"></select>
        <input id="fund-amt" type="number" step="1" placeholder="Amount" style="width:140px;">
        <input id="fund-note" placeholder="Note (optional)" style="flex:1; min-width:200px;">
        <button id="fund-add" class="btn small">+ Add</button>
      </div>
    </div>

    <!-- Containers + Items -->
    <div class="home-card">
      <h3>Containers & Items</h3>
      <div id="containers"></div>

      <div class="row" style="margin-top:8px;">
        <input id="new-cont-name" placeholder="New container name">
        <button id="add-cont" class="btn small">+ Add Container</button>
      </div>
    </div>

    <!-- Recent Transactions -->
    <div class="home-card">
      <h3>Recent Transactions</h3>
      <div id="tx" class="list"></div>
    </div>

    <!-- Catalog (add items) -->
    <div class="home-card">
      <h3>Add from Catalog</h3>

      <div class="searchbar">
        <div>
          <div class="row">
            <input id="q" placeholder="Search name…" style="flex:1">
            <button id="search" class="btn small">Search</button>
          </div>
          <div class="search-controls">
            <div>
              <label class="muted">Kind</label>
              <select id="kind">
                <option value="object">Objects</option>
                <option value="weapon">Weapons</option>
                <option value="equipment">Equipment</option>
                <option value="tool">Tools</option>
              </select>
            </div>
            <div>
              <label class="muted">Category</label>
              <select id="cat-select" disabled>
                <option value="__all">All</option>
              </select>
            </div>
            <div>
              <label class="muted">Results</label>
              <select id="limit">
                <option>25</option>
                <option selected>50</option>
                <option>100</option>
              </select>
            </div>
            <div>
              <label class="muted">Price modifier</label>
              <input id="price-mod" type="number" step="0.05" min="0" value="1" style="width:100%;">
            </div>
            <div class="row" style="align-items:end;">
              <button id="clear" class="btn btn-secondary small">Clear</button>
            </div>
          </div>
        </div>

        <div>
          <div class="purchase-controls">
            <div>
              <label class="muted">Container</label>
              <select id="global-cont"></select>
            </div>
            <div>
              <label class="muted">Currency</label>
              <select id="global-cur"></select>
            </div>
          </div>
          <div class="muted" style="margin-top:8px;">Selected container/currency apply to all “Add” actions below.</div>
        </div>
      </div>

      <div id="results" class="list" style="margin-top:8px;"></div>
    </div>

    <div>
      <a class="btn btn-secondary" href="inventory_create.html">← Back</a>
    </div>
  </div>
</div>

<!-- Item Details Modal -->
<div id="item-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="item-title">
  <div class="modal-card">
    <button class="modal-close" id="item-close" aria-label="Close">&times;</button>
    <h2 id="item-title">Item</h2>
    <div id="item-body" class="list" style="margin-top:10px;"></div>

    <!-- Actions for weapons/equipment -->
    <div id="item-actions" style="margin-top:12px;"></div>
  </div>
</div>

<!-- Quality Upgrade Modal -->
<div id="quality-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="quality-title">
  <div class="modal-card">
    <button class="modal-close" id="quality-close" aria-label="Close">&times;</button>
    <h2 id="quality-title">Upgrade Quality</h2>
    <div id="quality-body" class="list" style="margin-top:10px;"></div>
    <div class="btn-row">
      <button class="btn" id="quality-upgrade-confirm">Buy upgrade</button>
      <button class="btn btn-secondary" id="quality-close-action">Cancel</button>
    </div>
  </div>
</div>

<!-- Item Choice Modal -->
<div id="choice-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="choice-title">
  <div class="modal-card">
    <button class="modal-close" id="choice-close" aria-label="Close">&times;</button>
    <h2 id="choice-title">Configure choices</h2>
    <div id="choice-body" class="list" style="margin-top:10px;"></div>
    <div class="btn-row">
      <button class="btn btn-secondary" id="choice-cancel">Cancel</button>
      <button class="btn" id="choice-save">Save</button>
    </div>
  </div>
</div>

<script>
const $ = s => document.querySelector(s);
const token = localStorage.getItem("auth_token") || "";
const authHeaders = () => token ? { "Authorization": "Bearer " + token } : {};
async function api(path, opt = {}){
  const headers = Object.assign({}, opt.headers || {}, authHeaders());
  const resp = await fetch(path, { credentials: "include", ...opt, headers });
  const ct = resp.headers.get("content-type") || "";
  const data = ct.includes("application/json") ? await resp.json() : { status: "error", message: await resp.text() };
  if (!resp.ok || data.status === "error") throw new Error(data.message || ("HTTP " + resp.status));
  return data;
}
const params = new URLSearchParams(location.search);
const invId = params.get("inv");
const isEmbed = params.get("embed") === "1";
const SELF_CONTAINER_ID = "self";

let INV = null;
let LAST_RESULTS = [];
let FILTERED = [];
let PRICE_MOD = 1;
let ACTIVE_ITEM_ID = "";
const invPriceModEl = $("#price-mod");
const choiceModal = $("#choice-modal");
const choiceTitle = $("#choice-title");
const choiceBody = $("#choice-body");
const choiceSave = $("#choice-save");
const choiceCancel = $("#choice-cancel");
const choiceClose = $("#choice-close");
const qualityModal = $("#quality-modal");
const qualityTitle = $("#quality-title");
const qualityBody = $("#quality-body");
const qualityClose = $("#quality-close");
const qualityCloseAction = $("#quality-close-action");
const qualityUpgradeBtn = $("#quality-upgrade-confirm");

const KIND_PLURAL = { object: "objects", weapon: "weapons", equipment: "equipment", tool: "tools" };
const QUALITIES = ["Adequate","Good","Very Good","Excellent","Legendary","Mythical","Epic","Divine","Unreal"];
const QUALITY_SLOTS = { "Adequate":1,"Good":2,"Very Good":3,"Excellent":4,"Legendary":5,"Mythical":6,"Epic":7,"Divine":8,"Unreal":9 };
const QUALITY_DIFFS = {
  "Mediocre": -100, "Adequate": 0, "Good": 167, "Very Good": 1390,
  "Excellent": 5280, "Legendary": 15300, "Mythical": 38760,
  "Epic": 128000, "Divine": 614400, "Unreal": 921600,
};

const CHARACS = [
  { key:"reflex",    code:"REF", name:"Reflex",    skills:["Technicity","Dodge","Counter","Reactivity"] },
  { key:"dexterity", code:"DEX", name:"Dexterity", skills:["Accuracy","Evasion","Stealth","Acrobatics"] },
  { key:"body",      code:"BOD", name:"Body",      skills:["Brutality","Blocking","Resistance","Athletics"] },
  { key:"willpower", code:"WIL", name:"Willpower", skills:["Intimidation","Spirit","Instinct","Absorption"] },
  { key:"wisdom",    code:"WIS", name:"Wisdom",    skills:["Survival","Education","Perception","Psychology","Investigation"] },
  { key:"presence",  code:"PRE", name:"Presence",  skills:["Taming","Charm","Charisma","Deception","Persuasion"] },
  { key:"magic",     code:"MAG", name:"Magic",     skills:["Aura","Incantation","Enchantment","Restoration","Potential"] },
  { key:"tech",      code:"TECH",name:"Tech",      skills:["Crafting","Sleight of hand","Alchemy","Medicine","Engineering"] },
];
const INTENSITIES = ["Fire","Water","Earth","Wind","Lightning","Sun","Moon","Ki"];
const SKILL_LABEL = {
  aura: "Aura",
  incantation: "Incantation",
  enchantement: "Enchantment",
  enchantment: "Enchantment",
  restoration: "Restoration",
  potential: "Potential",
  stealth: "Stealth",
  investigation: "Investigation",
  charm: "Charm",
  intimidation: "Intimidation",
  absorption: "Absorption",
  spirit: "Spirit",
};
const SKILL_TO_CHAR = {
  aura: "magic", incantation: "magic", enchantement: "magic", enchantment: "magic", restoration: "magic", potential: "magic",
  stealth: "dexterity", investigation: "wisdom", charm: "presence", intimidation: "willpower", absorption: "willpower", spirit: "willpower",
};
let SCHOOLS = [];

const ITEM_CHOICES_KEY = invId ? `inv_item_choices_${invId}` : "";
let ITEM_CHOICES = {};
let QUALITY_CTX = null;
let qualityTargetSelect = null;
let qualityPriceInput = null;
let qualityCurrencySelect = null;
let qualityCostDisplay = null;

function slotsForQuality(q){ return QUALITY_SLOTS[q] || 0; }
function debounce(fn, ms=300){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

function lc(v){ return String(v || "").trim().toLowerCase(); }
function title(str){ return String(str || "").replace(/(^|\\s|_)([a-z])/g, (_,p1,p2)=> p1 + p2.toUpperCase()); }
function normSkillKey(name){ return lc(name).replace(/[^a-z0-9]+/g, ""); }

function loadItemChoices(){
  if (!ITEM_CHOICES_KEY) return;
  try{
    const raw = localStorage.getItem(ITEM_CHOICES_KEY);
    ITEM_CHOICES = raw ? JSON.parse(raw) : {};
  }catch(e){
    ITEM_CHOICES = {};
  }
}
function saveItemChoices(){
  if (!ITEM_CHOICES_KEY) return;
  try{ localStorage.setItem(ITEM_CHOICES_KEY, JSON.stringify(ITEM_CHOICES || {})); }catch(e){}
}

function skillOptionsList(){
  const out = [];
  for (const c of CHARACS){
    for (const s of c.skills){
      out.push({ key:`skills.${c.key}.${s}`, label:`${s} (${c.name})`, charKey:c.key });
    }
  }
  return out;
}
function charKeyForSkillName(name){
  const norm = normSkillKey(name);
  if (SKILL_TO_CHAR[norm]) return SKILL_TO_CHAR[norm];
  const lcName = String(name||"").toLowerCase();
  const hit = CHARACS.find(c=> (c.skills||[]).some(s=> String(s||"").toLowerCase() === lcName));
  return hit ? hit.key : "";
}
async function fetchSchools(){
  if (SCHOOLS.length) return SCHOOLS;
  const res = await api("/schools");
  SCHOOLS = res.schools || [];
  return SCHOOLS;
}

function normalizeChoiceEntry(val){
  if (!val) return { base:"", picks:[] };
  if (Array.isArray(val)) return { base:"", picks: val.filter(Boolean) };
  const picks = Array.isArray(val.picks) ? val.picks.slice()
    : Array.isArray(val.selected) ? val.selected.slice()
    : [];
  const base = val.base || val.source || "";
  return { base, picks: picks.filter(Boolean) };
}
function choiceMaxForMod(mod){
  if (!mod) return 1;
  const choice = (mod.choice && typeof mod.choice === "object") ? mod.choice : {};
  const rawChoice = choice.max_choices ?? choice.max_choice ?? choice.choice_max ?? choice.max ?? choice.maxChoices ?? choice.choiceMax;
  const raw = (rawChoice != null && rawChoice !== "") ? rawChoice
    : (mod.max_choices ?? mod.choice_max ?? mod.max_choice ?? mod.choiceMax ?? mod.choice_max_choices ?? mod.choiceMaxChoices);
  const parsed = Number(raw);
  return Number.isFinite(parsed) ? Math.max(0, parsed) : 1;
}
function collectModifierGroups(mods){
  const map = new Map();
  (mods || []).forEach((m, idx)=>{
    const name = String(m?.group || "").trim();
    if (!name) return;
    const max = 1;
    const modIdx = Number.isFinite(Number(m?.__mod_idx)) ? Number(m.__mod_idx) : idx;
    const entry = map.get(name) || { name, max, options: [] };
    entry.options.push({ idx: modIdx, mod: m });
    map.set(name, entry);
  });
  return Array.from(map.values());
}
function resolveModifierGroupSelections(mods, stored = {}){
  const groups = collectModifierGroups(mods);
  const selections = {};
  const active = new Set();
  groups.forEach(g=>{
    const allowed = g.options.map(o=> o.idx);
    const limit = g.max > 0 ? g.max : allowed.length;
    const saved = Array.isArray(stored?.[g.name]) ? stored[g.name] : [];
    let picks = saved.map(x=> Number(x)).filter(i=> allowed.includes(i));
    if (!picks.length){
      picks = allowed.slice(0, limit);
    }else if (limit > 0 && picks.length > limit){
      picks = picks.slice(0, limit);
    }
    selections[g.name] = picks;
    picks.forEach(i=> active.add(i));
  });
  return { groups, selections, active };
}
function normalizeRestrict(choice){
  if (!choice) return [];
  const src = choice.choice || choice;
  if (Array.isArray(src.restrict)) return src.restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(src.choice_restrict)) return src.choice_restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(src.restrict_list)) return src.restrict_list.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(choice.restrict)) return choice.restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(choice.choice_restrict)) return choice.choice_restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(choice.restrict_list)) return choice.restrict_list.map(s=> String(s).trim()).filter(Boolean);
  const txt = src.restrict_text || src.choice_restrict || src.restrict_list || src.restrict || src.restrict_string ||
    choice.restrict_text || choice.choice_restrict || choice.restrict_list || choice.restrict || choice.restrict_string || "";
  if (typeof txt === "string"){
    return String(txt).split(",").map(s=>s.trim()).filter(Boolean);
  }
  return [];
}
function normalizeChoiceAllowed(choice){
  if (!choice) return [];
  const src = choice.choice || choice;
  if (Array.isArray(src.choices)) return src.choices.map(s=> String(s).trim()).filter(Boolean);
  const txt = src.choices_text || "";
  if (typeof txt === "string" && txt.trim()){
    return txt.split(",").map(s=> s.trim()).filter(Boolean);
  }
  return [];
}
function itemChoiceState(itemId, kind){
  const byItem = ITEM_CHOICES[itemId] || {};
  return normalizeChoiceEntry(byItem[kind]);
}

function prettyTargetLabel(target){
  const t = String(target||"").trim();
  if (!t) return "(unknown target)";
  if (t.startsWith("choice:")){
    const inner = t.replace(/^choice:/,"");
    const base = prettyTargetLabel(inner);
    return base.startsWith("[Choice]") ? base : `[Choice] ${base}`;
  }
  const cm = t.match(/^char\\.(.+)$/i);
  if (cm){
    const key = cm[1].toLowerCase();
    const hit = CHARACS.find(c=> c.key === key);
    return hit ? `${hit.name} (Characteristic)` : t;
  }
  const sm = t.match(/^skills\\.([^.]+)\\.(.+)$/i);
  if (sm){
    const ckey = sm[1].toLowerCase();
    const sk = sm[2];
    const hit = CHARACS.find(c=> c.key === ckey);
    return hit ? `${sk} (${hit.name})` : `Skill: ${sk}`;
  }
  const im = t.match(/^intensities\\.(.+)$/i);
  if (im) return `Intensity: ${im[1]}`;
  const sch = t.match(/^schools\\.(.+)$/i);
  if (sch){
    const raw = sch[1];
    const found = (SCHOOLS||[]).find(s=> String(s.id||"").toLowerCase() === String(raw).toLowerCase());
    return found ? `${found.name} (School)` : `School: ${raw}`;
  }
  const md = t.match(/^magic_damage\\.(spell|weapon)\\.(.+)$/i);
  if (md) return `${md[2]} magic damage (${md[1]})`;
  const sg = t.match(/^skills\\.by_char\\.(.+)$/i);
  if (sg) return `Skills linked to ${sg[1]}`;
  const sn = t.match(/^schools\\.by_nature\\.(.+)$/i);
  if (sn) return `Schools linked to ${sn[1]}`;
  const ss = t.match(/^schools\\.by_skill\\.(.+)$/i);
  if (ss) return `Schools using ${ss[1]}`;
  if (t === "skill_ms") return "Magic School (by skill)";
  if (t === "nature_ms") return "Magic School (by nature)";
  if (t === "char_skill") return "Skill linked to characteristic";
  if (t === "school_any" || t === "school_ms") return "Magic School";
  if (t === "intensity_any") return "Intensity";
  return t;
}

async function choiceItemsForKind(kind, restrict, allowed){
  const rset = new Set((restrict||[]).map(x=> String(x).trim().toLowerCase()));
  const aset = new Set((allowed||[]).map(x=> String(x).trim().toLowerCase()));
  const useAllow = aset.size > 0;
  const isRestricted = (...cands)=>{
    for (const c of cands){
      if (c == null) continue;
      const base = String(c).trim().toLowerCase();
      if (!base) continue;
      if (rset.has(base)) return true;
      const noPrefix = base.replace(/^(skills|schools|intensities)\\./,"");
      if (rset.has(noPrefix)) return true;
      const beforeParen = base.split("(")[0].trim();
      if (beforeParen && rset.has(beforeParen)) return true;
      const noDots = noPrefix.replace(/[\\.\\s]+/g,"");
      if (noDots && rset.has(noDots)) return true;
    }
    return false;
  };
  const isAllowed = (...cands)=>{
    if (!useAllow) return true;
    for (const c of cands){
      if (c == null) continue;
      const base = String(c).trim().toLowerCase();
      if (!base) continue;
      if (aset.has(base)) return true;
      const noPrefix = base.replace(/^(skills|schools|intensities)\\./,"");
      if (aset.has(noPrefix)) return true;
    }
    return false;
  };
  if (kind === "skill_ms"){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const skillsWithSchools = new Set(
      (SCHOOLS || [])
        .filter(s=> s.linked_skill)
        .map(s=> normSkillKey(s.linked_skill))
    );
    if (!skillsWithSchools.size) return [];
    return skillOptionsList().filter(o=>{
      const skillName = (o.label || "").split("(")[0].trim();
      const norm = normSkillKey(skillName);
      if (skillsWithSchools.size && !skillsWithSchools.has(norm)) return false;
      return !isRestricted(o.key, o.label, o.charKey, norm, skillName);
    });
  }
  if (kind === "char_skill"){
    return skillOptionsList().filter(o=>{
      const skillName = (o.label || "").split("(")[0].trim();
      const norm = normSkillKey(skillName);
      if (!isAllowed(o.key, o.label, o.charKey, norm, skillName)) return false;
      return !isRestricted(o.charKey, skillName, norm, o.key, o.label);
    });
  }
  const charGroup = kind.match(/^skills\\.by_char\\.(.+)$/i);
  if (charGroup){
    const key = charGroup[1].toLowerCase();
    const hit = CHARACS.find(c=> c.key === key);
    if (!hit) return [];
    return (hit.skills || []).map(sk=>({ key:`skills.${key}.${sk}`, label:`${sk} (${hit.name||hit.label||key})` })).filter(o=>{
      const skillName = (o.label || "").split("(")[0].trim();
      const norm = normSkillKey(skillName);
      if (!isAllowed(o.key, o.label, key, norm, skillName)) return false;
      return !isRestricted(o.key, o.label, key, norm, skillName);
    });
  }
  if (kind === "nature_ms" || kind === "magic_weapon" || kind === "magic_spell"){
    if (kind === "nature_ms" && !SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const linkedNatures = new Set();
    if (kind === "nature_ms" && SCHOOLS.length){
      (SCHOOLS||[]).forEach(s=> (s.linked_intensities||[]).forEach(n=> linkedNatures.add(lc(n))));
    }
    return INTENSITIES.map(n=>({ key:`intensities.${n}`, label:n })).filter(o=>{
      const base = lc(o.label);
      if (kind === "nature_ms" && linkedNatures.size && !linkedNatures.has(base)) return false;
      if (!isAllowed(o.key, o.label, base)) return false;
      return !isRestricted(o.label, o.key, base);
    });
  }
  if (kind === "intensity_any"){
    return INTENSITIES.map(n=>({ key:`intensities.${n}`, label:n })).filter(o=> !isRestricted(o.key, o.label));
  }
  const schoolSkill = kind.match(/^schools\\.by_skill\\.(.+)$/i);
  if (schoolSkill){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const skillName = schoolSkill[1];
    return (SCHOOLS||[]).filter(s=> String(s.linked_skill || "").toLowerCase() === String(skillName).toLowerCase())
      .map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||"simple"})` }))
      .filter(o=>{
        const baseLabel = (o.label || "").split("(")[0].trim().toLowerCase();
        const rawId = String(o.key||"").replace(/^schools\\./i,"");
        if (!isAllowed(o.key, baseLabel, rawId)) return false;
        return !isRestricted(o.label, o.key, baseLabel, rawId);
      });
  }
  const schoolNature = kind.match(/^schools\\.by_nature\\.(.+)$/i);
  if (schoolNature){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const nature = schoolNature[1];
    return (SCHOOLS||[]).filter(s=> (s.linked_intensities || []).some(n=> String(n).toLowerCase() === String(nature).toLowerCase()))
      .map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||"simple"})` }))
      .filter(o=>{
        const baseLabel = (o.label || "").split("(")[0].trim().toLowerCase();
        const rawId = String(o.key||"").replace(/^schools\\./i,"");
        if (!isAllowed(o.key, baseLabel, rawId)) return false;
        return !isRestricted(o.label, o.key, baseLabel, rawId);
      });
  }
  if (kind === "school_ms" || kind === "school_any"){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    return (SCHOOLS||[]).map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||"simple"})` })).filter(o=>{
      const baseLabel = (o.label || "").split("(")[0].trim().toLowerCase();
      function rawKey(){ return String(o.key||"").replace(/^schools\\./i,""); }
      if (!isAllowed(o.key, baseLabel, rawKey())) return false;
      return !isRestricted(o.label, o.key, baseLabel, rawKey());
    });
  }
  return [];
}

function itemChoiceMods(it){
  const mods = [];
  (it.modifiers || []).forEach((m, idx)=>{
    if (String(m.target||"").startsWith("choice:")) mods.push({ ...m, __source:"Item", __mod_idx: idx });
  });
  return mods;
}
function resolveUpgradeModifiers(u, meta){
  const holder = (Array.isArray(u?.holder_modifiers) && u.holder_modifiers.length) ? u.holder_modifiers : [];
  if (holder.length) return holder;
  const mods = Array.isArray(u?.modifiers) ? u.modifiers : [];
  if (mods.length) return mods;
  const metaHolder = (Array.isArray(meta?.holder_modifiers) && meta.holder_modifiers.length) ? meta.holder_modifiers : [];
  if (metaHolder.length) return metaHolder;
  return Array.isArray(meta?.modifiers) ? meta.modifiers : [];
}
function upgradeChoiceMods(u, meta, choiceKey){
  const name = meta?.name || u?.name || u?.id || "Upgrade";
  const mods = resolveUpgradeModifiers(u, meta);
  const out = [];
  (mods || []).forEach((m, idx)=>{
    if (!String(m.target||"").startsWith("choice:")) return;
    out.push({
      ...m,
      __source:`Upgrade: ${name}`,
      __choice_key: choiceKey || "",
      __mod_idx: idx
    });
  });
  return out;
}
function itemHasChoice(it){
  return itemChoiceMods(it).length > 0;
}
function itemChoiceKey(it){
  const key = String(it?.item_id || it?.id || "").trim();
  if (key) return key;
  const name = String(it?.name || "").trim();
  return name || "";
}
function upgradeChoiceKeyLegacy(it, upgrade, idx){
  const itemKey = itemChoiceKey(it);
  if (!itemKey) return "";
  const upgId = String(upgrade?.id || upgrade?.key || upgrade || "").trim() || "upgrade";
  const target = String(upgrade?.target || "").trim() || "any";
  const pos = Number.isFinite(idx) ? idx : 0;
  return `${itemKey}::upg:${upgId}:${target}:${pos}`;
}
function upgradeChoiceKey(it, upgrade, idx){
  const itemKey = itemChoiceKey(it);
  if (!itemKey) return "";
  const choiceId = String(upgrade?.choice_id || upgrade?.choiceId || upgrade?.uid || "").trim();
  if (choiceId) return `${itemKey}::upg:${choiceId}`;
  return upgradeChoiceKeyLegacy(it, upgrade, idx);
}
function migrateUpgradeChoiceKeys(items){
  let changed = false;
  (items || []).forEach(it=>{
    (it.upgrades || []).forEach((u, idx)=>{
      const legacyKey = upgradeChoiceKeyLegacy(it, u, idx);
      const newKey = upgradeChoiceKey(it, u, idx);
      if (!legacyKey || !newKey || legacyKey === newKey) return;
      if (ITEM_CHOICES[legacyKey] && !ITEM_CHOICES[newKey]){
        ITEM_CHOICES[newKey] = ITEM_CHOICES[legacyKey];
        changed = true;
      }
      if (ITEM_CHOICES[legacyKey]){
        delete ITEM_CHOICES[legacyKey];
        changed = true;
      }
    });
  });
  return changed;
}
function pruneItemChoices(){
  if (!INV) return;
  const ids = new Set();
  (INV.items || []).forEach(it=>{
    const baseKey = itemChoiceKey(it);
    if (baseKey) ids.add(baseKey);
    (it.upgrades || []).forEach((u, idx)=>{
      ids.add(upgradeChoiceKey(it, u, idx));
    });
  });
  Object.keys(ITEM_CHOICES).forEach(id=>{ if (!ids.has(String(id))) delete ITEM_CHOICES[id]; });
  saveItemChoices();
}

async function openChoiceModalGeneric(mods, existingMap = {}, saveHandler = ()=>{}, { titleText = "Configure choices", enableGroups = false } = {}){
  if (!mods.length) return false;
  try{ if (!SCHOOLS.length) await fetchSchools(); }catch{}
  choiceTitle.textContent = titleText || "Configure choices";
  choiceBody.innerHTML = '<div class="muted">Loading choices...</div>';
  choiceModal.classList.remove("hidden");

  const blocks = [];
  choiceBody.innerHTML = "";
  const groupInfo = enableGroups ? resolveModifierGroupSelections(mods, existingMap?._groups || {}) : { groups:[], selections:{}, active:new Set() };
  const groupSelections = groupInfo.selections || {};
  let groupActive = new Set(groupInfo.active || []);
  const applyGroupLocks = ()=>{
    if (!groupInfo.groups.length) return;
    blocks.forEach(b=>{
      if (!b.groupName) return;
      const enabled = groupActive.has(b.modIdx);
      b.setEnabled?.(enabled);
    });
  };
  if (groupInfo.groups.length){
    const groupPanel = document.createElement("div");
    groupPanel.className = "panel";
    const header = document.createElement("div");
    header.innerHTML = `<strong>Exclusive groups</strong> <span class="muted">(select options per group)</span>`;
    groupPanel.appendChild(header);
    groupInfo.groups.forEach(g=>{
      const block = document.createElement("div");
      block.style.marginTop = "8px";
      const title = document.createElement("div");
      title.innerHTML = `<strong>${g.name}</strong> <span class="muted">(max ${g.max || "no limit"})</span>`;
      block.appendChild(title);
      const list = document.createElement("div");
      list.className = "choice-table";
      const counter = document.createElement("div");
      counter.className = "muted choice-counter";
      const updateCounter = ()=>{
        const checked = list.querySelectorAll(`input[data-group=\"${g.name}\"]:checked`).length;
        counter.textContent = `Selected ${checked}${g.max>0?` / ${g.max}`:""}`;
      };
      g.options.forEach(opt=>{
        const row = document.createElement("label");
        row.className = "choice-row";
        row.style.gridTemplateColumns = "auto 1fr";
        const input = document.createElement("input");
        input.type = g.max === 1 ? "radio" : "checkbox";
        input.name = `group-${g.name}`;
        input.dataset.group = g.name;
        input.value = String(opt.idx);
        input.checked = (groupSelections[g.name] || []).includes(opt.idx);
        input.addEventListener("change", ()=>{
          const checked = list.querySelectorAll(`input[data-group=\"${g.name}\"]:checked`);
          if (g.max === 1){
            checked.forEach(cb=>{ if (cb !== input) cb.checked = false; });
          }else if (g.max > 0 && checked.length > g.max){
            input.checked = false;
          }
          const picks = Array.from(list.querySelectorAll(`input[data-group=\"${g.name}\"]:checked`)).map(cb=> Number(cb.value));
          groupSelections[g.name] = picks;
          groupActive = new Set();
          Object.values(groupSelections).forEach(arr=> (arr || []).forEach(i=> groupActive.add(i)));
          applyGroupLocks();
          updateCounter();
        });
        row.appendChild(input);
        const label = document.createElement("span");
        label.textContent = prettyTargetLabel(opt.mod?.target || opt.mod?.key || opt.mod?.name || "Option");
        row.appendChild(label);
        list.appendChild(row);
      });
      updateCounter();
      block.appendChild(list);
      block.appendChild(counter);
      groupPanel.appendChild(block);
    });
    choiceBody.appendChild(groupPanel);
  }
  const choicesWrap = document.createElement("div");
  choiceBody.appendChild(choicesWrap);

  const normalizeMsBase = (kind, picks)=>{
    if (!picks || !picks.length || !SCHOOLS.length) return "";
    const first = String(picks[0]||"").replace(/^schools\\./i, "");
    const school = (SCHOOLS||[]).find(s=> String(s.id||"").toLowerCase() === first.toLowerCase() || String(s.name||"").toLowerCase() === first.toLowerCase());
    if (!school) return "";
    if (kind === "skill_ms" && school.linked_skill){
      const ck = charKeyForSkillName(school.linked_skill);
      return ck ? `skills.${ck}.${school.linked_skill}` : "";
    }
    if (kind === "nature_ms"){
      const n = (school.linked_intensities || [])[0];
      return n ? `intensities.${n}` : "";
    }
    return "";
  };
  const buildMsBaseOptions = (kind, restrict=[])=>{
    const rset = new Set((restrict||[]).map(x=> String(x).toLowerCase()));
    if (kind === "skill_ms"){
      const map = new Map();
      (SCHOOLS||[]).forEach(s=>{
        if (!s.linked_skill) return;
        const ck = charKeyForSkillName(s.linked_skill);
        if (!ck) return;
        const norm = normSkillKey(s.linked_skill);
        if (rset.has(norm) || rset.has(lc(s.linked_skill)) || rset.has(ck.toLowerCase())) return;
        const key = `skills.${ck}.${s.linked_skill}`;
        const list = map.get(key) || [];
        list.push(s.name || s.id);
        map.set(key, list);
      });
      return Array.from(map.entries()).map(([key, schools])=>{
        const parts = key.split(".");
        const skillName = parts.slice(2).join(".");
        const ck = parts[1] || "";
        const label = `${skillName} (${title(ck)}) - Schools: ${Array.from(new Set(schools)).join(", ")}`;
        return { key, label };
      }).sort((a,b)=> a.label.localeCompare(b.label));
    }
    if (kind === "nature_ms"){
      const map = new Map();
      (SCHOOLS||[]).forEach(s=>{
        (s.linked_intensities || []).forEach(n=>{
          const norm = lc(n);
          if (rset.has(norm) || rset.has(`intensities.${norm}`)) return;
          const key = `intensities.${n}`;
          const list = map.get(key) || [];
          list.push(s.name || s.id);
          map.set(key, list);
        });
      });
      return Array.from(map.entries()).map(([key, schools])=>{
        const label = `${key.replace(/^intensities\\./i,"")} - Schools: ${Array.from(new Set(schools)).join(", ")}`;
        return { key, label };
      }).sort((a,b)=> a.label.localeCompare(b.label));
    }
    return [];
  };
  const schoolsForMsBase = (kind, baseKey, restrict=[])=>{
    if (!baseKey) return [];
    const rset = new Set((restrict||[]).map(x=> String(x).toLowerCase()));
    const matches = (SCHOOLS||[]).filter(s=>{
      if (kind === "skill_ms"){
        const skillName = baseKey.split(".").slice(2).join(".");
        return lc(s.linked_skill) === lc(skillName);
      }
      if (kind === "nature_ms"){
        const nature = baseKey.replace(/^intensities\\./i,"");
        return (s.linked_intensities || []).some(n=> lc(n) === lc(nature));
      }
      return false;
    });
    return matches.map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||"simple"})` })).filter(opt=>{
      const base = (opt.label || "").split("(")[0].trim().toLowerCase();
      const key = String(opt.key||"").toLowerCase();
      const plain = key.replace(/^schools\\./i,"");
      return !(rset.has(base) || rset.has(key) || rset.has(plain));
    });
  };

  for (const [modIdxFallback, m] of mods.entries()){
    const kind = String(m.target||"").replace("choice:","");
    const restrict = normalizeRestrict(m);
    const allowed = normalizeChoiceAllowed(m);
    const max = choiceMaxForMod(m);
    const modIdx = Number.isFinite(Number(m?.__mod_idx)) ? Number(m.__mod_idx) : modIdxFallback;
    const groupName = String(m?.group || "").trim();
    const block = document.createElement("div");
    block.className = "panel";
    const setEnabled = (enabled)=>{
      block.style.opacity = enabled ? "" : "0.55";
      block.querySelectorAll("input, select, button").forEach(el=>{
        if (el.tagName === "BUTTON" || el.tagName === "SELECT" || el.tagName === "INPUT"){
          el.disabled = !enabled;
        }
      });
    };
    const titleEl = document.createElement("div");
    const srcNote = m.__source ? `<div class="muted" style="font-size:0.85rem;">${m.__source}</div>` : "";
    titleEl.innerHTML = `<strong>${kind.replace(/_/g," ")}</strong> <span class="muted">(max ${max||"no limit"})</span>${srcNote}`;
    block.appendChild(titleEl);

    if (kind === "skill_ms" || kind === "nature_ms"){
      const state = normalizeChoiceEntry(existingMap[kind]);
      const baseOpts = buildMsBaseOptions(kind, restrict);
      const baseWrap = document.createElement("div");
      baseWrap.className = "row";
      const baseLabel = document.createElement("label");
      baseLabel.className = "muted";
      baseLabel.textContent = kind === "skill_ms" ? "Select skill" : "Select nature";
      const baseSelect = document.createElement("select");
      baseSelect.innerHTML = '<option value="">-- choose --</option>';
      baseOpts.forEach(opt=>{
        const o = document.createElement("option");
        o.value = opt.key; o.textContent = opt.label;
        baseSelect.appendChild(o);
      });
      const inferredBase = state.base || normalizeMsBase(kind, state.picks);
      if (inferredBase && baseOpts.some(o=> o.key === inferredBase)){
        baseSelect.value = inferredBase;
      }
      baseWrap.appendChild(baseLabel);
      baseWrap.appendChild(baseSelect);

      const schoolsWrap = document.createElement("div");
      schoolsWrap.className = "choice-wrap";
      schoolsWrap.style.display = "grid";
      schoolsWrap.style.gridTemplateColumns = "repeat(auto-fit,minmax(220px,1fr))";
      schoolsWrap.style.gap = "8px";

      const counter = document.createElement("div");
      counter.className = "muted";
      counter.style.marginTop = "4px";

      const renderSchools = ()=>{
        schoolsWrap.innerHTML = "";
        const baseVal = baseSelect.value;
        if (!baseVal){
          const hint = document.createElement("div");
          hint.className = "muted";
          hint.textContent = "Choose a base option to see linked schools.";
          schoolsWrap.appendChild(hint);
          counter.textContent = "Selected 0";
          return;
        }
        const items = schoolsForMsBase(kind, baseVal, restrict);
        if (!items.length){
          const empty = document.createElement("div");
          empty.className = "muted";
          empty.textContent = "No schools linked to that choice.";
          schoolsWrap.appendChild(empty);
          counter.textContent = "Selected 0";
          return;
        }
        const picks = new Set(state.picks);
        items.forEach(opt=>{
          const row = document.createElement("label");
          row.style.display = "flex";
          row.style.gap = "8px";
          row.style.alignItems = "center";
          row.style.margin = "2px 0";
          const input = document.createElement("input");
          input.type = max === 1 ? "radio" : "checkbox";
          input.name = `choice-${kind}`;
          input.dataset.choice = kind;
          input.value = opt.key;
          input.checked = picks.has(opt.key);
          input.addEventListener("change", ()=>{
            const checked = schoolsWrap.querySelectorAll(`input[data-choice=\"${kind}\"]:checked`);
            if (max === 1){
              checked.forEach(cb=>{ if (cb !== input) cb.checked = false; });
            }else if (max > 0 && checked.length > max){
              input.checked = false;
            }
            counter.textContent = `Selected ${schoolsWrap.querySelectorAll(`input[data-choice=\"${kind}\"]:checked`).length}${max>0?` / ${max}`:""}`;
          });
          row.appendChild(input);
          const span = document.createElement("span");
          span.textContent = opt.label;
          row.appendChild(span);
          schoolsWrap.appendChild(row);
        });
        counter.textContent = `Selected ${schoolsWrap.querySelectorAll(`input[data-choice=\"${kind}\"]:checked`).length}${max>0?` / ${max}`:""}`;
      };
      baseSelect.addEventListener("change", ()=>{ state.base = baseSelect.value; renderSchools(); });
      renderSchools();

      block.appendChild(baseWrap);
      block.appendChild(schoolsWrap);
      block.appendChild(counter);
      choicesWrap.appendChild(block);
      blocks.push({ kind, max, node: schoolsWrap, baseSelect, isMs: true, groupName, modIdx, setEnabled });
      continue;
    }

    const state = normalizeChoiceEntry(existingMap[kind]);
    const items = await choiceItemsForKind(kind, restrict, allowed);
    let rows = [];
    if (!items.length){
      const empty = document.createElement("div");
      empty.className = "muted";
      empty.textContent = "No available options.";
      block.appendChild(empty);
    }else{
      const picks = Array.from(new Set((state.picks || []).filter(p=> items.some(opt=> opt.key === p))));
      const maxRows = max > 0 ? Math.min(max, items.length) : items.length;
      const table = document.createElement("div");
      table.className = "choice-table";
      const actions = document.createElement("div");
      actions.className = "choice-actions";
      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.className = "btn small";
      addBtn.textContent = "Add choice";
      const counter = document.createElement("div");
      counter.className = "muted choice-counter";

      rows = [];
      const getSelects = ()=> rows.map(r=> r.select);
      const getSelectedValues = ()=> getSelects().map(sel=> sel.value).filter(Boolean);
      const enforceUnique = (changed)=>{
        const seen = new Set();
        const all = getSelects();
        const ordered = changed ? [changed, ...all.filter(s=> s !== changed)] : all;
        ordered.forEach(sel=>{
          const val = sel.value;
          if (!val) return;
          if (seen.has(val)){
            sel.value = "";
          }else{
            seen.add(val);
          }
        });
      };
      const rebuildOptions = ()=>{
        const values = getSelectedValues();
        getSelects().forEach(sel=>{
          const current = sel.value;
          const taken = new Set(values.filter(v=> v !== current));
          sel.innerHTML = '<option value="">-- choose --</option>';
          items.forEach(opt=>{
            if (taken.has(opt.key)) return;
            const o = document.createElement("option");
            o.value = opt.key;
            o.textContent = opt.label;
            sel.appendChild(o);
          });
          if (current && !Array.from(sel.options).some(o=> o.value === current)){
            sel.value = "";
          }else{
            sel.value = current;
          }
        });
      };
      const updateActions = ()=>{
        const selected = getSelectedValues().length;
        counter.textContent = `Selected ${selected}${max>0?` / ${max}`:""}`;
        const maxReached = rows.length >= maxRows;
        const remaining = items.length - new Set(getSelectedValues()).size;
        addBtn.disabled = maxReached || remaining <= 0;
        rows.forEach(r=>{ r.removeBtn.disabled = rows.length <= 1; });
        if (max === 1) addBtn.style.display = "none";
      };
      const syncUI = (changed)=>{
        enforceUnique(changed);
        rebuildOptions();
        updateActions();
      };
      const addRow = (value="")=>{
        const row = document.createElement("div");
        row.className = "choice-row";
        const select = document.createElement("select");
        select.dataset.choice = kind;
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "btn small choice-remove";
        removeBtn.textContent = "Remove";
        removeBtn.addEventListener("click", ()=>{
          const idx = rows.findIndex(r=> r.row === row);
          if (idx >= 0) rows.splice(idx, 1);
          row.remove();
          syncUI();
        });
        select.addEventListener("change", ()=> syncUI(select));
        row.appendChild(select);
        row.appendChild(removeBtn);
        table.appendChild(row);
        rows.push({ row, select, removeBtn });
        if (value) select.value = value;
      };

      const initial = picks.slice(0, max > 0 ? max : picks.length);
      if (initial.length){
        initial.forEach(()=> addRow(""));
      }else{
        addRow("");
      }
      syncUI();
      if (initial.length){
        rows.forEach((r, idx)=>{ r.select.value = initial[idx] || ""; });
        syncUI();
      }
      addBtn.addEventListener("click", ()=>{
        if (rows.length >= maxRows) return;
        addRow("");
        syncUI();
      });

      actions.appendChild(addBtn);
      actions.appendChild(counter);
      block.appendChild(table);
      block.appendChild(actions);
    }
    choicesWrap.appendChild(block);
    blocks.push({ kind, max, rows, isMs: false, groupName, modIdx, setEnabled });
  }

  applyGroupLocks();
  return new Promise(resolve=>{
    const close = (saved=false)=>{
      choiceModal.classList.add("hidden");
      resolve(saved);
    };
    const save = ()=>{
      const selections = (existingMap && !Array.isArray(existingMap)) ? { ...existingMap } : {};
      for (const b of blocks){
        let picks = [];
        if (b.isMs){
          picks = Array.from(b.node.querySelectorAll(`input[data-choice=\"${b.kind}\"]:checked`)).map(i=> i.value);
        }else{
          picks = (b.rows || []).map(r=> r.select?.value || "").filter(Boolean);
          if (b.max > 0 && picks.length > b.max){
            alert(`Select at most ${b.max} option(s) for ${b.kind.replace(/_/g," ")}.`);
            return;
          }
        }
        selections[b.kind] = { base: b.baseSelect?.value || "", picks };
      }
      if (groupInfo.groups.length){
        selections._groups = { ...groupSelections };
      }
      saveHandler(selections);
      close(true);
    };
    const closeBtn = ()=>close(false);
    choiceClose.onclick = closeBtn;
    choiceCancel.onclick = closeBtn;
    choiceSave.onclick = save;
  });
}

async function openItemChoiceModal(it){
  const mods = itemChoiceMods(it);
  if (!mods.length) return false;
  const key = itemChoiceKey(it);
  return openChoiceModalGeneric(mods, ITEM_CHOICES[key] || {}, (selections)=>{
    if (!key) return;
    ITEM_CHOICES[key] = selections;
    saveItemChoices();
  }, { titleText: `Configure: ${it.alt_name || it.name || "Item"}`, enableGroups: true });
}

async function openUpgradeChoiceModal(it, upgrade, idx){
  const upgId = upgrade?.id || upgrade?.key || upgrade;
  const meta = (window.UPGRADE_META || {})[upgId] || {};
  const choiceKey = upgradeChoiceKey(it, upgrade, idx);
  const legacyKey = upgradeChoiceKeyLegacy(it, upgrade, idx);
  const mods = upgradeChoiceMods(upgrade, meta, choiceKey);
  if (!mods.length) return false;
  if (!choiceKey) return false;
  const existing = ITEM_CHOICES[choiceKey] || (legacyKey ? ITEM_CHOICES[legacyKey] : {}) || {};
  return openChoiceModalGeneric(mods, existing, (selections)=>{
    ITEM_CHOICES[choiceKey] = selections;
    if (legacyKey && legacyKey !== choiceKey) ITEM_CHOICES[legacyKey] = selections;
    saveItemChoices();
  }, { titleText: `Configure: ${meta.name || upgrade?.name || "Upgrade"}`, enableGroups: true });
}

function qualityPrice(base, target){
  const raw = Math.round(Number(base || 0));
  const diff = QUALITY_DIFFS[target] ?? 0;
  return Math.max(0, raw + diff);
}

function updateQualityCostPreview(){
  if (!QUALITY_CTX || !qualityTargetSelect || !qualityCostDisplay) return;
  const base = Number(QUALITY_CTX.base_price || QUALITY_CTX.paid_unit || 0);
  const qty = Number(QUALITY_CTX.quantity || 1);
  const currentQuality = QUALITY_CTX.current_quality || "Adequate";
  const target = qualityTargetSelect.value || "";
  if (!target){
    qualityCostDisplay.textContent = "Select a target quality to preview the cost.";
    return;
  }
  const oldUnit = qualityPrice(base, currentQuality);
  const newUnit = qualityPrice(base, target);
  const perUnitDelta = Math.max(0, newUnit - oldUnit);
  const totalDelta = perUnitDelta * qty;
  const modifier = Math.max(0, parseFloat(qualityPriceInput?.value || "1") || 1);
  const adjusted = Math.round(totalDelta * modifier);
  qualityCostDisplay.textContent =
    `Current: ${currentQuality} (${oldUnit} each). Target: ${target} (${newUnit} each). ` +
    `Delta: ${perUnitDelta} each / ${totalDelta} total. Adjusted (x${modifier.toFixed(2)}): ${adjusted}.`;
}

function populateQualityCurrencyOptions(){
  if (!qualityCurrencySelect) return;
  const currencies = Object.keys((INV?.currencies) || {});
  const keys = currencies.length ? currencies : ["Jelly"];
  qualityCurrencySelect.innerHTML = "";
  keys.forEach(k=>{
    const opt = document.createElement("option");
    opt.value = k;
    opt.textContent = k;
    qualityCurrencySelect.appendChild(opt);
  });
  const preferred = $("#global-cur")?.value;
  if (preferred && keys.includes(preferred)){
    qualityCurrencySelect.value = preferred;
  }
}

function openQualityUpgradeModal(it){
  if (!qualityModal) return;
  const title = it.alt_name ? `${it.alt_name} (${it.name || "Item"})` : (it.name || "Item");
  qualityTitle.textContent = `Upgrade: ${title}`;
  const currentQuality = it.quality || "Adequate";
  const startIdx = Math.max(0, QUALITIES.indexOf(currentQuality) + 1);
  const nextQualities = QUALITIES.slice(startIdx);
  const qty = Number(it.quantity || 1);
  const basePrice = Number(it.base_price ?? it.paid_unit ?? 0);
  if (!nextQualities.length){
    qualityBody.innerHTML = `<div class="muted">This item is already at ${currentQuality}, the highest quality.</div>`;
    qualityUpgradeBtn.disabled = true;
    qualityModal.classList.remove("hidden");
    return;
  }
  qualityBody.innerHTML = `
    <div class="row" style="gap:10px;">
      <div class="muted">Current quality: <strong>${currentQuality}</strong></div>
      <div class="muted">Quantity: <strong>${qty}</strong></div>
    </div>
    <div class="row" style="gap:10px;align-items:flex-end;">
      <div style="flex:1;">
        <label class="muted">Target quality</label>
        <select id="quality-target"></select>
      </div>
      <div style="flex:1;">
        <label class="muted">Price modifier</label>
        <input id="quality-price-mod" type="number" min="0" step="0.01" value="1">
      </div>
    </div>
    <div class="row" style="gap:10px;align-items:flex-end;">
      <div style="flex:1;">
        <label class="muted">Currency</label>
        <select id="quality-currency"></select>
      </div>
      <div style="flex:1;">
        <div id="quality-cost" class="muted" style="margin-top:20px;"></div>
      </div>
    </div>
  `;
  qualityTargetSelect = qualityBody.querySelector("#quality-target");
  qualityPriceInput = qualityBody.querySelector("#quality-price-mod");
  qualityCurrencySelect = qualityBody.querySelector("#quality-currency");
  qualityCostDisplay = qualityBody.querySelector("#quality-cost");
  if (qualityTargetSelect){
    qualityTargetSelect.innerHTML = `<option value="">-- select --</option>` +
      nextQualities.map(q=>`<option value="${q}">${q}</option>`).join("");
    qualityTargetSelect.addEventListener("change", updateQualityCostPreview);
  }
  qualityPriceInput?.addEventListener("input", updateQualityCostPreview);
  QUALITY_CTX = {
    item_id: it.item_id,
    base_price: basePrice,
    paid_unit: Number(it.paid_unit || basePrice),
    quantity: qty,
    current_quality: currentQuality
  };
  populateQualityCurrencyOptions();
  updateQualityCostPreview();
  qualityUpgradeBtn.disabled = false;
  qualityModal.classList.remove("hidden");
}

function closeQualityUpgradeModal(){
  QUALITY_CTX = null;
  if (qualityTargetSelect){
    qualityTargetSelect.removeEventListener("change", updateQualityCostPreview);
  }
  qualityTargetSelect = null;
  if (qualityPriceInput){
    qualityPriceInput.removeEventListener("input", updateQualityCostPreview);
  }
  qualityPriceInput = null;
  qualityCurrencySelect = null;
  qualityCostDisplay = null;
  if (qualityModal) qualityModal.classList.add("hidden");
}

async function confirmQualityUpgrade(){
  if (!QUALITY_CTX) return;
  const target = qualityTargetSelect?.value || "";
  if (!target){
    alert("Pick a target quality.");
    return;
  }
  const currency = qualityCurrencySelect?.value || $("#global-cur")?.value || "Jelly";
  const ok = await upgradeQuality(QUALITY_CTX.item_id, target, currency);
  if (ok) closeQualityUpgradeModal();
}


function broadcastInventoryUpdate(){
  if (!INV) return;
  if (window.parent && window.parent !== window && isEmbed){
    window.parent.postMessage({ type: "inventory-updated", inventory: INV }, location.origin);
  }
}

function applyInventory(inv){
  INV = inv;
  migrateUpgradeChoiceKeys(INV.items || []);
  pruneItemChoices();
  renderInventory();
  populateGlobals();
  broadcastInventoryUpdate();
}

document.addEventListener("DOMContentLoaded", () => {
  loadItemChoices();
  loadInventory();
  $("#search").addEventListener("click", doSearch);
  $("#q").addEventListener("keydown", e=>{ if (e.key==="Enter") doSearch(); });
  $("#tag").addEventListener("keydown", e=>{ if (e.key==="Enter") doSearch(); });
  $("#clear").addEventListener("click", clearSearch);
  $("#add-cont").addEventListener("click", addContainer);
  $("#item-close").addEventListener("click", closeItemModal);
  $("#item-modal").addEventListener("click", (e)=>{ if (e.target === $("#item-modal")) closeItemModal(); });
  $("#choice-modal").addEventListener("click", (e)=>{ if (e.target === $("#choice-modal")) $("#choice-modal").classList.add("hidden"); });
  qualityClose?.addEventListener("click", closeQualityUpgradeModal);
  qualityCloseAction?.addEventListener("click", closeQualityUpgradeModal);
  qualityUpgradeBtn?.addEventListener("click", confirmQualityUpgrade);
  qualityModal?.addEventListener("click", (e)=>{ if (e.target === qualityModal) closeQualityUpgradeModal(); });
  $("#cat-select").addEventListener("change", applyCategoryFilter);
  $("#fund-add").addEventListener("click", addFunds);
});

async function loadInventory(){
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}`, { headers: authHeaders() });
  const j = await r.json();
  if (j.status !== "success") { alert(j.message || "Load failed"); return; }
  applyInventory(j.inventory);
}

function renderInventory(){
  $("#inv-title").textContent = INV.name;

  // money
  const cur = INV.currencies || {};
  $("#money").innerHTML = Object.keys(cur).length
    ? Object.entries(cur).map(([k,v])=>`<span class="pill">${k}: <b>${v}</b></span>`).join(" ")
    : `<span class="muted">No currency set.</span>`;

  // add-funds currency
  const selFund = $("#fund-cur");
  selFund.innerHTML = "";
  const currencies = Object.keys(INV.currencies || {Jelly:0});
  if (!currencies.length) currencies.push("Jelly");
  currencies.forEach(k=>{
    const opt = document.createElement("option");
    opt.value = k; opt.textContent = k;
    selFund.appendChild(opt);
  });

  // enc totals
  $("#enc-total").textContent = Number(INV.enc_total || 0).toFixed(1);

  // group items by container
  const grouped = {};
  for (const it of (INV.items || [])){
    const cid = (it.equipped !== false) ? SELF_CONTAINER_ID : (it.container_id || "");
    (grouped[cid] ||= []).push(it);
  }

  // containers
  const box = $("#containers");
  box.innerHTML = "";
  const containers = (INV.containers || []).slice().sort((a,b)=>{
    if (a.id === SELF_CONTAINER_ID) return -1;
    if (b.id === SELF_CONTAINER_ID) return 1;
    return String(a.name||"").localeCompare(String(b.name||""));
  });
  for (const c of containers){
    const items = grouped[c.id] || [];
    const isSelf = c.id === SELF_CONTAINER_ID;
    const card = document.createElement("div");
    card.className = "container-card";

    const head = document.createElement("div");
    head.className = "container-head";
    head.innerHTML = `
      ${isSelf
        ? `<strong>Self (equipped items)</strong>`
        : `<input value="${escapeHtml(c.name)}" data-id="${c.id}" class="cname" type="text">`
      }
      ${isSelf
        ? `<span class="pill">Always included</span>`
        : `<label class="row" style="gap:6px;">
        <input type="checkbox" class="cinc" data-id="${c.id}" ${c.include ? "checked" : ""}>
        include in total
      </label>`
      }
      <span class="pill">enc: <b>${Number(c.enc_total||0).toFixed(1)}</b></span>
      <span class="pill">items: <b>${items.length}</b></span>
      ${isSelf ? "" : `<button class="btn btn-secondary small rename" data-id="${c.id}">Save</button>`}
    `;
    card.appendChild(head);

    // items list for this container
    const list = document.createElement("div");
    list.className = "items";
    if (!items.length){
      const empty = document.createElement("div");
      empty.className = "muted";
      empty.textContent = "No items in this container.";
      list.appendChild(empty);
    }else{
      for (const it of items){
        const row = document.createElement("div");
        row.className = "item-row";
        row.title = buildModifierSummary(it) || "";
        const hasChoice = itemHasChoice(it);
        const displayName = it.alt_name ? `${escapeHtml(it.alt_name)} <span class="muted">(${escapeHtml(it.name||"Item")})</span>` : escapeHtml(it.name||"Item");
        const totalEnc = (Number(it.enc||0) * Number(it.quantity||1)) || 0;
        const equipped = it.equipped !== false;
        const stowedId = it.stowed_container_id || (it.container_id !== SELF_CONTAINER_ID ? it.container_id : "");

        const info = document.createElement("div");
        info.className = "grow";
        info.innerHTML = `
          <div><b>${displayName}</b></div>
          <div class="muted">x${it.quantity||1} | enc: ${totalEnc.toFixed(1)}</div>
          <div class="muted">${equipped ? '<span class="pill">Equipped</span>' : '<span class="pill" style="background:#331515;border-color:#662222">Unequipped</span>'}</div>
        `;
        const moveTargets = (INV.containers || []).filter(c => c.id !== SELF_CONTAINER_ID);
        const moveWrap = document.createElement("div");
        moveWrap.className = "row";
        moveWrap.style.marginTop = "6px";
        moveWrap.style.gap = "6px";
        const select = document.createElement("select");
        select.className = "move-target";
        select.dataset.id = it.item_id;
        for (const mc of moveTargets){
          const opt = document.createElement("option");
          opt.value = mc.id; opt.textContent = mc.name;
          select.appendChild(opt);
        }
        const preferred = moveTargets.find(mc => mc.id === stowedId);
        if (preferred){ select.value = preferred.id; }
        const moveBtn = document.createElement("button");
        moveBtn.className = "btn small move-btn";
        moveBtn.dataset.id = it.item_id;
        moveBtn.textContent = "Move";
        if (moveTargets.length){
          moveWrap.appendChild(select);
          moveWrap.appendChild(moveBtn);
        }else{
          const hint = document.createElement("div");
          hint.className = "muted";
          hint.textContent = "Add another container to move items.";
          moveWrap.appendChild(hint);
        }
        info.appendChild(moveWrap);

        const toggle = document.createElement("button");
        toggle.className = "btn small";
        if (it.consumable){
          toggle.textContent = "Use";
          toggle.addEventListener("click", async ()=>{
            await useItem(it.item_id);
          });
        }else{
          toggle.textContent = equipped ? "Unequip" : "Equip";
          toggle.addEventListener("click", async ()=>{
            await toggleEquip(it.item_id, !equipped);
          });
        }

        const details = document.createElement("button");
        details.className = "btn small view";
        details.dataset.id = it.item_id;
        details.textContent = "Details";

        row.appendChild(info);
        row.appendChild(toggle);
        if (hasChoice){
          const choices = document.createElement("button");
          choices.className = "btn small";
          choices.textContent = "Choices";
          choices.addEventListener("click", ()=> openItemChoiceModal(it));
          row.appendChild(choices);
        }
        row.appendChild(details);
        list.appendChild(row);
      }
    }
    card.appendChild(list);
    box.appendChild(card);
  }

  // save name
  box.querySelectorAll(".rename").forEach(btn=>{
    btn.addEventListener("click", async ()=>{
      const id = btn.dataset.id;
      const name = box.querySelector(`.cname[data-id="${id}"]`).value.trim() || "Container";
      await patchContainer(id, { name });
    });
  });

  // toggle include
  box.querySelectorAll(".cinc").forEach(ch=>{
    ch.addEventListener("change", async ()=>{
      await patchContainer(ch.dataset.id, { include: ch.checked });
    });
  });

  // item details openers
  box.querySelectorAll(".view").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const it = (INV.items || []).find(x => x.item_id === btn.dataset.id);
      if (!it) return;
      openItemModal(it);
    });
  });
  box.querySelectorAll(".move-btn").forEach(btn=>{
    btn.addEventListener("click", async ()=>{
      const id = btn.dataset.id;
      const sel = box.querySelector(`select.move-target[data-id="${id}"]`);
      const target = sel ? sel.value : "";
      await moveItem(id, target);
    });
  });

  // transactions
  const tx = $("#tx"); tx.innerHTML = "";
  for (const t of (INV.transactions || []).slice(-25).reverse()){
    const div = document.createElement("div");
    div.className = "row";
    div.innerHTML = `<span class="muted">${new Date(t.ts).toLocaleString()}</span> — <b>${t.amount}</b> ${t.currency} — ${escapeHtml(t.note || "")}`;
    tx.appendChild(div);
  }
}

function populateGlobals(){
  // Container selector (global)
  const selC = $("#global-cont");
  selC.innerHTML = "";
  const conts = (INV.containers || []);
  conts.forEach(c=>{
    const opt = document.createElement("option");
    opt.value = c.id; opt.textContent = c.name;
    selC.appendChild(opt);
  });
  const preferred = conts.find(c=>c.id !== SELF_CONTAINER_ID) || conts[0];
  if (preferred){ selC.value = preferred.id; }

  // Currency selector (global)
  const selCur = $("#global-cur");
  selCur.innerHTML = "";
  const currencies = Object.keys(INV.currencies || {Jelly:0});
  if (!currencies.length){ currencies.push("Jelly"); }
  currencies.forEach(k=>{
    const opt = document.createElement("option");
    opt.value = k; opt.textContent = k;
    selCur.appendChild(opt);
  });
  populateQualityCurrencyOptions();

  // Add-funds currency already populated in renderInventory
}

async function patchContainer(cid, body){
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/containers/${encodeURIComponent(cid)}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify(body)
  });
  const j = await r.json();
  if (j.status !== "success") { alert(j.message || "Update failed"); return; }
  applyInventory(j.inventory);
}

async function addContainer(){
  const name = ($("#new-cont-name").value || "Container").trim();
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/containers`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ name })
  });
  const j = await r.json();
  if (j.status !== "success") { alert(j.message || "Create failed"); return; }
  $("#new-cont-name").value = "";
  applyInventory(j.inventory);
}

/* ------------- Add Funds ------------- */
async function addFunds(){
  const currency = $("#fund-cur").value || "Jelly";
  const amount = parseInt($("#fund-amt").value || "0", 10);
  const note = ($("#fund-note").value || "Top up").trim();
  if (!amount || amount <= 0){ alert("Enter a positive amount."); return; }
  if (!confirm(`Add +${amount} ${currency} to this inventory?`)) return;

  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/deposit`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ currency, amount, note })
  });
  const j = await r.json();
  if (j.status !== "success"){ alert(j.message || "Deposit failed"); return; }
  $("#fund-amt").value = "";
  $("#fund-note").value = "";
  applyInventory(j.inventory);
}

/* ------------- Catalog search & filter ------------- */

async function doSearch(){
  const q = ($("#q").value || "").trim();
  const tags = ($("#tag").value || "").trim();
  const kind = $("#kind").value;
  const limit = parseInt($("#limit").value || "50", 10);
  PRICE_MOD = parseFloat($("#price-mod").value || "1") || 1;

  const rows = await fetchCatalog(kind, q, limit, tags);
  LAST_RESULTS = rows || [];

  // build category options from results
  buildCategoryOptions(LAST_RESULTS);
  applyCategoryFilter(); // sets FILTERED and renders
}

function getRowCategory(row){
  return row.category || row.subcategory || row.type || "Uncategorized";
}

function buildCategoryOptions(rows){
  const sel = $("#cat-select");
  const set = new Set(rows.map(getRowCategory));
  const cats = ["__all", ...Array.from(set).sort((a,b)=>String(a).localeCompare(String(b)))];

  sel.innerHTML = "";
  for (const c of cats){
    const opt = document.createElement("option");
    opt.value = c;
    opt.textContent = (c === "__all") ? "All" : c;
    sel.appendChild(opt);
  }
  sel.disabled = rows.length === 0;
  sel.value = "__all";
}

function applyCategoryFilter(){
  const cat = $("#cat-select").value || "__all";
  FILTERED = (cat === "__all")
    ? LAST_RESULTS.slice()
    : LAST_RESULTS.filter(r => getRowCategory(r) === cat);
  renderResults();
}

async function fetchCatalog(kind, q, limit, tags){
  const plural = KIND_PLURAL[kind] || "objects";
  const tryPaths = [
    `/catalog/search?kind=${encodeURIComponent(kind)}&q=${encodeURIComponent(q)}&tags=${encodeURIComponent(tags || "")}&limit=${limit}`,
    `/catalog/${encodeURIComponent(plural)}?q=${encodeURIComponent(q)}&tags=${encodeURIComponent(tags || "")}&limit=${limit}`
  ];
  for (const path of tryPaths){
    try{
      const r = await fetch(path, { headers: authHeaders() });
      const j = await r.json();
      if (j && j.status === "success"){
        const key = (j.objects && "objects") || (j.weapons && "weapons") || (j.equipment && "equipment") || (j.tools && "tools") || "rows";
        const rows = j[key] || j.rows || [];
        return rows.map(x => ({ ...x, __kind: kind }));
      }
    }catch(e){}
  }
  return [];
}

function invParseCustomPriceInput(inputStr){
  if (inputStr == null) return null;
  const raw = String(inputStr).trim();
  if (!raw) return null;
  const percentMark = raw.startsWith("%") || raw.endsWith("%");
  const numeric = raw.replace("%","");
  const num = Number(numeric);
  if (!Number.isFinite(num) || num < 0) return null;
  if (percentMark){
    return { priceModifier: num / 100 };
  }
  return { customPrice: num };
}

async function invPromptPricingChoice(row){
  return await new Promise(resolve=>{
    const basePrice = row?.price != null ? Number(row.price) : 0;
    const overlay = document.createElement("div");
    overlay.style.cssText = "position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:4000; display:grid; place-items:center; padding:12px;";
    const card = document.createElement("div");
    card.className = "price-choice-card";
    card.style.cssText = "background:#11121b; border:1px solid #2a2a3a; border-radius:12px; padding:14px; box-shadow:0 12px 40px rgba(0,0,0,0.45); color:#f3f3f5; font-family:inherit;";
    card.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:8px; margin-bottom:10px;">
        <div style="min-width:0;">
          <div class="price-choice-title">${escapeHtml(row?.name || row?.title || "Item")}</div>
          <div class="muted" style="font-size:0.9rem;">Base price: ${basePrice || 0}</div>
        </div>
        <button id="price-close" class="btn small" style="background:#222635; border-color:#2f3548;">×</button>
      </div>
      <div class="price-choice-grid">
        <label class="price-choice-option">
          <span>Action</span>
          <select id="price-mode-select">
            <option value="market">Buy at market price</option>
            <option value="custom">Custom</option>
            <option value="take">Take (price 0)</option>
          </select>
        </label>
        <div class="price-choice-custom hidden" id="price-choice-custom">
          <div class="price-choice-field">
            <label class="muted">Price per unit</label>
            <input id="price-custom-value" type="number" min="0" step="1" placeholder="Enter amount">
          </div>
          <div class="price-choice-field">
            <label class="muted">Percent change</label>
            <input id="price-custom-percent" type="number" min="0" step="0.1" placeholder="% of base (e.g. 120)">
          </div>
        </div>
        <div class="price-choice-actions">
          <button id="price-cancel" class="btn small btn-secondary">Cancel</button>
          <button id="price-apply" class="btn small">Apply</button>
        </div>
      </div>
    `;
    overlay.appendChild(card);
    document.body.appendChild(overlay);

    const cleanup = (val)=>{ overlay.remove(); resolve(val); };
    card.querySelector("#price-close").addEventListener("click", ()=>cleanup(null));
    card.querySelector("#price-cancel").addEventListener("click", ()=>cleanup(null));
    overlay.addEventListener("click", (e)=>{ if (e.target === overlay) cleanup(null); });

    const modeSelect = card.querySelector("#price-mode-select");
    const customArea = card.querySelector("#price-choice-custom");
    const customValueInput = card.querySelector("#price-custom-value");
    const customPercentInput = card.querySelector("#price-custom-percent");
    const updateCustomArea = ()=>{
      const showCustom = modeSelect?.value === "custom";
      if (customArea){
        customArea.classList.toggle("hidden", !showCustom);
      }
    };
    modeSelect?.addEventListener("change", updateCustomArea);
    updateCustomArea();
    card.querySelector("#price-apply").addEventListener("click", ()=>{
      const mode = modeSelect?.value || "market";
      if (mode === "take"){ cleanup({ pricingMode:"take", customPrice:0 }); return; }
      if (mode === "market"){ cleanup({ pricingMode:"market" }); return; }
      const parseInline = ()=>{
        const val = customValueInput?.value?.trim();
        if (val){
          const parsed = invParseCustomPriceInput(val);
          if (parsed) return parsed;
        }
        const pct = customPercentInput?.value?.trim();
        if (pct){
          const suffix = pct.endsWith("%") ? pct : `${pct}%`;
          const parsed = invParseCustomPriceInput(suffix);
          if (parsed) return parsed;
        }
        return null;
      };
      const inlineChoice = parseInline();
      if (inlineChoice){
        cleanup({ pricingMode:"custom", ...inlineChoice });
        return;
      }
      openCustomPriceModal(basePrice).then(choice=>{
        if (!choice) return;
        cleanup({ pricingMode:"custom", ...choice });
      });
    });
  });
}

function openCustomPriceModal(basePrice){
  return new Promise(resolve=>{
    const overlay = document.createElement("div");
    overlay.style.cssText = "position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:4001; display:grid; place-items:center; padding:12px;";
    const card = document.createElement("div");
    card.className = "price-choice-card";
    card.style.cssText = "background:#11121b; border:1px solid #2a2a3a; border-radius:12px; padding:14px; box-shadow:0 12px 40px rgba(0,0,0,0.45); color:#f3f3f5; font-family:inherit;";
    card.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:8px; margin-bottom:10px;">
        <div style="min-width:0;">
          <div class="price-choice-title">Custom price</div>
          <div class="muted" style="font-size:0.9rem;">Base price: ${basePrice || 0}</div>
        </div>
        <button id="custom-close" class="btn small" style="background:#222635; border-color:#2f3548;">×</button>
      </div>
      <div class="price-choice-grid">
        <div class="price-choice-custom">
          <div class="price-choice-field">
            <span class="muted" style="min-width:80px;">% modifier</span>
            <input id="price-mod-input" type="number" step="1" min="0" style="flex:1; min-width:0; padding:8px; border-radius:8px; border:1px solid #2d3042; background:#181b2a; color:#f3f3f5;" value="${Math.round(((parseFloat(invPriceModEl?.value || "1") || 1) * 100))}">
          </div>
          <div class="price-choice-field">
            <span class="muted" style="min-width:80px;">Exact price</span>
            <input id="price-exact-input" type="number" step="1" min="0" style="flex:1; min-width:0; padding:8px; border-radius:8px; border:1px solid #2d3042; background:#181b2a; color:#f3f3f5;" placeholder="${basePrice || 0}">
          </div>
          <div class="muted" style="grid-column:1/-1; font-size:0.9rem;">Tip: fill either % modifier or exact price. Leave both blank to cancel.</div>
        </div>
        <div class="price-choice-actions">
          <button id="custom-cancel" class="btn small btn-secondary">Cancel</button>
          <button id="custom-apply" class="btn small">Apply</button>
        </div>
      </div>
    `;
    overlay.appendChild(card);
    document.body.appendChild(overlay);

    const cleanup = (val)=>{ overlay.remove(); resolve(val); };
    card.querySelector("#custom-close").addEventListener("click", ()=>cleanup(null));
    card.querySelector("#custom-cancel").addEventListener("click", ()=>cleanup(null));
    overlay.addEventListener("click", (e)=>{ if (e.target === overlay) cleanup(null); });
    card.querySelector("#custom-apply").addEventListener("click", ()=>{
      const pctRaw = card.querySelector("#price-mod-input").value;
      const priceRaw = card.querySelector("#price-exact-input").value;
      const parsedPct = pctRaw ? invParseCustomPriceInput(`%${pctRaw}`) : null;
      const parsedPrice = priceRaw ? invParseCustomPriceInput(priceRaw) : null;
      const choice = parsedPrice || parsedPct;
      if (!choice){
        alert("Enter a % modifier or an exact price for custom mode.");
        return;
      }
      cleanup(choice);
    });
  });
}

function renderResults(){
  const list = $("#results");
  list.innerHTML = "";

  if (!FILTERED.length){
    list.textContent = "No results.";
    return;
  }

  const globalContainer = $("#global-cont").value;
  const globalCurrency  = $("#global-cur").value || "Jelly";

  for (const r of FILTERED){
    const line = document.createElement("div");
    line.className = "row";
    line.style.borderBottom = "1px solid #222";
    line.style.padding = "6px 0";

    const cat = getRowCategory(r);
    const price = (r.price != null) ? `Price: ${r.price}` : "";
    const enc = (r.enc != null) ? `Enc: ${Number(r.enc||0).toFixed(1)}` : "";

    line.innerHTML = `
      <div style="flex:1;min-width:260px;">
        <div><b>${escapeHtml(r.name || r.title || "Item")}</b></div>
        <div class="muted">${escapeHtml(cat)} ${price ? " • "+price : ""} ${enc ? " • "+enc : ""}</div>
      </div>
      <input type="number" min="1" value="1" style="width:90px" class="qty">
      <button class="btn small buy">Add</button>
    `;

    line.querySelector(".buy").addEventListener("click", async ()=>{
      const qty = Math.max(1, parseInt(line.querySelector(".qty").value||"1", 10));
      const choice = await invPromptPricingChoice(r);
      if (!choice) return;
      await buyItem(r.__kind || "object", r.id, qty, globalContainer, globalCurrency, choice);
    });

    list.appendChild(line);
  }
}

function clearSearch(){
  $("#q").value = "";
  $("#tag").value = "";
  LAST_RESULTS = [];
  FILTERED = [];
  buildCategoryOptions([]);
  renderResults();
}

/* ------------- Purchase ------------- */

async function buyItem(kind, ref_id, quantity, container_id, currency, opts = {}){
  const payload = { kind, ref_id, quantity, container_id, currency };
  const priceModifier = (opts.priceModifier != null) ? opts.priceModifier : (parseFloat(invPriceModEl?.value || "1") || 1);
  const customPrice = (opts.customPrice != null) ? Number(opts.customPrice) : null;
  const pricingMode = (opts.pricingMode || "").toString();
  if (pricingMode) payload.pricing_mode = pricingMode;
  if (pricingMode === "take"){
    payload.custom_price = 0;
  }else{
    if (priceModifier != null) payload.price_modifier = priceModifier;
    if (Number.isFinite(customPrice)) payload.custom_price = customPrice;
  }
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/purchase`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify(payload)
  });
  const j = await r.json();
  if (j.status !== "success") { alert(j.message || "Purchase failed"); return; }
  applyInventory(j.inventory);
}


async function moveItem(item_id, container_id){
  if (!container_id){ alert("Pick a target container."); return; }
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ container_id })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Move failed"); return; }
  applyInventory(j.inventory);
}

async function toggleEquip(item_id, equipped){
    const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...authHeaders() },
      body: JSON.stringify({ equipped })
  });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success"){ alert(j.message || "Update failed"); return; }
    applyInventory(j.inventory);
  }

function alchemyTierFromPrice(price){
  const ladder = [ [10000,6],[2000,5],[1000,4],[200,3],[100,2],[50,1] ];
  let tier = 1;
  const p = Number(price||0);
  for (const [min,t] of ladder){
    if (p >= min){ tier = t; break; }
  }
  return tier;
}

async function useItem(item_id){
  const currency = $("#global-cur").value || "Jelly";
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}/use`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Use failed"); return; }
  applyInventory(j.inventory);
}

async function refillAlchemy(item_id){
  const currency = $("#global-cur").value || "Jelly";
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}/refill_alchemy`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Refill failed"); return; }
  applyInventory(j.inventory);
}

async function sellItem(item_id, price){
  const currency = $("#global-cur").value || "Jelly";
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}/sell`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ price, currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Sell failed"); return; }
  applyInventory(j.inventory);
}

async function disposeItem(item_id){
  const currency = $("#global-cur").value || "Jelly";
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}/dispose`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Dispose failed"); return; }
  applyInventory(j.inventory);
}

/* ------- Item Details Modal (incl. upgrades/quality/alt name) ------- */
function openItemModal(it){
  ACTIVE_ITEM_ID = it.item_id;
  const equipped = it.equipped !== false;
  const qty = Number(it.quantity || 1);
  const encUnit = Number(it.enc || 0);
  const encTotal = encUnit * qty;
  const paidUnit = Number(it.paid_unit ?? it.base_price ?? 0) || 0;
  const totalPaid = paidUnit * qty;

  const titleText = it.alt_name ? `${it.alt_name} (${it.name || "Item"})` : (it.name || "Item");
  $("#item-title").textContent = titleText;
  const body = $("#item-body");
  body.innerHTML = "";
  const actions = $("#item-actions");
  actions.innerHTML = "";

  const nameRow = document.createElement("div");
  nameRow.className = "row";
  nameRow.style.gap = "6px";
  const nameInput = document.createElement("input");
  nameInput.placeholder = "Display name (sets alt name)";
  nameInput.value = it.alt_name || it.name || "";
  nameInput.style.flex = "1";
  const commitName = debounce(async ()=>{ await saveAltName(it.item_id, nameInput.value || ""); }, 500);
  nameInput.addEventListener("input", commitName);
  nameInput.addEventListener("blur", ()=>commitName());
  nameRow.appendChild(nameInput);
  body.appendChild(nameRow);

  const info = document.createElement("div");
  info.className = "info-grid";
  const totalPrice = Number.isFinite(totalPaid) ? totalPaid : 0;
  const cells = [
    { label: "Type", value: it.kind || "object" },
    { label: "Quality", value: it.quality || "—" },
    { label: "Enc (unit)", value: encUnit.toFixed(1) },
    { label: "Enc (total)", value: encTotal.toFixed(1) },
    { label: "Quantity", value: qty },
    { label: "Total price", value: totalPrice.toFixed(0) }
  ];
  cells.forEach(c=>{
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.innerHTML = `<div class="label">${escapeHtml(c.label)}</div><div><strong>${escapeHtml(c.value)}</strong></div>`;
    info.appendChild(cell);
  });
  body.appendChild(info);

  const modLine = buildModifierSummary(it);
  if (modLine){
    const mods = document.createElement("div");
    mods.className = "muted";
    mods.textContent = `Applies: ${modLine}`;
    body.appendChild(mods);
  }
  if (itemHasChoice(it)){
    const choiceHint = document.createElement("div");
    choiceHint.className = "muted";
    choiceHint.textContent = "This item has configurable choices.";
    body.appendChild(choiceHint);
    const choiceRow = document.createElement("div");
    choiceRow.className = "btn-row";
    const choiceBtn = document.createElement("button");
    choiceBtn.className = "btn small";
    choiceBtn.textContent = "Configure choices";
    choiceBtn.addEventListener("click", async ()=>{
      await openItemChoiceModal(it);
    });
    choiceRow.appendChild(choiceBtn);
    body.appendChild(choiceRow);
  }

  if (it.kind === "weapon" || it.kind === "equipment"){
    const upSection = document.createElement("div");
    upSection.className = "list";
    upSection.style.marginTop = "10px";

    const capLabel = `${(it.upgrades || []).length} / ${slotsForQuality(it.quality) || 0}`;
    const upHead = document.createElement("div");
    upHead.className = "row";
    upHead.style.alignItems = "center";
    upHead.style.gap = "10px";
    upHead.innerHTML = `<h3 style="margin:0;">Upgrades</h3><span class="pill-soft">${capLabel}</span>`;
    upSection.appendChild(upHead);

    const installRow = document.createElement("div");
    installRow.className = "row";
    installRow.style.gap = "8px";
    const ulabel = document.createElement("label"); ulabel.className = "muted"; ulabel.textContent = "Install upgrade";
    const uselect = document.createElement("select"); uselect.id = "up-select";
    uselect.innerHTML = '<option value="">-- select upgrade --</option>';
    const ubtn = document.createElement("button"); ubtn.className = "btn small"; ubtn.textContent = "Install";
    installRow.appendChild(ulabel); installRow.appendChild(uselect); installRow.appendChild(ubtn);
    upSection.appendChild(installRow);

    loadUpgradeOptions(ulabel, uselect, it);
    ubtn.addEventListener("click", async ()=>{
      const sel = uselect.value;
      if (!sel){ alert("Select an upgrade first."); return; }
      let target = "";
      const meta = (window.UPGRADE_META || {})[sel];
      if (meta && Array.isArray(meta.targets) && meta.targets.length){
        const choice = prompt(`Select target for ${meta.name || "upgrade"} (${meta.targets.join(", ")})`, meta.targets[0]);
        if (!choice || !meta.targets.includes(choice)){ alert("Invalid target."); return; }
        const existing = (it.upgrades || []).filter(u=>u.target===choice).length;
        if (existing >= 2){ alert("Target already has two upgrades."); return; }
        target = choice;
      }
      await installUpgrade(it.item_id, sel, target);
    });

    const upList = document.createElement("div");
    upList.className = "upg-list";
    const ups = it.upgrades || [];
    if (!ups.length){
      const empty = document.createElement("div");
      empty.className = "muted";
      empty.textContent = "No upgrades installed.";
      upList.appendChild(empty);
    }else{
      ups.forEach((u, idx)=>{
        const meta = (window.UPGRADE_META || {})[u.id] || {};
        const title = meta.name || u.name || u.id || "Upgrade";
        const desc = u.description_html || u.description || meta.description_html || meta.description || "";

        const row = document.createElement("div");
        row.className = "upg-row";

        const head = document.createElement("div");
        head.className = "row";
        head.style.justifyContent = "space-between";
        head.style.alignItems = "center";
        head.innerHTML = `<h4 style="margin:0;">${escapeHtml(title)}</h4>${u.target ? `<span class="pill-soft">Target: ${escapeHtml(u.target)}</span>` : ""}`;
        row.appendChild(head);

        if (desc){
          const dd = document.createElement("div");
          dd.className = "muted";
          dd.innerHTML = desc;
          row.appendChild(dd);
        }

        const btns = document.createElement("div");
        btns.className = "btn-row";
        const rem = document.createElement("button");
        rem.className = "btn btn-secondary small";
        rem.textContent = "Remove";
        rem.addEventListener("click", async ()=>{
          await removeUpgrade(it.item_id, u.id, u.target || "");
          closeItemModal();
        });
        const edit = document.createElement("button");
        edit.className = "btn small";
        edit.textContent = "Edit";
        edit.addEventListener("click", ()=>{ window.open(`upgrades_home.html?id=${encodeURIComponent(u.id)}`, "_blank"); });
        const choiceMods = upgradeChoiceMods(u, meta, upgradeChoiceKey(it, u, idx));
        if (choiceMods.length){
          const cfg = document.createElement("button");
          cfg.className = "btn small";
          cfg.textContent = "Configure";
          cfg.addEventListener("click", async ()=>{ await openUpgradeChoiceModal(it, u, idx); });
          btns.appendChild(cfg);
        }
        btns.appendChild(rem);
        btns.appendChild(edit);
        row.appendChild(btns);
        upList.appendChild(row);
      });
    }

    upSection.appendChild(upList);
    body.appendChild(upSection);
  }

  const btnRow = document.createElement("div");
  btnRow.className = "btn-row";

  const equipBtn = document.createElement("button");
  equipBtn.className = "btn small";
  equipBtn.textContent = equipped ? "Unequip" : "Equip";
  equipBtn.addEventListener("click", async ()=>{
    await toggleEquip(it.item_id, !equipped);
    closeItemModal();
  });
  btnRow.appendChild(equipBtn);

  const moveWrap = document.createElement("div");
  moveWrap.className = "row";
  moveWrap.style.gap = "6px";
  const moveSel = document.createElement("select");
  const stowedId = it.stowed_container_id || (it.container_id !== SELF_CONTAINER_ID ? it.container_id : "");
  (INV.containers || []).filter(c=>c.id !== SELF_CONTAINER_ID).forEach(c=>{
    const o = document.createElement("option");
    o.value = c.id; o.textContent = c.name;
    moveSel.appendChild(o);
  });
  if (stowedId){ moveSel.value = stowedId; }
  const moveBtn = document.createElement("button");
  moveBtn.className = "btn small";
  moveBtn.textContent = "Move";
  if (!moveSel.children.length){
    moveSel.disabled = true;
    moveBtn.disabled = true;
    moveBtn.title = "Add another container to move items.";
  }
  moveBtn.addEventListener("click", async ()=>{
    await moveItem(it.item_id, moveSel.value || "");
    closeItemModal();
  });
  moveWrap.appendChild(moveSel);
  moveWrap.appendChild(moveBtn);
  btnRow.appendChild(moveWrap);

  const sellBtn = document.createElement("button");
  sellBtn.className = "btn small";
  sellBtn.textContent = "Sell";
  sellBtn.addEventListener("click", async ()=>{
    const fallback = Number(it.base_price ?? it.paid_unit ?? 0) || 0;
    const ask = prompt("Sell price per unit (blank to cancel)", fallback);
    if (ask === null) return;
    const price = Number(ask);
    if (!Number.isFinite(price) || price < 0){ alert("Enter a valid price."); return; }
    await sellItem(it.item_id, price);
    closeItemModal();
  });
  btnRow.appendChild(sellBtn);

  const disposeBtn = document.createElement("button");
  disposeBtn.className = "btn btn-secondary small";
  disposeBtn.textContent = "Dispose";
  disposeBtn.addEventListener("click", async ()=>{
    if (!confirm("Dispose this item? This removes it with no revenue.")) return;
    await disposeItem(it.item_id);
    closeItemModal();
  });
  btnRow.appendChild(disposeBtn);

  const qBtn = document.createElement("button");
  qBtn.className = "btn small";
  qBtn.textContent = "Improve Quality";
  qBtn.addEventListener("click", async ()=>{
    openQualityUpgradeModal(it);
  });
  btnRow.appendChild(qBtn);

  actions.appendChild(btnRow);

  if (it.consumable){
    const useRow = document.createElement("div");
    useRow.className = "btn-row";
    const useBtn = document.createElement("button");
    useBtn.className = "btn small";
    useBtn.textContent = "Use";
    if ((Number(it.quantity)||0) <= 0) useBtn.disabled = true;
    useBtn.addEventListener("click", async ()=>{
      await useItem(it.item_id);
      closeItemModal();
    });
    useRow.appendChild(useBtn);
    actions.appendChild(useRow);
  }

  if (it.alchemy_tool){
    const tier = alchemyTierFromPrice(it.base_price);
    const cost = 50 * tier;
    const refillRow = document.createElement("div");
    refillRow.className = "btn-row";
    const refillBtn = document.createElement("button");
    refillBtn.className = "btn small";
    refillBtn.textContent = `Refill (+1, ${cost} Jelly)`;
    refillBtn.addEventListener("click", async ()=>{
      await refillAlchemy(it.item_id);
      closeItemModal();
    });
    refillRow.appendChild(refillBtn);
    actions.appendChild(refillRow);
  }

  $("#item-modal").classList.remove("hidden");
}


function closeItemModal(){
  ACTIVE_ITEM_ID = "";
  $("#item-modal").classList.add("hidden");
}

/* ------- Item actions API ------- */
async function saveAltName(item_id, alt_name){
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ alt_name })
  });
  const j = await r.json();
  if (j.status !== "success"){ alert(j.message || "Save failed"); return; }
  applyInventory(j.inventory);
}

async function upgradeQuality(item_id, to, currency){
  const payload = { to };
  if (currency) payload.currency = currency;
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}/upgrade_quality`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify(payload)
  });
  const j = await r.json();
  if (j.status !== "success"){ alert(j.message || "Upgrade failed"); return false; }
  closeItemModal();
  applyInventory(j.inventory);
  return true;
}

async function installUpgrade(item_id, upgrade, targetOverride=""){
  const meta = (window.UPGRADE_META || {})[upgrade] || null;
  let target = targetOverride || "";
  if (!target && meta && Array.isArray(meta.targets) && meta.targets.length){
    const counts = {};
    const current = (INV?.items || []).find(i=>i.item_id===item_id);
    const existing = current?.upgrades || [];
    existing.forEach(u=>{ if(u.target){ counts[u.target]=(counts[u.target]||0)+1; } });
    const options = meta.targets.map(t=>`${t} (${counts[t]||0}/2)`).join(", ");
    const choice = prompt(`Select target for ${meta.name || "upgrade"} [${options}]`, meta.targets[0]);
    if (!choice) return;
    if (!meta.targets.includes(choice)){
      alert("Invalid target."); return;
    }
    if ((counts[choice]||0) >= 2){
      alert("Target already has two upgrades."); return;
    }
    target = choice;
  }
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}/install_upgrade`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ upgrade_id: upgrade, target })
  });
  const j = await r.json();
  if (j.status !== "success"){ alert(j.message || "Install failed"); return; }
  applyInventory(j.inventory);
  if (ACTIVE_ITEM_ID === item_id) {
    const updated = (INV?.items || []).find(i=>i.item_id===item_id);
    if (updated) openItemModal(updated);
  }
}

async function removeUpgrade(item_id, upgrade_id, target=""){
  const r = await fetch(`/inventories/${encodeURIComponent(invId)}/items/${encodeURIComponent(item_id)}/remove_upgrade`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ upgrade_id, target })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Remove failed"); return; }
  applyInventory(j.inventory);
}

async function fetchUpgrades(kind, slot){
  const qs = [];
  if (kind) qs.push(`kind=${encodeURIComponent(kind)}`);
  if (slot) qs.push(`slot=${encodeURIComponent(slot)}`);
  const url = `/upgrades${qs.length ? '?'+qs.join('&') : ''}`;
  const r = await fetch(url, { headers: { ...authHeaders() } });
  const j = await r.json();
  if (j.status !== "success") throw new Error(j.message || "Load upgrades failed");
  const ups = j.upgrades || [];
  window.UPGRADE_META = window.UPGRADE_META || {};
  ups.forEach(u=>{ window.UPGRADE_META[u.id] = u; });
  return ups;
}

async function loadUpgradeOptions(labelEl, selectEl, it){
  if (!labelEl || !selectEl) return;
  labelEl.textContent = "Install upgrade (loading...)";
  selectEl.innerHTML = "";
  try{
    const slot = it.equipment_slot || it.slot || "";
    const ups = await fetchUpgrades(it.kind, slot);
    if (!ups.length){
      labelEl.textContent = "Install upgrade (none available)";
      const o = document.createElement("option");
      o.textContent = "-- none --";
      selectEl.appendChild(o);
      return;
    }
    labelEl.textContent = "Install upgrade";
    selectEl.innerHTML = '<option value=\"\">-- select upgrade --</option>';
    ups.forEach(u=>{
      const o = document.createElement("option");
      o.value = u.id;
      const ttxt = (u.targets && u.targets.length) ? ` · target: ${u.targets.join("/")}` : "";
      const excl = u.exclusive_group ? ` · excl:${u.exclusive_group}` : "";
      o.textContent = `${u.name}${u.slot ? ` (${u.slot})` : ""}${ttxt}${excl}`;
      selectEl.appendChild(o);
    });
  }catch(e){
    labelEl.textContent = "Install upgrade (error)";
    const o = document.createElement("option");
    o.textContent = "Error loading upgrades";
    selectEl.appendChild(o);
  }
}

/* ------- utils ------- */
function buildModifierSummary(it){
  const out = [];
  const mods = Array.isArray(it?.modifiers) ? it.modifiers : [];
  mods.forEach(m=>{
    const mode = m.mode || "add";
    const val = m.value ?? "";
    const tgt = m.target || "";
    out.push(`${mode} ${val}${tgt ? " -> " + tgt : ""}`);
  });
  const ups = Array.isArray(it?.upgrades) ? it.upgrades : [];
  ups.forEach(u=>{
    const pool = Array.isArray(u.holder_modifiers) && u.holder_modifiers.length
      ? u.holder_modifiers
      : (Array.isArray(u.modifiers) ? u.modifiers : []);
    pool.forEach(m=>{
      const mode = m.mode || "add";
      const val = m.value ?? "";
      const tgt = m.target || "";
      out.push(`${mode} ${val}${tgt ? " -> " + tgt : ""}`);
    });
  });
  return out.join(", ");
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}
function escapeAttr(s){ return escapeHtml(s).replaceAll('"',"&quot;"); }
</script>
</body>
</html>

