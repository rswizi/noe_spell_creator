<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NoE -- Edit Character (with Abilities)</title>

  <style>
    :root {
      color-scheme: dark;
      --bg: #14090c;
      --bg-2: #0c0b12;
      --panel: #121219;
      --border: #252533;
      --accent: #c53535;
      --accent-2: #f04a4a;
      --text: #f3f3f5;
    }
    html,body { height: 100%; }
    body {
      margin: 0;
      font-family: "Segoe UI", "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text);
      background: linear-gradient(180deg, #1a0c0f 0%, #0b0b10 100%);
      background-repeat: no-repeat;
      background-attachment: fixed;
      background-size: 100% 100%;
    }
    .page { min-height: 100vh; display: grid; place-items: start center; }
    .wrap { width: 100%; max-width: 1100px; padding: 28px 16px 60px; }

    .topbar { display:flex; gap:12px; align-items:center; margin-bottom:16px; }
    .topbar h1 { font-size: 22px; margin: 0; }
    a.btn, button, input, select, textarea {
      padding:10px 12px; border-radius:12px; border:1px solid var(--border);
      background: #181821; color: var(--text); text-decoration:none;
      transition: background .15s ease, border .15s ease, transform .1s ease;
    }
    a.btn:hover, button:hover { background:#1f1f2a; border-color:#2f2f42; }
    button:active { transform: translateY(1px); }
    input, select, textarea { width:100%; }
    textarea { resize: vertical; }
    .muted { opacity:.78; font-size:.9rem; }
    .grow { flex: 1 1 auto; }
    .right { margin-left:auto; }

    .tabs { display:flex; gap:8px; border-bottom:1px solid var(--border); margin:16px 0 12px; flex-wrap:wrap; }
    .tab { padding:10px 14px; border:1px solid var(--border); border-bottom:none; border-radius:14px 14px 0 0; background:#14141d; cursor:pointer; }
    .tab.active { background: linear-gradient(135deg, rgba(197,53,53,0.25), rgba(20,20,29,0.9)); border-color: var(--accent); font-weight:700; box-shadow: 0 8px 16px rgba(0,0,0,0.3); }
    .tabpanes { border:1px solid var(--border); border-radius:0 18px 18px 18px; background: #11111a; padding:16px; box-shadow: 0 10px 30px rgba(0,0,0,0.28); }

    .stats-grid { display:grid; gap:14px; grid-template-columns: repeat(auto-fit, minmax(460px, 1fr)); align-items:stretch; }
    .panel { border:1px solid var(--border); border-radius:16px; overflow:hidden; background: var(--panel); box-shadow: 0 8px 24px rgba(0,0,0,0.25); height:100%; display:flex; flex-direction:column; }
    details.panel > summary { list-style:none; cursor:pointer; padding:14px 16px; display:flex; align-items:center; gap:10px; }
    details.panel > summary::-webkit-details-marker { display:none; }
    .pill { font-size:.85rem; opacity:.9; border:1px solid #2f2f3f; border-radius:999px; padding:3px 10px; }
    .panel-body { padding:0 16px 16px; display:grid; gap:10px; }
    .panel.skill-4 .panel-body { min-height: 260px; }
    .panel.skill-5 .panel-body { min-height: 320px; }

    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .row > .grow { flex:1 1 auto; }
    .k { opacity:.88; font-size:.9rem; }
    .num { width:90px; } /* Base numeric inputs stay comfortable; size specific rows below */
    .total { font-weight:600; }
    .hdr { display:flex; align-items:center; gap:10px; }
    .skills { display:grid; gap:8px; margin-top:10px; }
    .skill-line { display:grid; grid-template-columns: minmax(120px, 1fr) 78px 58px; gap:8px; align-items:center; }
    .skill-line input.num { width:40px; max-width:40px; } /* tighter inputs for skill rows */
    .skill-total { min-width:48px; text-align:center; font-variant-numeric: tabular-nums; padding:2px 4px; }
    .charac-badge { font-variant-numeric: tabular-nums; }
    .badge { border:1px solid #2f2f3f; border-radius:999px; padding:2px 8px; font-variant-numeric: tabular-nums; background:#181821; }
    .hdr input.num { width:88px; }
    .intensities-panel { grid-column: 1 / -1; }
    .intensities-grid {
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:10px 12px;
    }
    .intensity-line {
      display:grid;
      grid-template-columns: minmax(80px, 1fr) 70px 62px;
      gap:6px;
      align-items:center;
    }
    .intensity-line input.num { width:40px; max-width:40px; }
    .intensity-line .skill-total { text-align:center; min-width:48px; }
    @media (max-width: 900px){
      .intensities-grid { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
    }

    .derived-grid { display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); }
    .kv { display:grid; grid-template-columns: auto 1fr; gap:6px 8px; align-items:center; }
    .kv .val { justify-self:end; font-variant-numeric: tabular-nums; }

    /* Abilities tab */
    .abi-grid { display:grid; gap:12px; grid-template-columns: 1fr; }
    .abi-bucket h3 { margin:6px 0 8px; font-size:1rem; }
    .abi-list { display:grid; gap:8px; }
    .abi-item { display:flex; align-items:center; gap:10px; padding:8px 10px; border:1px solid #2b2b3b; border-radius:12px; background:linear-gradient(145deg, #14141d, #0f0f16); box-shadow: inset 0 1px 0 rgba(255,255,255,0.03); }
    .abi-item .tag { border:1px solid #3b3b4b; border-radius:999px; padding:3px 8px; font-size:.75rem; opacity:.9; }
    .abi-item button { padding:6px 10px; font-size:.85rem; }
    .abi-add { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .abi-add input, .abi-add select { flex:1 1 auto; }
    .abi-hint { opacity:.75; font-size:.85rem; margin-top:6px; }
    /* Modifiers breakdown */
    .mod-list { margin:6px 0 4px 16px; padding:0; list-style:disc; display:none; opacity:0.9; }
    .mod-list li { margin:0 0 3px 0; font-size:0.9rem; }
    .mod-toggle { cursor:pointer; }
    .stat-counter { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0; }
    .stat-counter .pill { border-color:#2f2f2f; }
    .current-row { display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:8px; margin-top:8px; }
    .current-row label { display:flex; align-items:center; gap:6px; }
    .current-row input { width:100%; }
    .override-row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:8px; }
  /* Avatar */
  .avatar-card { display:flex; gap:14px; align-items:center; flex-wrap:wrap; }
  .avatar-frame { width:124px; height:124px; border:1px solid #333; border-radius:14px; overflow:hidden; background:#08080e; display:grid; place-items:center; }
  .avatar-frame img { width:100%; height:100%; object-fit:cover; }
  .avatar-tools { display:grid; gap:6px; min-width:280px; }
  .avatar-crop { border:1px solid #333; border-radius:14px; background:#0b0b12; }
  /* Inventory UI */
  .home-card { border:1px solid var(--border); border-radius:14px; padding:12px; background: #14141d; margin-bottom:12px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
  .container-card { border:1px solid #2a2a38; border-radius:12px; padding:12px; margin-bottom:10px; background: linear-gradient(135deg, #12121a, #0f0f17); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
  .container-head { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px; }
  .items { display:grid; gap:8px; }
  .item-row { display:grid; grid-template-columns: 1fr auto auto auto; gap:8px; align-items:center; padding:8px 10px; border:1px solid #292938; border-radius:10px; background:#161623; }
  .item-row .pill { white-space:nowrap; }
  .inv-summary { display:grid; gap:6px; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); align-items:center; }
  .inv-actions { display:flex; gap:8px; flex-wrap:wrap; }
  .info-grid { display:grid; gap:10px; grid-template-columns: repeat(auto-fit,minmax(160px,1fr)); margin:10px 0; }
  .info-grid .cell { border:1px solid #242436; border-radius:10px; padding:8px; background:#12121c; }
  .info-grid .label { font-size:.85rem; opacity:.75; }
  .pill-soft { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:10px; background:#111827; border:1px solid #1f2b3f; }
  .upg-list { display:grid; gap:10px; }
  .upg-row { border:1px solid #242436; border-radius:10px; padding:8px; background:#12121c; }
  .upg-row h4 { margin:0 0 4px; font-size:1rem; }
  .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:3000; display:none; }
    .modal{ position:fixed; inset:0; display:none; z-index:3001; align-items:center; justify-content:center; padding:16px; }
    .modal.open, .modal-backdrop.open{ display:flex; }
    .modal-card{
      width:100%; max-width:520px; background:#11111a; border:1px solid #2a2a3a;
      border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.6);
      max-height:90vh; overflow:auto;
    }
    /* Personal tab */
    .personal-grid { display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); align-items:start; margin-bottom:10px; }
    .kv-field { display:grid; gap:6px; min-width:0; }
    .kv-field input, .kv-field textarea, .kv-field .richtext { width:100%; box-sizing:border-box; }
    .richtext{
      min-height:100px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#181821;
      outline:none;
      overflow:auto;
    }
    .richtext:focus{ border-color:#2f2f42; box-shadow:0 0 0 1px #2f2f42; }
    .richtext:empty:before{
      content: attr(data-placeholder);
      opacity: .55;
      pointer-events:none;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="page"><div class="wrap">

    <div class="topbar">
      <h1 id="title">Edit Character</h1>
      <span id="login-chip" class="muted right"></span>
      <a class="btn" href="characters.html">Back to My Characters</a>
      <a class="btn" href="character_admin.html" id="admin-link" style="display:none">All Characters</a>
      <button class="btn" id="delete-char" style="border-color:#7a1b1b; background:linear-gradient(135deg, rgba(197,53,53,0.35), rgba(60,10,14,0.9)); color:#fff;">Delete</button>
      <label class="row" style="gap:6px; margin-left:8px;">
        <input type="checkbox" id="override-derived"> <span class="muted">Override values (DM)</span>
      </label>
    </div>

    <!-- Name card -->
    <div class="panel" style="margin-bottom:12px;">
      <details open class="panel">
        <summary class="hdr">
          <strong>Name</strong>
          <span class="muted">(autosaves)</span>
          <span class="muted status" id="status">Loaded.</span>
        </summary>
          <div class="panel-body">
            <div class="avatar-card">
              <div class="avatar-frame"><img id="avatar-preview" alt="Avatar preview"></div>
              <div class="avatar-tools">
                <input id="name" placeholder="Enter a name..." class="grow" maxlength="22" />
                <button id="avatar-open" class="btn small">Set avatar</button>
                <div id="avatar-status" class="muted"></div>
              </div>
            </div>
          </div>
        </details>
    </div>

    <!-- Tabs -->
    <div class="tabs" role="tablist">
      <div class="tab active" data-tab="tab-stat">Statistic</div>
      <div class="tab" data-tab="tab-inv">Inventory</div>
      <div class="tab" data-tab="tab-spell">Spell List</div>
      <div class="tab" data-tab="tab-abi">Abilities</div>
      <div class="tab" data-tab="tab-com">Combat</div>
      <div class="tab" data-tab="tab-per">Personal</div>
    </div>

    <div class="tabpanes">
      <!-- STATISTICS TAB -->
      <div id="tab-stat" class="tabpane">
        <div class="panel" style="margin-bottom:12px;">
          <details open class="panel">
            <summary class="hdr">
              <strong>Derived Stats</strong>
              <span class="muted">(auto from Level, Milestones & skills)</span>
              <span class="grow"></span>
              <span class="k">Level</span>
              <input id="level" type="number" class="num" min="1" value="1" />
              <button class="btn small" id="xp-add-btn">Add XP</button>
              <button class="btn small" id="level-set-btn">Set level</button>
            </summary>
            <div class="panel-body">
              <div class="row muted" id="xp-progress" style="gap:8px;"></div>
              <div class="derived-grid">
                <div class="kv"><div class="k">HP</div> <div class="val badge mod-toggle" id="hp-val" data-target="mods-derived-hp" title="">--</div>
                <ul class="mod-list" id="mods-derived-hp" style="display:none"></ul></div>
                <div class="kv"><div class="k">EN</div> <div class="val badge mod-toggle" id="en-val" data-target="mods-derived-en" title="">--</div>
                <ul class="mod-list" id="mods-derived-en" style="display:none"></ul></div>
                <div class="kv"><div class="k">FO</div> <div class="val badge mod-toggle" id="fo-val" data-target="mods-derived-fo" title="">--</div>
                <ul class="mod-list" id="mods-derived-fo" style="display:none"></ul></div>
                <div class="kv"><div class="k">MO</div> <div class="val badge mod-toggle" id="mo-val" data-target="mods-derived-mo" title="">--</div>
                <ul class="mod-list" id="mods-derived-mo" style="display:none"></ul></div>
                <div class="kv"><div class="k">SP cap (10% HP)</div> <div class="val badge mod-toggle" id="spcap-val" data-target="mods-derived-spcap" title="">--</div>
                <ul class="mod-list" id="mods-derived-spcap" style="display:none"></ul></div>
                <div class="kv"><div class="k">Encumbrance</div> <div class="val badge mod-toggle" id="enc-val" data-target="mods-derived-enc" title="">--</div>
                <ul class="mod-list" id="mods-derived-enc" style="display:none"></ul></div>
                <div class="kv"><div class="k">Eclipse Threshold (ET)</div> <div class="val badge mod-toggle" id="et-val" data-target="mods-derived-et" title="">--</div>
                <ul class="mod-list" id="mods-derived-et" style="display:none"></ul></div>
                <div class="kv"><div class="k">Max Toxicity (TX)</div> <div class="val badge mod-toggle" id="tx-val" data-target="mods-derived-tx" title="">--</div>
                <ul class="mod-list" id="mods-derived-tx" style="display:none"></ul></div>
              </div>
            </div>
          </details>
        </div>

        <!-- Sublimations -->
        <div class="panel" style="margin-bottom:12px;">
          <details open class="panel">
            <summary class="hdr">
              <strong>Sublimations</strong>
              <span class="pill" id="sub-slot-pill"></span>
              <span class="muted" id="sub-warning"></span>
            </summary>
            <div class="panel-body">
              <div class="row" style="justify-content:flex-end; margin-bottom:8px; gap:8px;">
                <button id="sub-open-btn" class="btn small">Add sublimation</button>
              </div>
              <div id="sub-list" class="abi-list"></div>
              <div class="muted" id="sub-hidden"></div>
            </div>
          </details>
        </div>

        <div class="stat-counter">
          <span class="pill" id="skill-counter">Skills: -- / --</span>
          <span class="pill" id="stat-counter">Characteristics: -- / --</span>
          <span class="pill" id="skill-cap">Max per skill: --</span>
        </div>

        <div class="stats-grid" id="stats-grid"><!-- injected --></div>

      </div>

      <!-- INVENTORY -->
      <div id="tab-inv" class="tabpane" style="display:none;">
        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Inventory</strong>
              <span class="muted">(linked & fully managed here)</span>
            </summary>
            <div class="panel-body">
              <div class="row" style="margin-bottom:10px; flex-wrap:wrap; gap:8px;">
                <select id="inv-select" class="grow"></select>
                <button id="inv-load-btn">Load</button>
                <button id="inv-create-btn" class="btn small">Create & Link</button>
                <button id="inv-dup-link" class="btn small">Duplicate & Link</button>
                <a class="btn" id="inv-open-manager" target="_blank" rel="noopener">Open manager</a>
                <span id="inv-status" class="muted"></span>
              </div>

              <div id="inv-manager" style="display:none;">
                <div class="home-card">
                  <h3 id="inv-title">Inventory</h3>
                  <div class="inv-summary">
                    <div id="inv-money"></div>
                    <div class="row muted" style="gap:6px;">Total Encumbrance: <strong id="inv-enc-total">0</strong></div>
                  </div>
                  <div class="inv-actions" style="margin-top:8px;">
                    <button id="inv-fund-open" class="btn small">Add / Remove funds</button>
                    <button id="inv-catalog-open" class="btn small">Add from catalog</button>
                  </div>
                </div>

                <div class="home-card">
                  <h3>Containers & Items</h3>
                  <div id="inv-containers"></div>
                  <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap;">
                    <input id="inv-new-cont-name" placeholder="New container name">
                    <button id="inv-add-cont" class="btn small">+ Add Container</button>
                  </div>
                </div>

                <div class="home-card">
                  <h3>Recent Transactions</h3>
                  <div id="inv-tx" class="list"></div>
                </div>
              </div>
            </div>
          </details>
        </div>

        <!-- Item modal -->
        <div id="inv-item-backdrop" class="modal-backdrop" aria-hidden="true"></div>
        <div id="inv-item-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="inv-item-title">
          <div class="modal-card">
            <button class="modal-close" id="inv-item-close" aria-label="Close">&times;</button>
            <h2 id="inv-item-title">Item</h2>
            <div id="inv-item-body" class="list" style="margin-top:10px;"></div>
            <div id="inv-item-actions" style="margin-top:12px;"></div>
          </div>
        </div>
      </div>

      <!-- ABILITIES TAB -->
      <div id="tab-abi" class="tabpane" style="display:none;">
        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Archetype</strong>
              <span class="muted">(auto unlock by level)</span>
            </summary>
            <div class="panel-body">
              <div class="row" style="gap:8px; flex-wrap:wrap;">
                <select id="arc-select" class="grow"></select>
                <button id="arc-apply" class="btn">Apply</button>
                <span id="arc-status" class="muted"></span>
              </div>
              <div id="arc-summary" class="muted"></div>
              <div class="abi-list" id="arc-abilities"></div>
            </div>
          </details>
        </div>

        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Abilities on this Character</strong>
              <span class="muted">(Archetype / Passive / Active)</span>
              <span class="grow"></span>
              <button class="btn small" id="abi-open-add">Add ability</button>
            </summary>
            <div class="panel-body">
              <div class="abi-hint" id="talent-counter">Talents: -- / --</div>

              <div class="abi-grid" style="margin-top:16px;">
                <div class="abi-bucket">
                  <h3>Passive</h3>
                  <div id="abi-list-passive" class="abi-list"></div>
                </div>
                <div class="abi-bucket">
                  <h3>Active</h3>
                  <div id="abi-list-active" class="abi-list"></div>
                </div>
                <div class="abi-bucket">
                  <h3>Spells (from linked list)</h3>
                  <div class="row" style="gap:8px; align-items:center; margin-bottom:6px;">
                    <label class="row muted" style="gap:6px; align-items:center;">
                      <input type="checkbox" id="abi-spells-only-learned" checked> Prepared Only
                    </label>
                  </div>
                  <div id="abi-list-spells" class="abi-list"></div>
                </div>
              </div>
            </div>
          </details>
        </div>
      </div>

      <!-- SPELL LIST TAB -->
      <div id="tab-spell" class="tabpane" style="display:none;">
        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Spell List</strong>
              <span class="muted">(linked & managed here)</span>
            </summary>
            <div class="panel-body">
              <div class="row" style="margin-bottom:10px; flex-wrap:wrap; gap:8px;">
                <select id="sl-select" class="grow"></select>
                <button id="sl-load-btn">Load</button>
                <button id="sl-create-btn">Create & Link</button>
                <button id="sl-dup-btn">Duplicate & Link</button>
                <a class="btn" href="spell_list_home.html" target="_blank" rel="noopener">Open manager</a>
                <span id="sl-status" class="muted"></span>
              </div>
              <div id="sl-summary" class="muted" style="margin-bottom:8px;"></div>
              <div class="row" id="sl-counters" style="gap:8px; flex-wrap:wrap; margin-bottom:10px;">
                <span class="pill" id="cnt-sch-simple">Simple schools: --</span>
                <span class="pill" id="cnt-sch-complex">Complex schools: --</span>
                <span class="pill" id="cnt-sp-simple">Simple spell slots: --</span>
                <span class="pill" id="cnt-sp-complex">Complex spell slots: --</span>
              </div>

              <div class="panel" style="margin-bottom:12px;">
                <details open class="panel">
                  <summary class="hdr">
                    <strong>Schools</strong>
                    <span class="muted">(add and track MS)</span>
                  </summary>
                  <div class="panel-body">
                    <div class="row" style="margin-bottom:8px; gap:8px; flex-wrap:wrap;">
                      <button class="btn small" id="sl-add-menu-btn">Add schools</button>
                      <div id="sl-add-menu" class="row" style="gap:6px; display:none; flex-wrap:wrap;">
                        <button class="btn small" id="sl-quick-add">Quick Add</button>
                        <button class="btn small" id="sl-manual-add">Manual Add</button>
                      </div>
                      <span class="muted" id="sl-schools-status"></span>
                    </div>
                    <div id="sl-schools" class="abi-list"></div>
                  </div>
                </details>
              </div>

              <div class="panel">
                <details open class="panel">
                  <summary class="hdr">
                    <strong>My Spells</strong>
                    <span class="muted">(from linked list)</span>
                    <span class="grow"></span>
                    <button class="btn small" id="sl-open-add">Add spells</button>
                  </summary>
                  <div class="panel-body">
                    <div class="table-wrap">
                      <table class="table">
                        <thead>
                          <tr>
                            <th style="width:30%;">Name</th>
                            <th>Schools</th>
                            <th style="width:10%;">Category</th>
                            <th style="width:12%;">Status</th>
                            <th style="width:18%;">Actions</th>
                          </tr>
                        </thead>
                        <tbody id="sl-spells-body">
                          <tr><td colspan="5" class="empty">Load a spell list.</td></tr>
                        </tbody>
                      </table>
                    </div>
                  </div>
                </details>
              </div>
            </div>
          </details>
        </div>

        <div id="sl-add-backdrop" class="modal-backdrop" aria-hidden="true"></div>
        <div id="sl-add-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="sl-add-title">
          <div class="modal-card" style="max-width:960px;">
            <header class="row" style="justify-content:space-between; align-items:center;">
              <div class="modal-title" id="sl-add-title">Add Spells</div>
              <button class="modal-close" id="sl-add-close" aria-label="Close">âœ•</button>
            </header>
            <div class="row" style="gap:10px; flex-wrap:wrap; margin-bottom:8px;">
              <input id="sl-search-q" placeholder="Search spells..." style="flex:1; min-width:240px;">
              <button class="btn" id="sl-search-btn">Search</button>
            </div>
            <div class="table-wrap">
              <table class="table">
                <thead><tr><th>Name</th><th>Schools</th><th>Category</th><th>Add</th></tr></thead>
                <tbody id="sl-search-body">
                  <tr><td colspan="4" class="empty">Use search to list spells.</td></tr>
                </tbody>
              </table>
            </div>
            <div class="row" style="margin-top:10px; gap:8px;">
              <button class="btn btn-secondary" id="sl-add-cancel">Close</button>
            </div>
            <div id="sl-add-status" class="muted" style="margin-top:6px;"></div>
          </div>
        </div>

        <div id="sl-sch-modal-backdrop" class="modal-backdrop" aria-hidden="true"></div>
        <div id="sl-sch-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="sl-sch-title">
          <div class="modal-card" style="max-width:720px;">
            <header class="row" style="justify-content:space-between; align-items:center;">
              <div class="modal-title" id="sl-sch-title">Add Schools</div>
              <button class="modal-close" id="sl-sch-close" aria-label="Close" style="font-size:20px;">Ã—</button>
            </header>
            <div class="table-wrap">
              <table class="table">
                <thead><tr><th style="width:8%;">Add</th><th>School</th><th style="width:20%;">Type</th><th style="width:18%;">Category</th></tr></thead>
                <tbody id="sl-sch-body">
                  <tr><td colspan="4" class="empty">Loading...</td></tr>
                </tbody>
              </table>
            </div>
            <div class="row" style="margin-top:10px; gap:8px;">
              <button class="btn btn-secondary" id="sl-sch-cancel">Cancel</button>
              <button class="btn" id="sl-sch-apply">Add selected</button>
            </div>
            <div id="sl-sch-status" class="muted" style="margin-top:6px;"></div>
          </div>
        </div>
      </div>

      <!-- COMBAT / PERSONAL placeholders -->
      <div id="tab-com" class="tabpane" style="display:none;">
        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Current values</strong>
              <span class="muted">(HP/EN/FO/SP)</span>
            </summary>
            <div class="panel-body">
              <div class="current-row">
                <label class="muted">Current HP <input id="cur-hp" type="number" min="0"></label>
                <label class="muted">Current EN <input id="cur-en" type="number" min="0"></label>
                <label class="muted">Current FO <input id="cur-fo" type="number" min="0"></label>
                <label class="muted">Current SP <input id="cur-sp" type="number" min="0"></label>
              </div>
            </div>
          </details>
        </div>
      </div>
      <div id="tab-per" class="tabpane" style="display:none;">
        <div class="panel">
          <details open class="panel">
            <summary class="hdr"><strong>Personal</strong><span class="muted">(freeform character info)</span></summary>
            <div class="panel-body">
              <div class="personal-grid">
                <label class="kv-field">
                  <span class="k">Nicknames</span>
                  <input id="p-nicknames" placeholder="Aliases or epithets">
                </label>
                <label class="kv-field">
                  <span class="k">Height</span>
                  <input id="p-height" placeholder="e.g. 1.80 m">
                </label>
                <label class="kv-field">
                  <span class="k">Weight</span>
                  <input id="p-weight" placeholder="e.g. 75 kg">
                </label>
                <label class="kv-field">
                  <span class="k">Elo</span>
                  <input id="p-elo" placeholder="Rating / score">
                </label>
                <label class="kv-field">
                  <span class="k">Rank</span>
                  <input id="p-rank" placeholder="Rank or title">
                </label>
              </div>

              <div class="personal-grid">
                <label class="kv-field">
                  <span class="k">Friends</span>
                  <div id="p-friends" class="richtext" contenteditable="true" data-placeholder="Allies, contacts"></div>
                </label>
                <label class="kv-field">
                  <span class="k">Enemies</span>
                  <div id="p-enemies" class="richtext" contenteditable="true" data-placeholder="Rivals, threats"></div>
                </label>
              </div>

              <label class="kv-field">
                <span class="k">Notes</span>
                <div id="p-notes" class="richtext" contenteditable="true" data-placeholder="Any additional notes"></div>
              </label>

              <label class="kv-field">
                <span class="k">Backstory</span>
                <div id="p-backstory" class="richtext" contenteditable="true" data-placeholder="Describe the character's history"></div>
              </label>
            </div>
          </details>
        </div>
      </div>
    </div>

  </div></div>

<!-- Avatar modal -->
<div id="avatar-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="avatar-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="avatar-title">
  <div class="modal-card">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="avatar-title">Set Avatar</div>
      <button class="modal-close" id="avatar-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap;">
      <input type="file" id="avatar-file" accept="image/png,image/jpeg">
      <label class="muted">Zoom <input id="avatar-zoom" type="range" min="1" max="3" step="0.05" value="1"></label>
      <label class="muted">Offset X <input id="avatar-offset-x" type="range" min="-120" max="120" step="2" value="0"></label>
      <label class="muted">Offset Y <input id="avatar-offset-y" type="range" min="-120" max="120" step="2" value="0"></label>
    </div>
    <canvas id="avatar-canvas" width="256" height="256" class="avatar-crop" style="margin-top:10px;"></canvas>
    <div class="row" style="margin-top:12px; gap:10px;">
      <button class="btn" id="avatar-upload">Upload</button>
      <button class="btn btn-secondary" id="avatar-cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Funds modal -->
<div id="inv-fund-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="inv-fund-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="inv-fund-title">
  <div class="modal-card" style="max-width:540px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="inv-fund-title">Add / Remove funds</div>
      <button class="modal-close" id="inv-fund-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:8px; flex-wrap:wrap; margin-top:8px;">
      <label class="muted">Currency</label>
      <select id="inv-fund-cur"></select>
      <input id="inv-fund-amt" type="number" step="1" placeholder="Amount (use negative for removal)" style="width:160px;">
      <input id="inv-fund-note" placeholder="Note (optional)" style="flex:1; min-width:220px;">
    </div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button id="inv-fund-save" class="btn">Apply</button>
      <button id="inv-fund-cancel" class="btn btn-secondary">Cancel</button>
    </div>
    <div id="inv-fund-status" class="muted" style="margin-top:6px;"></div>
  </div>
</div>

<!-- Catalog modal -->
<div id="inv-catalog-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="inv-catalog-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="inv-catalog-title">
  <div class="modal-card" style="max-width:980px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="inv-catalog-title">Add from Catalog</div>
      <button class="modal-close" id="inv-catalog-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:6px;">
      <input id="inv-q" placeholder="Search nameâ€¦" style="flex:1">
      <select id="inv-kind">
        <option value="object">Objects</option>
        <option value="weapon">Weapons</option>
        <option value="equipment">Equipment</option>
        <option value="tool">Tools</option>
      </select>
      <select id="inv-cat-select">
        <option value="__all">All</option>
      </select>
      <select id="inv-limit">
        <option>25</option>
        <option selected>50</option>
        <option>100</option>
      </select>
      <input id="inv-price-mod" type="number" step="0.05" min="0" value="1" style="width:120px;" title="Price modifier (e.g. 0.9 for 10% discount, 1.2 for 20% markup)">
      <button id="inv-search" class="btn small">Search</button>
      <button id="inv-clear" class="btn btn-secondary small">Clear</button>
    </div>
    <div class="row" style="gap:10px; margin-top:8px; flex-wrap:wrap;">
      <label class="muted">Container</label>
      <select id="inv-global-cont"></select>
      <label class="muted">Currency</label>
      <select id="inv-global-cur"></select>
      <label class="muted">Equipped?</label>
      <select id="inv-equpped-flag">
        <option value="0" selected>No</option>
        <option value="1">Yes</option>
      </select>
    </div>
    <div id="inv-results" class="list" style="margin-top:10px; max-height:420px; overflow:auto;"></div>
  </div>
</div>

<!-- Sublimation modal -->
<div id="sub-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="sub-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="sub-title">
  <div class="modal-card" style="max-width:520px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="sub-title">Add sublimation</div>
      <button class="modal-close" id="sub-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:8px; flex-wrap:wrap; margin-top:8px;">
      <label class="muted">Type
        <select id="sub-type">
          <option value="lethality">Lethality</option>
          <option value="blessing">Blessing</option>
          <option value="excellence">Excellence</option>
          <option value="defense">Defense</option>
          <option value="speed">Speed</option>
          <option value="devastation">Devastation</option>
          <option value="clarity">Clarity</option>
          <option value="endurance">Endurance</option>
        </select>
      </label>
      <label class="muted">Tier
        <select id="sub-tier">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
        </select>
      </label>
      <label class="muted" id="sub-skill-label" style="display:none;">Target skill
        <select id="sub-skill"></select>
      </label>
      <label class="muted" id="sub-nature-label" style="display:none;">Nature
        <select id="sub-nature"></select>
      </label>
    </div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn" id="sub-add-btn">Add</button>
      <button class="btn btn-secondary" id="sub-cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Abilities modal -->
<div id="abi-add-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="abi-add-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="abi-add-title">
  <div class="modal-card" style="max-width:960px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="abi-add-title">Add Ability</div>
      <button class="modal-close" id="abi-add-close" aria-label="Close">&times;</button>
    </header>
    <div class="abi-add" style="margin:10px 0;">
      <input id="abi-search" placeholder="Search ability by nameâ€¦" />
      <select id="abi-filter-type">
        <option value="">Any type</option>
        <option value="active">Active</option>
        <option value="passive">Passive</option>
        <option value="mixed">Mixed</option>
      </select>
      <select id="abi-filter-source">
        <option value="">Any source</option>
        <option value="Specie">Specie</option>
        <option value="Talent">Talent</option>
        <option value="Archetype">Archetype</option>
        <option value="Expertise">Expertise</option>
        <option value="Awakening">Awakening</option>
        <option value="Apotheosis">Apotheosis</option>
        <option value="Other">Other</option>
      </select>
      <button id="abi-search-btn">Find</button>
    </div>
    <div id="abi-results" class="abi-list" style="margin-bottom:12px;"></div>
    <div class="row" style="gap:8px; justify-content:flex-end;">
      <button class="btn btn-secondary" id="abi-add-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Ability choice config modal -->
<div id="choice-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="choice-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="choice-title">
  <div class="modal-card" style="max-width:720px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="choice-title">Configure choices</div>
      <button class="modal-close" id="choice-close" aria-label="Close">&times;</button>
    </header>
    <div id="choice-body" class="list" style="margin-top:10px;"></div>
    <div class="row" style="justify-content:flex-end; gap:8px; margin-top:12px;">
      <button class="btn" id="choice-cancel">Cancel</button>
      <button class="btn" id="choice-save">Save</button>
    </div>
  </div>
</div>

<script>
/* --- auth helper --- */
function getToken(){ return localStorage.getItem('auth_token') || ''; }
function setCookieToken(tok){ if(!tok) return; document.cookie = `token=${tok}; path=/; SameSite=Lax`; }
function authHeaders(){ const t=getToken(); if(t) setCookieToken(t); return t ? {'Authorization':'Bearer '+t, 'X-Auth-Token':t} : {}; }
async function api(path,opt={}){ const headers = Object.assign({}, opt.headers||{}, authHeaders()); const resp = await fetch(path, { credentials:'include', ...opt, headers }); const ct = resp.headers.get('content-type') || ''; const data = ct.includes('application/json') ? await resp.json() : { status:'error', message: await resp.text() }; if(!resp.ok || data.status==='error') throw new Error(data.message || ('HTTP '+resp.status)); return data; }

/* Constants */
const CHARACS = [
  { key:'reflex',    code:'REF', name:'Reflex',    skills:['Technicity','Dodge','Counter','Reactivity'] },
  { key:'dexterity', code:'DEX', name:'Dexterity', skills:['Accuracy','Evasion','Stealth','Acrobatics'] },
  { key:'body',      code:'BOD', name:'Body',      skills:['Brutality','Blocking','Resistance','Athletics'] },
  { key:'willpower', code:'WIL', name:'Willpower', skills:['Intimidation','Spirit','Instinct','Absorption'] },
  { key:'wisdom',    code:'WIS', name:'Wisdom',    skills:['Survival','Education','Perception','Psychology','Investigation'] },
  { key:'presence',  code:'PRE', name:'Presence',  skills:['Taming','Charm','Charisma','Deception','Persuasion'] },
  { key:'magic',     code:'MAG', name:'Magic',     skills:['Aura','Incantation','Enchantment','Restoration','Potential'] },
  { key:'tech',      code:'TECH',name:'Tech',      skills:['Crafting','Sleight of hand','Alchemy','Medicine','Engineering'] },
];

const NATURES = ['Fire','Lightning','Water','Earth','Wind','Sun','Moon','Ki'];
const INTENSITIES = ['Fire','Water','Earth','Wind','Lightning','Sun','Moon','Ki'];
const SUB_TIER_SLOTS = {1:1, 2:3, 3:5, 4:7};
const SUB_TYPES = [
  { key:'lethality', label:'Lethality' },
  { key:'blessing', label:'Blessing' },
  { key:'excellence', label:'Excellence' },
  { key:'defense', label:'Defense' },
  { key:'speed', label:'Speed' },
  { key:'devastation', label:'Devastation' },
  { key:'clarity', label:'Clarity' },
  { key:'endurance', label:'Endurance' },
];
const QUALITY_ORDER = ['Very Mediocre','Mediocre','Adequate','Good','Very Good','Excellent','Legendary','Mythical','Epic','Divine','Unreal'];

function _archetypeRankForLevel(lvl){
  const thresholds = [[80,12],[70,11],[60,10],[50,9],[40,8],[30,7],[20,6],[10,5],[1,4]];
  const v = Math.max(1, Number(lvl)||1);
  for (const [lv,r] of thresholds){
    if (v >= lv) return r;
  }
  return 1;
}
const TARGET_GROUPS = [
  { label:'Characteristics', options:[
    { value:'char.reflex', label:'Reflex (modifier)' },
    { value:'char.dexterity', label:'Dexterity (modifier)' },
    { value:'char.body', label:'Body (modifier)' },
    { value:'char.wisdom', label:'Wisdom (modifier)' },
    { value:'char.presence', label:'Presence (modifier)' },
    { value:'char.magic', label:'Magic (modifier)' },
    { value:'char.willpower', label:'Willpower (modifier)' },
    { value:'char.tech', label:'Tech (modifier)' },
  ]},
  { label:'Skills', options:[
    { value:'skills.reflex.Technicity', label:'Technicity (Reflex)' },
    { value:'skills.reflex.Dodge', label:'Dodge (Reflex)' },
    { value:'skills.reflex.Counter', label:'Counter (Reflex)' },
    { value:'skills.reflex.Reactivity', label:'Reactivity (Reflex)' },
    { value:'skills.dexterity.Accuracy', label:'Accuracy (Dexterity)' },
    { value:'skills.dexterity.Evasion', label:'Evasion (Dexterity)' },
    { value:'skills.dexterity.Stealth', label:'Stealth (Dexterity)' },
    { value:'skills.dexterity.Acrobatics', label:'Acrobatics (Dexterity)' },
    { value:'skills.body.Brutality', label:'Brutality (Body)' },
    { value:'skills.body.Blocking', label:'Blocking (Body)' },
    { value:'skills.body.Resistance', label:'Resistance (Body)' },
    { value:'skills.body.Athletics', label:'Athletics (Body)' },
    { value:'skills.wisdom.Survival', label:'Survival (Wisdom)' },
    { value:'skills.wisdom.Education', label:'Education (Wisdom)' },
    { value:'skills.wisdom.Perception', label:'Perception (Wisdom)' },
    { value:'skills.wisdom.Psychology', label:'Psychology (Wisdom)' },
    { value:'skills.wisdom.Investigation', label:'Investigation (Wisdom)' },
    { value:'skills.presence.Taming', label:'Taming (Presence)' },
    { value:'skills.presence.Charm', label:'Charm (Presence)' },
    { value:'skills.presence.Charisma', label:'Charisma (Presence)' },
    { value:'skills.presence.Deception', label:'Deception (Presence)' },
    { value:'skills.presence.Persuasion', label:'Persuasion (Presence)' },
    { value:'skills.magic.Aura', label:'Aura (Magic)' },
    { value:'skills.magic.Incantation', label:'Incantation (Magic)' },
    { value:'skills.magic.Enchantment', label:'Enchantment (Magic)' },
    { value:'skills.magic.Restoration', label:'Restoration (Magic)' },
    { value:'skills.magic.Potential', label:'Potential (Magic)' },
    { value:'skills.willpower.Intimidation', label:'Intimidation (Willpower)' },
    { value:'skills.willpower.Spirit', label:'Spirit (Willpower)' },
    { value:'skills.willpower.Instinct', label:'Instinct (Willpower)' },
    { value:'skills.willpower.Absorption', label:'Absorption (Willpower)' },
    { value:'skills.tech.Crafting', label:'Crafting (Tech)' },
    { value:'skills.tech.Sleight of hand', label:'Sleight of hand (Tech)' },
    { value:'skills.tech.Alchemy', label:'Alchemy (Tech)' },
    { value:'skills.tech.Medicine', label:'Medicine (Tech)' },
    { value:'skills.tech.Engineering', label:'Engineering (Tech)' },
  ]},
  { label:'Intensities', options: INTENSITIES.map(n=>({ value:`intensities.${n}`, label:`${n} (Magic)` })) },
  { label:'Derived / Resources', options:[
    { value:'derived.hp', label:'HP' },
    { value:'derived.en', label:'EN' },
    { value:'derived.fo', label:'FO' },
    { value:'derived.mo', label:'MO' },
    { value:'derived.spcap', label:'SP cap' },
    { value:'derived.enc', label:'Encumbrance' },
    { value:'derived.et', label:'Eclipse Threshold (ET)' },
    { value:'derived.tx', label:'Max Toxicity (TX)' },
    { value:'derived.talent_max', label:'Talent Max' },
  ]},
  { label:'Custom', options:[{ value:'__custom__', label:'Custom path...' }]}
];
function totalFromInvest(v){ return (parseInt(v||0,10) || 0) + 4; }
function modFromTotal(total){ return Math.floor((Number(total)-10)/2); }
function numOr(v, fb=0){
  const n = Number(v);
  return Number.isFinite(n) ? n : fb;
}
function investVal(v, fb=0){
  if (v && typeof v === 'object') return numOr(v.invest, fb);
  return numOr(v, fb);
}
const lc = (s)=> String(s||'').toLowerCase();
const QUALITY_SLOTS = { "Adequate":1,"Good":2,"Very Good":3,"Excellent":4,"Legendary":5,"Mythical":6,"Epic":7,"Divine":8,"Unreal":9 };
function slotsForQuality(q){ return QUALITY_SLOTS[q] || 0; }
function qualityStepDelta(q){
  const baseIdx = QUALITY_ORDER.findIndex(x=> lc(x) === 'adequate');
  const idx = QUALITY_ORDER.findIndex(x=> lc(x) === lc(q));
  if (idx === -1 || baseIdx === -1) return 0;
  return idx - baseIdx;
}
function debounce(fn, ms=300){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }
function qualityStepFromNote(note){
  if (!note) return 0;
  const m = String(note).match(/([+-]?\d+(?:\.\d+)?)\s*(?:per\s+quality|\/\s*quality)/i);
  return m ? Number(m[1]) || 0 : 0;
}
const MAX_LEVEL = 100;
function xpForLevel(level){
  const lvl = Math.max(1, Math.min(MAX_LEVEL, Math.floor(level||1)));
  return 100 * ((lvl-1) * lvl / 2);
}
function levelFromXp(xp){
  const val = Math.max(0, Math.floor(xp||0));
  let lvl = 1;
  for (let i=1;i<MAX_LEVEL;i++){
    const next = xpForLevel(i+1);
    if (val < next) break;
    lvl = i+1;
  }
  return lvl;
}

/* State */
const params = new URLSearchParams(location.search);
const CID = params.get('id');
let ROLE = 'user';
let SAVE_TIMER = null;
let CHAR = null;
let ASSIGNED = []; // full documents of assigned abilities (resolved by id)
let ABILITY_CHOICES = {}; // per-ability user selections for configurable modifiers (choices or groups)
let ITEM_CHOICES = {}; // per-item (inventory) user selections for choice-based modifiers
let INVENTORIES = [];
let LINKED_INV = null;
let SELECTED_INV_ID = '';
let INV_LAST_RESULTS = [];
let INV_FILTERED = [];
let SPELL_LISTS = [];
let LINKED_SPELL_LIST = null;
let SELECTED_SPELL_LIST_ID = '';
let SPELLLIST_SPELLS = [];
let SPELLLIST_META = {};
let ADDED_SCHOOLS = new Set();
const setAddedSchools = (arr=[])=>{
  ADDED_SCHOOLS = new Set((arr || []).map(String));
  if (CHAR && CHAR.stats) CHAR.stats.selected_schools = Array.from(ADDED_SCHOOLS);
  renderSchoolSpellCounters();
};
let XP = 0;
let SCHOOLS = [];
let SUBLIMATIONS = [];
let SUB_HIDDEN = {};
let PERSONAL = {};
let CURRENT = { hp:null, en:null, fo:null, sp:null };
let OVERRIDE_ENABLED = false;
let OVERRIDE_VALUES = { hp:null, en:null, fo:null, mo:null, spcap:null, enc:null, et:null, tx:null };
let ARCHETYPES = [];
let COMPUTED_ARC_ABILITIES = [];
let UPGRADE_META = {};
let TALENT_MAX = 1;

/* Passive bonus aggregations (recomputed whenever ASSIGNED changes) */
let PASSIVE = {
  char: {},     // key -> { set:[], mul:[], add:[], notes:[] }  (applied to characteristic MOD)
  skill: {},    // "key|skill" -> { set:[], mul:[], add:[], notes:[] } (applied to skill TOTAL)
  school: {},   // schoolId -> { set:[], mul:[], add:[], notes:[] } (applied to MS for that school)
};

/* DOM refs */
const loginChip = document.getElementById('login-chip');
const adminLink = document.getElementById('admin-link');
const titleEl   = document.getElementById('title');
const statusEl  = document.getElementById('status');
const nameEl    = document.getElementById('name');
const deleteBtn = document.getElementById('delete-char');
const gridEl    = document.getElementById('stats-grid');

/* derived refs */
const levelEl = document.getElementById('level');
const hpEl = document.getElementById('hp-val');
const enEl = document.getElementById('en-val');
const foEl = document.getElementById('fo-val');
const moEl = document.getElementById('mo-val');
const spcapEl = document.getElementById('spcap-val');
const encEl = document.getElementById('enc-val');
const etEl = document.getElementById('et-val');
const txEl = document.getElementById('tx-val');
const skillCounterEl = document.getElementById('skill-counter');
const statCounterEl = document.getElementById('stat-counter');
const skillCapEl = document.getElementById('skill-cap');
const overrideToggle = document.getElementById('override-derived');
const overrideInputsWrap = document.getElementById('override-inputs');
const ovHpEl = document.getElementById('ov-hp');
const ovEnEl = document.getElementById('ov-en');
const ovFoEl = document.getElementById('ov-fo');
const ovMoEl = document.getElementById('ov-mo');
const ovSpEl = document.getElementById('ov-spcap');
const curHpEl = document.getElementById('cur-hp');
const curEnEl = document.getElementById('cur-en');
const curFoEl = document.getElementById('cur-fo');
const curSpEl = document.getElementById('cur-sp');

/* Abilities tab refs */
const abiOpenAddBtn = document.getElementById('abi-open-add');
const abiAddModal = document.getElementById('abi-add-modal');
const abiAddBackdrop = document.getElementById('abi-add-backdrop');
const abiAddClose = document.getElementById('abi-add-close');
const abiAddCancel = document.getElementById('abi-add-cancel');
const abiSearchEl = document.getElementById('abi-search');
const abiFilterTypeEl = document.getElementById('abi-filter-type');
const abiFilterSrcEl  = document.getElementById('abi-filter-source');
const abiSearchBtn = document.getElementById('abi-search-btn');
const abiResultsEl = document.getElementById('abi-results');
const listPassiveEl   = document.getElementById('abi-list-passive');
const listActiveEl    = document.getElementById('abi-list-active');
const listSpellEl     = document.getElementById('abi-list-spells');
const talentCounterEl = document.getElementById('talent-counter');
const choiceModal = document.getElementById('choice-modal');
const choiceBackdrop = document.getElementById('choice-backdrop');
const choiceClose = document.getElementById('choice-close');
const choiceCancel = document.getElementById('choice-cancel');
const choiceSave = document.getElementById('choice-save');
const choiceBody = document.getElementById('choice-body');
const choiceTitle = document.getElementById('choice-title');
const arcSelectEl     = document.getElementById('arc-select');
const arcApplyBtn     = document.getElementById('arc-apply');
const arcStatusEl     = document.getElementById('arc-status');
const arcSummaryEl    = document.getElementById('arc-summary');
const arcAbilitiesEl  = document.getElementById('arc-abilities');
/* Inventory tab refs */
const invSelectEl = document.getElementById('inv-select');
const invLoadBtn = document.getElementById('inv-load-btn');
const invDupLinkBtn = document.getElementById('inv-dup-link');
const invOpenManagerBtn = document.getElementById('inv-open-manager');
const invStatusEl = document.getElementById('inv-status');
const invManagerEl = document.getElementById('inv-manager');
const invTitleEl = document.getElementById('inv-title');
const invMoneyEl = document.getElementById('inv-money');
const invEncTotalEl = document.getElementById('inv-enc-total');
const invFundCurEl = document.getElementById('inv-fund-cur');
const invFundAmtEl = document.getElementById('inv-fund-amt');
const invFundNoteEl = document.getElementById('inv-fund-note');
const invContainersEl = document.getElementById('inv-containers');
const invNewContNameEl = document.getElementById('inv-new-cont-name');
const invAddContBtn = document.getElementById('inv-add-cont');
const invTxEl = document.getElementById('inv-tx');
const invQEl = document.getElementById('inv-q');
const invKindEl = document.getElementById('inv-kind');
const invCatEl = document.getElementById('inv-cat-select');
const invLimitEl = document.getElementById('inv-limit');
const invSearchBtn = document.getElementById('inv-search');
const invClearBtn = document.getElementById('inv-clear');
const invPriceModEl = document.getElementById('inv-price-mod');
const invGlobalContEl = document.getElementById('inv-global-cont');
const invGlobalCurEl = document.getElementById('inv-global-cur');
const invEquippedFlagEl = document.getElementById('inv-equpped-flag');
const invResultsEl = document.getElementById('inv-results');
const invItemModal = document.getElementById('inv-item-modal');
const invItemBackdrop = document.getElementById('inv-item-backdrop');
const invItemTitle = document.getElementById('inv-item-title');
const invItemBody = document.getElementById('inv-item-body');
const invItemActions = document.getElementById('inv-item-actions');
const invFundOpenBtn = document.getElementById('inv-fund-open');
const invFundModal = document.getElementById('inv-fund-modal');
const invFundBackdrop = document.getElementById('inv-fund-backdrop');
const invFundClose = document.getElementById('inv-fund-close');
const invFundSave = document.getElementById('inv-fund-save');
const invFundCancel = document.getElementById('inv-fund-cancel');
const invFundStatus = document.getElementById('inv-fund-status');
const invCatalogOpenBtn = document.getElementById('inv-catalog-open');
const invCreateBtn = document.getElementById('inv-create-btn');
const invCatalogModal = document.getElementById('inv-catalog-modal');
const invCatalogBackdrop = document.getElementById('inv-catalog-backdrop');
const invCatalogClose = document.getElementById('inv-catalog-close');
const SELF_CONTAINER_ID = 'self';
/* Spell list refs */
const avatarPreview = document.getElementById('avatar-preview');
const avatarOpenBtn = document.getElementById('avatar-open');
const avatarFileEl = document.getElementById('avatar-file');
const avatarZoomEl = document.getElementById('avatar-zoom');
const avatarOffsetXEl = document.getElementById('avatar-offset-x');
const avatarOffsetYEl = document.getElementById('avatar-offset-y');
const avatarUploadBtn = document.getElementById('avatar-upload');
const avatarModal = document.getElementById('avatar-modal');
const avatarBackdrop = document.getElementById('avatar-backdrop');
const avatarClose = document.getElementById('avatar-close');
const avatarCancel = document.getElementById('avatar-cancel');
const avatarStatusEl = document.getElementById('avatar-status');
const avatarCanvas = document.getElementById('avatar-canvas');
let AVATAR_IMG = null;
if (avatarPreview){
  avatarPreview.onerror = ()=>{ avatarPreview.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9WUZPi8AAAAASUVORK5CYII='; };
}
const slSelectEl = document.getElementById('sl-select');
const slLoadBtn = document.getElementById('sl-load-btn');
const slCreateBtn = document.getElementById('sl-create-btn');
const slDupBtn = document.getElementById('sl-dup-btn');
const slStatusEl = document.getElementById('sl-status');
const slSummaryEl = document.getElementById('sl-summary');
const cntSchSimpleEl = document.getElementById('cnt-sch-simple');
const cntSchComplexEl = document.getElementById('cnt-sch-complex');
const cntSpSimpleEl = document.getElementById('cnt-sp-simple');
const cntSpComplexEl = document.getElementById('cnt-sp-complex');
const slSchoolsEl = document.getElementById('sl-schools');
const xpProgressEl = document.getElementById('xp-progress');
const xpAddBtn = document.getElementById('xp-add-btn');
const levelSetBtn = document.getElementById('level-set-btn');
const slSchoolsStatusEl = document.getElementById('sl-schools-status');
const slAddMenuBtn = document.getElementById('sl-add-menu-btn');
const slAddMenu = document.getElementById('sl-add-menu');
const slQuickAddBtn = document.getElementById('sl-quick-add');
const slManualAddBtn = document.getElementById('sl-manual-add');
const slSchModal = document.getElementById('sl-sch-modal');
const slSchBackdrop = document.getElementById('sl-sch-modal-backdrop');
const slSchClose = document.getElementById('sl-sch-close');
const slSchCancel = document.getElementById('sl-sch-cancel');
const slSchApply = document.getElementById('sl-sch-apply');
const slSchBody = document.getElementById('sl-sch-body');
const slSchStatus = document.getElementById('sl-sch-status');
const slSpellsBody = document.getElementById('sl-spells-body');
const slOpenAddBtn = document.getElementById('sl-open-add');
const slAddModal = document.getElementById('sl-add-modal');
const slAddBackdrop = document.getElementById('sl-add-backdrop');
const slAddClose = document.getElementById('sl-add-close');
const slAddCancel = document.getElementById('sl-add-cancel');
const slSearchQ = document.getElementById('sl-search-q');
const slSearchBtn = document.getElementById('sl-search-btn');
const slSearchBody = document.getElementById('sl-search-body');
const slAddStatus = document.getElementById('sl-add-status');
const abiSpellsOnlyLearnedEl = document.getElementById('abi-spells-only-learned');
const ABI_SPELLS_FILTER_KEY = 'abi_spells_only_learned';
let EFFECTS_BY_ID = {};
let EFFECTS_PROMISE = null;

function initAbiSpellsFilter(){
  if (!abiSpellsOnlyLearnedEl) return;
  try{
    const stored = localStorage.getItem(ABI_SPELLS_FILTER_KEY);
    abiSpellsOnlyLearnedEl.checked = stored ? stored === '1' : true;
  }catch{}
  abiSpellsOnlyLearnedEl.addEventListener('change', ()=>{
    try{ localStorage.setItem(ABI_SPELLS_FILTER_KEY, abiSpellsOnlyLearnedEl.checked ? '1' : '0'); }catch{}
    renderAbilitySpellsBucket();
  });
}

async function ensureEffectsLoaded(){
  if (Object.keys(EFFECTS_BY_ID).length) return EFFECTS_BY_ID;
  if (EFFECTS_PROMISE) return EFFECTS_PROMISE;
  EFFECTS_PROMISE = api('/effects').then(res=>{
    const list = res.effects || [];
    EFFECTS_BY_ID = {};
    list.forEach(e=>{ EFFECTS_BY_ID[String(e.id||e._id||'').toLowerCase()] = e; });
    return EFFECTS_BY_ID;
  }).catch(()=>({})).finally(()=>{ EFFECTS_PROMISE = null; });
  return EFFECTS_PROMISE;
}
/* Sublimations refs */
const subTypeEl = document.getElementById('sub-type');
const subTierEl = document.getElementById('sub-tier');
const subSkillEl = document.getElementById('sub-skill');
const subSkillLabel = document.getElementById('sub-skill-label');
const subNatureEl = document.getElementById('sub-nature');
const subNatureLabel = document.getElementById('sub-nature-label');
const subAddBtn = document.getElementById('sub-add-btn');
const subListEl = document.getElementById('sub-list');
const subSlotPill = document.getElementById('sub-slot-pill');
const subWarningEl = document.getElementById('sub-warning');
const subHiddenEl = document.getElementById('sub-hidden');
const subOpenBtn = document.getElementById('sub-open-btn');
const subModal = document.getElementById('sub-modal');
const subBackdrop = document.getElementById('sub-backdrop');
const subClose = document.getElementById('sub-close');
const subCancel = document.getElementById('sub-cancel');
initAbiSpellsFilter();
/* Personal refs */
const pNickEl = document.getElementById('p-nicknames');
const pHeightEl = document.getElementById('p-height');
const pWeightEl = document.getElementById('p-weight');
const pEloEl = document.getElementById('p-elo');
const pRankEl = document.getElementById('p-rank');
const pFriendsEl = document.getElementById('p-friends');
const pEnemiesEl = document.getElementById('p-enemies');
const pNotesEl = document.getElementById('p-notes');
const pBackstoryEl = document.getElementById('p-backstory');

// Sublimations form wiring
(() => {
  const skillOpts = buildSkillOptions();
  subSkillEl.innerHTML = '';
  skillOpts.forEach(opt=>{
    const o = document.createElement('option');
    o.value = opt.value; o.textContent = opt.label;
    subSkillEl.appendChild(o);
  });
  subNatureEl.innerHTML = '<option value=\"\">-- choose --</option>';
  NATURES.forEach(n=>{
    const o = document.createElement('option');
    o.value = n; o.textContent = n;
    subNatureEl.appendChild(o);
  });
  subTypeEl.addEventListener('change', updateSubSpecialFields);
  subAddBtn.addEventListener('click', addSublimationFromForm);
  updateSubSpecialFields();
})();
subOpenBtn?.addEventListener('click', ()=>{
  subModal?.classList.remove('hidden');
  subBackdrop?.classList.remove('hidden');
  subModal?.classList.add('open');
  subBackdrop?.classList.add('open');
});
const closeSubModal = ()=>{
  subModal?.classList.remove('open');
  subBackdrop?.classList.remove('open');
  subModal?.classList.add('hidden');
  subBackdrop?.classList.add('hidden');
};
subClose?.addEventListener('click', closeSubModal);
subCancel?.addEventListener('click', closeSubModal);
subBackdrop?.addEventListener('click', (e)=>{ if (e.target === subBackdrop) closeSubModal(); });

// Overrides & current handlers
[curHpEl, curEnEl, curFoEl, curSpEl].forEach(el=>{
  el?.addEventListener('input', ()=>{
    CURRENT = {
      hp: Number(curHpEl?.value||0),
      en: Number(curEnEl?.value||0),
      fo: Number(curFoEl?.value||0),
      sp: Number(curSpEl?.value||0),
    };
    updateDerived(); queueSave();
  });
});

/* tabs switching */
document.querySelectorAll('.tab').forEach(tab=>{
  tab.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tabpane').forEach(p=>p.style.display='none');
    tab.classList.add('active');
    const id = tab.getAttribute('data-tab');
    document.getElementById(id).style.display='';
  });
});

/* auth */
async function checkMe() {
  loginChip.textContent = 'Checking login...';
  try{
    const me = await api('/auth/me');
    loginChip.textContent = `${me.username} (${me.role})`;
    if ((me.role||'').toLowerCase()==='admin') adminLink.style.display='';
    ROLE = me.role||'user';
    return me;
  } catch(e){
    loginChip.textContent = 'Not logged in';
    adminLink.style.display='none';
    throw e;
  }
}

/* defaults */
function makeDefaultStats(){
  const stats = {};
  for (const c of CHARACS){
    const sk = {};
    for (const s of c.skills) sk[s] = 0;
    stats[c.key] = { invest: 0, skills: sk };
  }
  const ints = {};
  for (const n of INTENSITIES){ ints[n] = 0; }
  stats.intensities = ints;
  stats.personal = {
    nicknames: "",
    height: "",
    weight: "",
    elo: "",
    rank: "",
    friends: "",
    enemies: "",
    notes: "",
    backstory: "",
  };
  return stats;
}

function skillMaxForLevel(lvl){
  if (lvl <= 1) return 4;
  if (lvl <= 11) return 5;
  if (lvl <= 21) return 6;
  if (lvl <= 31) return 7;
  if (lvl <= 41) return 8;
  if (lvl <= 51) return 9;
  return 10;
}
function skillPointPool(lvl){
  // 80 at level 1, +2 per level-up
  return 80 + Math.max(0, (Math.max(1, lvl) - 1) * 2);
}
function statPointPool(lvl){
  // 24 at level 1, +3 every 9 levels (per KP rule)
  return 24 + Math.floor((Math.max(1, lvl) - 1) / 9) * 3;
}
function statInvestCap(lvl){
  const lv = Math.max(1, Math.floor(Number(lvl) || 1));
  // Base total cap 10, +1 every 10 levels, max 20
  const maxTotal = Math.min(20, 10 + Math.floor(lv / 10));
  return Math.max(0, maxTotal - 4); // convert back to invest (base is 4)
}
function statTotalCap(lvl){
  return totalFromInvest(statInvestCap(lvl));
}
function totalSkillInvest(){
  let t = 0;
  for (const c of CHARACS){
    const rec = (CHAR.stats && CHAR.stats[c.key]) || {};
    for (const s of (c.skills||[])){
      t += investVal(rec.skills?.[s], 0);
    }
  }
  if (CHAR.stats?.intensities){
    for (const n of INTENSITIES){
      t += investVal(CHAR.stats.intensities[n], 0);
    }
  }
  return t;
}
function totalStatInvest(){
  let t = 0;
  for (const c of CHARACS){
    t += investVal(CHAR.stats?.[c.key]?.invest, 0);
  }
  return t;
}
function updatePointCounters(){
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const poolSkill = skillPointPool(lvl);
  const poolStat = statPointPool(lvl);
  const usedSkill = totalSkillInvest();
  const usedStat = totalStatInvest();
  const capSkillInvest = skillMaxForLevel(lvl);
  const capStatInvest = statInvestCap(lvl);
  const capStatTotal = statTotalCap(lvl);
  if (skillCounterEl) skillCounterEl.textContent = `Skills: ${usedSkill} / ${poolSkill}`;
  if (statCounterEl){
    statCounterEl.textContent = `Characteristics: ${usedStat} / ${poolStat} (max invest per stat: ${capStatInvest}, base total cap: ${capStatTotal})`;
    statCounterEl.title = `You can invest up to ${capStatInvest} per stat (base total ${capStatTotal}); modifiers may push higher.`;
  }
  if (skillCapEl){
    skillCapEl.textContent = `Max per skill (invest): ${capSkillInvest}`;
    skillCapEl.title = 'Cap applies to invested points; bonuses can raise totals beyond this.';
  }
}

/* ---------- Sublimations helpers ---------- */
function normalizeSublimations(arr){
  const out = [];
  (arr || []).forEach(s=>{
    if (!s || !s.type) return;
    const tier = Math.min(4, Math.max(1, Number(s.tier)||1));
    out.push({
      id: s.id || `sub_${Date.now()}_${Math.random().toString(16).slice(2)}`,
      type: String(s.type||'').toLowerCase(),
      tier,
      skill: s.skill || '',
      nature: s.nature || ''
    });
  });
  return out;
}
function slotsForLevel(lvl){
  const base = 2; // unlocked immediately, +2 every 10 levels
  return base + (Math.floor(Math.max(1, lvl-1) / 10) * 2);
}
function slotsUsed(subs){
  return (subs||[]).reduce((acc,s)=> acc + (SUB_TIER_SLOTS[s.tier] || 0), 0);
}
function buildSkillOptions(){
  const opts = [];
  for (const c of CHARACS){
    for (const s of c.skills){
      opts.push({ value:`${c.key}|${s}`, label:`${s} (${c.name})` });
    }
  }
  // Allow intensities as targetable â€œskillsâ€ for Excellence
  INTENSITIES.forEach(n=>{
    opts.push({ value:`magic|${n}`, label:`${n} (Intensity)` });
  });
  return opts;
}

function updateSubSpecialFields(){
  const t = (subTypeEl.value || '').toLowerCase();
  const isEx = t === 'excellence';
  const isBless = t === 'blessing';
  subSkillEl.style.display = subSkillLabel.style.display = isEx ? '' : 'none';
  subNatureEl.style.display = subNatureLabel.style.display = isBless ? '' : 'none';
}

function sublimationDescription(sub){
  const t = (sub.type || '').toLowerCase();
  const tier = Math.min(4, Math.max(1, Number(sub.tier) || 1));
  if (t === 'lethality') return `+${2 * tier} neutral weapon dmg (not animarmas)`;
  if (t === 'blessing') return `+${2 * tier} ${(sub.nature || 'magic').toLowerCase()} dmg to space actions`;
  if (t === 'excellence'){
    const name = (sub.skill || '').split('|')[1] || 'skill';
    return `+${tier} to ${name}`;
  }
  if (t === 'defense') return `+${12 * tier} HP`;
  if (t === 'speed') return `+${tier} MO`;
  if (t === 'devastation') return `+${tier} Condition DC`;
  if (t === 'clarity') return `+${2 * tier} EN`;
  if (t === 'endurance') return `+${2 * tier} FO`;
  return '';
}

function renderSublimations(){
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const cap = slotsForLevel(lvl);
  const used = slotsUsed(SUBLIMATIONS);
  subSlotPill.textContent = `Slots: ${used} / ${cap}`;
  subWarningEl.textContent = used > cap ? 'Over capacity' : '';

  subListEl.innerHTML = '';
  if (!SUBLIMATIONS.length){
    subListEl.innerHTML = '<div class="muted">No sublimations set.</div>';
  }else{
    SUBLIMATIONS.forEach(sub=>{
      const row = document.createElement('div');
      row.className = 'abi-item';
      const desc = sublimationDescription(sub);
      row.innerHTML = `
        <div class="grow">
          <div class="row" style="align-items:center; gap:8px;">
            <strong>${sub.type}</strong>
            <span class="pill">Tier ${sub.tier}</span>
            ${desc ? `<span class="pill muted" style="opacity:.9;">${desc}</span>` : ''}
          </div>
        </div>
      `;

      const rem = document.createElement('button');
      rem.className = 'btn btn-secondary small';
      rem.textContent = 'Remove';
      rem.addEventListener('click', ()=>{
        SUBLIMATIONS = SUBLIMATIONS.filter(s=>s.id !== sub.id);
        onSublimationChanged();
      });
      row.appendChild(rem);

      subListEl.appendChild(row);
    });
  }

  const { hidden } = getSublimationEffects();
  const parts = [];
  if (hidden.weaponNeutral) parts.push(`+${hidden.weaponNeutral} neutral weapon dmg (not animarmas)`);
  if (hidden.magicBonus) parts.push(`+${hidden.magicBonus} ${hidden.magicNature || 'magic'} dmg to space actions`);
  if (hidden.conditionDC) parts.push(`+${hidden.conditionDC} Condition DC`);
  subHiddenEl.textContent = parts.length ? `Hidden effects: ${parts.join(' | ')}` : '';
}

function onSublimationChanged(){
  renderSublimations();
  recomputePassiveAgg();
  renderStatistics();
  updateDerived();
  queueSave();
}

function addSublimationFromForm(){
  const type = (subTypeEl.value || '').toLowerCase();
  const tier = Math.min(4, Math.max(1, Number(subTierEl.value)||1));
  const skill = subSkillEl.value || '';
  const nature = subNatureEl.value || '';
  if (!type){ subWarningEl.textContent = 'Pick a type'; return; }
  if (type === 'excellence' && !skill){ subWarningEl.textContent = 'Choose a skill for Excellence'; return; }
  if (type === 'blessing' && !nature){ subWarningEl.textContent = 'Choose a nature for Blessing'; return; }
  if (type !== 'excellence' && SUBLIMATIONS.some(s=>s.type===type)){
    subWarningEl.textContent = 'This sublimation type is already slotted';
    return;
  }
  if (type === 'excellence' && SUBLIMATIONS.some(s=>s.type==='excellence' && s.skill === skill)){
    subWarningEl.textContent = 'That skill already has an Excellence';
    return;
  }
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const cap = slotsForLevel(lvl);
  const newUsed = slotsUsed(SUBLIMATIONS) + (SUB_TIER_SLOTS[tier] || 0);
  if (newUsed > cap){
    subWarningEl.textContent = 'Not enough slots';
    return;
  }
  subWarningEl.textContent = '';
  SUBLIMATIONS = SUBLIMATIONS.concat([{ id:`sub_${Date.now()}_${Math.random().toString(16).slice(2)}`, type, tier, skill, nature }]);
  onSublimationChanged();
  if (typeof closeSubModal === 'function') closeSubModal();
}

/* ---------- PASSIVE AGGREGATION (char & skills) ---------- */
function resetPassiveAgg(){
  PASSIVE = { char:{}, skill:{}, school:{}, magic_damage:{ spell:{}, weapon:{} } };
}
function ensureAgg(obj, key){
  if (!obj[key]) obj[key] = { set:[], mul:[], add:[], notes:[] };
  return obj[key];
}
function modEffectiveValue(mod){
  const base = Number(mod?.value || 0);
  const step = Math.max(0, Number(mod?.level_step || 0));
  const inc = Number(mod?.level_increment || 1);
  if (step > 0){
    const lvl = Math.max(1, Math.floor(Number(CHAR?.level || levelEl?.value || 1)));
    const extra = Math.floor((lvl - 1) / step) * inc;
    return base + extra;
  }
  return base;
}
function normalizeChoiceEntry(val){
  if (!val) return { base:'', picks:[] };
  if (Array.isArray(val)) return { base:'', picks: val.filter(Boolean) };
  const picks = Array.isArray(val.picks) ? val.picks.slice()
    : Array.isArray(val.selected) ? val.selected.slice()
    : [];
  const base = val.base || val.source || '';
  return { base, picks: picks.filter(Boolean) };
}
function normalizeRestrict(choice){
  // Accept either the whole modifier or the nested choice object.
  if (!choice) return [];
  const src = choice.choice || choice;
  if (Array.isArray(src.restrict)) return src.restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(src.choice_restrict)) return src.choice_restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(src.restrict_list)) return src.restrict_list.map(s=> String(s).trim()).filter(Boolean);
  // Some older records stored restrict fields at the modifier level instead of inside choice
  if (Array.isArray(choice.restrict)) return choice.restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(choice.choice_restrict)) return choice.choice_restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(choice.restrict_list)) return choice.restrict_list.map(s=> String(s).trim()).filter(Boolean);
  const txt = src.restrict_text || src.choice_restrict || src.restrict_list || src.restrict || src.restrict_string ||
    choice.restrict_text || choice.choice_restrict || choice.restrict_list || choice.restrict || choice.restrict_string || '';
  if (typeof txt === 'string'){
    return String(txt).split(',').map(s=>s.trim()).filter(Boolean);
  }
  return [];
}
function normalizeChoiceAllowed(choice){
  if (!choice) return [];
  const src = choice.choice || choice;
  if (Array.isArray(src.choices)) return src.choices.map(s=> String(s).trim()).filter(Boolean);
  const txt = src.choices_text || '';
  if (typeof txt === 'string' && txt.trim()){
    return txt.split(',').map(s=> s.trim()).filter(Boolean);
  }
  return [];
}
function abilityChoiceSelections(ab, kind){
  const byAb = ABILITY_CHOICES[ab.id] || {};
  return normalizeChoiceEntry(byAb[kind]).picks;
}
function abilityChoiceState(ab, kind){
  const byAb = ABILITY_CHOICES[ab.id] || {};
  return normalizeChoiceEntry(byAb[kind]);
}
function itemChoiceState(itemId, kind){
  const byItem = ITEM_CHOICES[itemId] || {};
  return normalizeChoiceEntry(byItem[kind]);
}
function abilityGroupSelections(ab){
  const byAb = ABILITY_CHOICES[ab.id] || {};
  return byAb._groups || {};
}
function setAbilityGroupSelections(abId, data){
  if (!ABILITY_CHOICES[abId]) ABILITY_CHOICES[abId] = {};
  ABILITY_CHOICES[abId]._groups = data || {};
}
function abilityGroups(ab){
  const mods = (ab?.passive?.modifiers || []);
  const map = new Map();
  mods.forEach((m, idx)=>{
    const name = (m.group || '').trim();
    if (!name) return;
    const max = 1; // groups are mutually exclusive
    const entry = map.get(name) || { name, max, options: [] };
    entry.options.push({ idx, mod: m });
    map.set(name, entry);
  });
  return Array.from(map.values());
}
function resolveGroupSelections(ab){
  const groups = abilityGroups(ab);
  const stored = abilityGroupSelections(ab);
  const active = new Set();
  const selections = {};
  groups.forEach(g=>{
    const allowed = g.options.map(o=> o.idx);
    const limit = g.max > 0 ? g.max : allowed.length;
    const saved = Array.isArray(stored[g.name]) ? stored[g.name] : [];
    let picks = saved.map(x=> Number(x)).filter(i=> allowed.includes(i));
    if (!picks.length){
      picks = allowed.slice(0, limit);
    }else if (limit > 0 && picks.length > limit){
      picks = picks.slice(0, limit);
    }
    selections[g.name] = picks;
    picks.forEach(i=> active.add(i));
  });
  if (ab?.id && JSON.stringify(stored) !== JSON.stringify(selections)){
    setAbilityGroupSelections(ab.id, selections);
  }
  return { active, selections, groups };
}
function prettyTargetLabel(target){
  const t = String(target||'').trim();
  if (!t) return '(unknown target)';
  if (t.startsWith('choice:')){
    const inner = t.replace(/^choice:/,'');
    const base = prettyTargetLabel(inner);
    return base.startsWith('[Choice]') ? base : `[Choice] ${base}`;
  }
  const cm = t.match(/^char\.(.+)$/i);
  if (cm){
    const key = cm[1].toLowerCase();
    const hit = CHARACS.find(c=> c.key === key);
    return hit ? `${hit.name} (Characteristic)` : t;
  }
  const sm = t.match(/^skills\.([^.]+)\.(.+)$/i);
  if (sm){
    const ckey = sm[1].toLowerCase();
    const sk = sm[2];
    const hit = CHARACS.find(c=> c.key === ckey);
    return hit ? `${sk} (${hit.name})` : `Skill: ${sk}`;
  }
  const im = t.match(/^intensities\.(.+)$/i);
  if (im) return `Intensity: ${im[1]}`;
  const sch = t.match(/^schools\.(.+)$/i);
  if (sch){
    const raw = sch[1];
    const found = (SCHOOLS||[]).find(s=> String(s.id||'').toLowerCase() === String(raw).toLowerCase());
    return found ? `${found.name} (School)` : `School: ${raw}`;
  }
  const md = t.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
  if (md) return `${md[2]} magic damage (${md[1]})`;
  const sg = t.match(/^skills\.by_char\.(.+)$/i);
  if (sg) return `Skills linked to ${sg[1]}`;
  const sn = t.match(/^schools\.by_nature\.(.+)$/i);
  if (sn) return `Schools linked to ${sn[1]}`;
  const ss = t.match(/^schools\.by_skill\.(.+)$/i);
  if (ss) return `Schools using ${ss[1]}`;
  if (t === 'skill_ms') return 'Magic School (by skill)';
  if (t === 'nature_ms') return 'Magic School (by nature)';
  if (t === 'char_skill') return 'Skill linked to characteristic';
  if (t === 'school_any' || t === 'school_ms') return 'Magic School';
  if (t === 'intensity_any') return 'Intensity';
  return t;
}
function expandedTargets(mod){
  const baseTarget = String(mod.target || mod.key || '').trim();
  if (!baseTarget) return [];
  const out = [];
  const push = (t)=> out.push({ ...mod, target: t });
  const sg = baseTarget.match(/^skills\.by_char\.(.+)$/i);
  if (sg){
    const key = sg[1].toLowerCase();
    const hit = CHARACS.find(c=> c.key === key);
    if (hit){
      (hit.skills || []).forEach(sk=> push(`skills.${key}.${sk}`));
      return out;
    }
  }
  const schN = baseTarget.match(/^schools\.by_nature\.(.+)$/i);
  if (schN){
    const nature = schN[1];
    const matches = (SCHOOLS || []).filter(s=> (s.linked_intensities || []).some(n=> String(n).toLowerCase() === String(nature).toLowerCase()));
    if (matches.length){
      matches.forEach(s=> push(`schools.${s.id}`));
      return out;
    }
  }
  const schS = baseTarget.match(/^schools\.by_skill\.(.+)$/i);
  if (schS){
    const skill = schS[1];
    const matches = (SCHOOLS || []).filter(s=> String(s.linked_skill || '').toLowerCase() === String(skill).toLowerCase());
    if (matches.length){
      matches.forEach(s=> push(`schools.${s.id}`));
      return out;
    }
  }
  const md = baseTarget.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
  if (md){
    push(`magic_damage.${md[1].toLowerCase()}.${md[2]}`);
    return out;
  }
  push(baseTarget);
  return out;
}
function resolvedPassiveMods(ab){
  const mods = (ab.passive && ab.passive.modifiers) || [];
  const out = [];
  const { active: activeGroups } = resolveGroupSelections(ab);
  mods.forEach((m, idx)=>{
    const grouped = (m.group || '').trim();
    if (grouped && !activeGroups.has(idx)) return;
    const expanded = expandedTargets(m);
    for (const em of expanded){
      const t = (em.target || em.key || '').trim();
      if (!t) continue;
      if (t.startsWith('choice:')){
        const kind = t.replace('choice:','');
        const picks = Array.from(new Set(abilityChoiceSelections(ab, kind)));
        if (!picks.length) continue;
        picks.forEach(sel=> out.push({ ...em, target: sel }));
        continue;
      }
      out.push(em);
    }
  });
  return out;
}
function recomputePassiveAgg(){
  resetPassiveAgg();
  const passiveAbilities = (ASSIGNED||[]).filter(a=>{
    const t = (a.type||'').toLowerCase();
    return t==='passive' || t==='mixed';
  });
  for (const ab of passiveAbilities){
    const mods = resolvedPassiveMods(ab);
    for (const m of mods){
      const t = (m.target || m.key || '').trim();
      const mode = ((m.mode||'add')+'').toLowerCase();
      const val = modEffectiveValue(m);
      const note = m.note ? ` (${m.note})` : '';
      const origin = `${ab.name}${note}`;
      if (!t) continue;

      const cm = t.match(/^char\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)$/i);
      if (cm){
        const key = cm[1].toLowerCase();
        const agg = ensureAgg(PASSIVE.char, key);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }

      const sm = t.match(/^skills\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)\.(.+)$/i);
      if (sm){
        const ckey = sm[1].toLowerCase();
        const skName = sm[2];
        const k = `${ckey}|${skName}`;
        const agg = ensureAgg(PASSIVE.skill, k);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }

      const im = t.match(/^intensities\.(.+)$/i);
      if (im){
        const skName = im[1];
        const k = `magic|${skName}`;
        const agg = ensureAgg(PASSIVE.skill, k);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }

      const sch = t.match(/^schools\.(.+)$/i);
      if (sch){
        const key = sch[1].toLowerCase();
        const agg = ensureAgg(PASSIVE.school, key);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }
      const schNat = t.match(/^schools\.by_nature\.(.+)$/i);
      if (schNat){
        const nature = schNat[1];
        const matches = (SCHOOLS || []).filter(s=> (s.linked_intensities || []).some(n=> String(n).toLowerCase() === String(nature).toLowerCase()));
        matches.forEach(s=>{
          const key = String(s.id || '').toLowerCase();
          const agg = ensureAgg(PASSIVE.school, key);
          (agg[mode]||agg.add).push({v:val, origin});
          agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        });
        continue;
      }
      const schSkill = t.match(/^schools\.by_skill\.(.+)$/i);
      if (schSkill){
        const skillName = schSkill[1];
        const matches = (SCHOOLS || []).filter(s=> String(s.linked_skill || '').toLowerCase() === String(skillName).toLowerCase());
        matches.forEach(s=>{
          const key = String(s.id || '').toLowerCase();
          const agg = ensureAgg(PASSIVE.school, key);
          (agg[mode]||agg.add).push({v:val, origin});
          agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        });
        continue;
      }

      const md = t.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
      if (md){
        const kind = md[1].toLowerCase();
        const nature = md[2].toLowerCase();
        const bucket = PASSIVE.magic_damage[kind] || {};
        PASSIVE.magic_damage[kind] = bucket;
        const agg = ensureAgg(bucket, nature);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }
    }
  }
  for (const m of getEquippedInventoryModifiers()){
    const t = (m.target||'').trim();
    const mode = (m.mode||'add').toLowerCase();
    const val = modEffectiveValue(m);
    const origin = m.origin || 'Inventory';
    if (!t) continue;
    const cm = t.match(/^char\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)$/i);
    if (cm){
      const key = cm[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.char, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sm = t.match(/^skills\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)\.(.+)$/i);
    if (sm){
      const ckey = sm[1].toLowerCase();
      const skName = sm[2];
      const k = `${ckey}|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const im = t.match(/^intensities\.(.+)$/i);
    if (im){
      const skName = im[1];
      const k = `magic|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sch = t.match(/^schools\.(.+)$/i);
    if (sch){
      const key = sch[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.school, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
  }
  const { mods: subMods } = getSublimationEffects();
  for (const m of subMods){
    const t = (m.target||'').trim();
    const mode = (m.mode||'add').toLowerCase();
    const val = modEffectiveValue(m);
    const origin = m.origin || 'Sublimation';
    if (!t) continue;
    const cm = t.match(/^char\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)$/i);
    if (cm){
      const key = cm[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.char, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sm = t.match(/^skills\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)\.(.+)$/i);
    if (sm){
      const ckey = sm[1].toLowerCase();
      const skName = sm[2];
      const k = `${ckey}|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const im = t.match(/^intensities\.(.+)$/i);
    if (im){
      const skName = im[1];
      const k = `magic|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sch = t.match(/^schools\.(.+)$/i);
    if (sch){
      const key = sch[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.school, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const schNat = t.match(/^schools\.by_nature\.(.+)$/i);
    if (schNat){
      const nature = schNat[1];
      const matches = (SCHOOLS || []).filter(s=> (s.linked_intensities || []).some(n=> String(n).toLowerCase() === String(nature).toLowerCase()));
      matches.forEach(s=>{
        const key = String(s.id || '').toLowerCase();
        const agg = ensureAgg(PASSIVE.school, key);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      });
      continue;
    }
    const schSkill = t.match(/^schools\.by_skill\.(.+)$/i);
    if (schSkill){
      const skillName = schSkill[1];
      const matches = (SCHOOLS || []).filter(s=> String(s.linked_skill || '').toLowerCase() === String(skillName).toLowerCase());
      matches.forEach(s=>{
        const key = String(s.id || '').toLowerCase();
        const agg = ensureAgg(PASSIVE.school, key);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      });
      continue;
    }
    const md = t.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
    if (md){
      const kind = md[1].toLowerCase();
      const nature = md[2].toLowerCase();
      const bucket = PASSIVE.magic_damage[kind] || {};
      PASSIVE.magic_damage[kind] = bucket;
      const agg = ensureAgg(bucket, nature);
      (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }
    }
  }
  for (const m of getSpellEffectModifiers()){
    const t = (m.target||'').trim();
    const mode = (m.mode||'add').toLowerCase();
    const val = modEffectiveValue(m);
    const origin = m.origin || 'Spell';
    if (!t) continue;
    const cm = t.match(/^char\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)$/i);
    if (cm){
      const key = cm[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.char, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sm = t.match(/^skills\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)\.(.+)$/i);
    if (sm){
      const ckey = sm[1].toLowerCase();
      const skName = sm[2];
      const k = `${ckey}|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const im = t.match(/^intensities\.(.+)$/i);
    if (im){
      const skName = im[1];
      const agg = ensureAgg(PASSIVE.intensity, skName);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sch = t.match(/^schools\.(.+)$/i);
    if (sch){
      const skName = sch[1];
      const agg = ensureAgg(PASSIVE.school, skName);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const md = t.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
    if (md){
      const kind = md[1].toLowerCase();
      const nature = md[2].toLowerCase();
      const bucket = PASSIVE.magic_damage[kind] || {};
      PASSIVE.magic_damage[kind] = bucket;
      const agg = ensureAgg(bucket, nature);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
  }
function applyOps(base, agg){
  if (!agg) return { value: base, notes: [`Base = ${base}`] };
  const notes = [`Base = ${base}`];
  let v = base;
  // set -> mul -> add
  for (const x of (agg.set||[])){ v = x.v; notes.push(`Set to ${x.v} -> ${x.origin}`); }
  for (const x of (agg.mul||[])){ const before = v; v = Math.round(v * x.v); notes.push(`*${x.v} (from ${before}) -> ${x.origin}`); }
  for (const x of (agg.add||[])){ v = v + x.v; notes.push(`${x.v>=0?'+':''}${x.v} -> ${x.origin}`); }
  return { value: v, notes };
}

/* ---------- Rendering: Statistics & Skills ---------- */
function skillId(key, skill, suffix){
  const slug = (skill || '').toLowerCase().replace(/[^a-z0-9]+/g, '_');
  return `${key}__${slug}__${suffix}`;
}

function setNotesList(id, notes){
  let el = document.getElementById(id);
  if (!el){
    el = document.createElement('ul');
    el.className = 'mod-list';
    el.id = id;
    el.style.display = 'none';
  }else{
    el.innerHTML = '';
  }
  (notes || []).forEach(n=>{
    const li = document.createElement('li');
    li.textContent = n;
    el.appendChild(li);
  });
  return el;
}

function toggleModList(id){
  const el = document.getElementById(id);
  if (!el) return;
  el.style.display = (el.style.display === 'none' || !el.style.display) ? '' : 'none';
}

document.addEventListener('click', (e)=>{
  const t = e.target.closest('.mod-toggle');
  if (!t) return;
  const id = t.getAttribute('data-target');
  if (id) toggleModList(id);
});

function getEquippedInventoryModifiers(){
  if (!LINKED_INV) return [];
  const items = LINKED_INV.items || [];
  const mods = [];
  for (const it of items){
    if (it.equipped === false) continue;
    const itemKey = itemChoiceKey(it);
    const allMods = [
      ...(it.modifiers || []).map(m=>({ ...m, __origin:'Item' })),
      ...((it.upgrades||[]).flatMap(u=> (u.modifiers||[]).map(m=>({ ...m, __origin:`Upgrade: ${u.name || u.id || 'Upgrade'}` }))) || [])
    ];
    for (const m of allMods){
      const originPrefix = m.__origin || 'Item';
      const note = m.note ? ` (${m.note})` : '';
      const origin = `[${originPrefix}] ${it.name || 'Item'}${note}`;
      const expanded = expandedTargets(m);
      expanded.forEach(em=>{
        const target = (em.target || em.key || '').trim();
        if (!target) return;
        const mode = (em.mode || m.mode || 'add').toLowerCase();
        const baseValue = numOr(em.value ?? m.value, 0);
        const quality_step = numOr(em.quality_step ?? m.quality_step ?? qualityStepFromNote(em.note || m.note), 0);
        const qualityDelta = quality_step ? qualityStepDelta(it.quality) : 0;
        const value = baseValue + (quality_step * qualityDelta);
        const level_step = Number(em.level_step ?? m.level_step ?? 0);
        const level_increment = Number(em.level_increment ?? m.level_increment ?? 1);
        if (target.startsWith('choice:')){
          const kind = target.replace('choice:','');
          const picks = normalizeChoiceEntry(itemChoiceState(itemKey, kind)).picks;
          if (!picks.length) return;
          picks.forEach(sel=> mods.push({ target: sel, mode, value, level_step, level_increment, origin }));
          return;
        }
        mods.push({ target, mode, value, level_step, level_increment, origin });
      });
    }
  }
  return mods;
}

function getSpellEffectModifiers(){
  const mods = [];
  const meta = SPELLLIST_META.spell_meta || {};
  const allowedStatus = new Set(["known","learnt",""]);
  if (!Object.keys(EFFECTS_BY_ID).length && !EFFECTS_PROMISE){
    ensureEffectsLoaded().catch(()=>{});
  }
  for (const sp of SPELLLIST_SPELLS){
    const status = (meta[sp.id]?.status || "known");
    if (!allowedStatus.has(status)) continue;
    const effects = sp.effects || [];
    effects.forEach(eid=>{
      const key = String(eid||'').toLowerCase();
      const eff = EFFECTS_BY_ID[key] || {};
      const mlist = Array.isArray(eff.modifiers) ? eff.modifiers : [];
      mlist.forEach(m=>{
        const origin = `Spell: ${sp.name || sp.id}${eff.name ? ` / ${eff.name}` : ""}`;
        expandedTargets(m).forEach(em=>{
          const target = (em.target || em.key || '').trim();
          if (!target) return;
          const merged = { ...m, ...em };
          const mode = (merged.mode || 'add').toLowerCase();
          const value = modEffectiveValue(merged);
          const level_step = Number(merged.level_step || 0);
          const level_increment = Number(merged.level_increment ?? 1);
          mods.push({ target, mode, value, level_step, level_increment, origin });
        });
      });
    });
  }
  return mods;
}

function getSublimationEffects(){
  const mods = [];
  const hidden = { weaponNeutral:0, magicBonus:0, magicNature:'', conditionDC:0 };
  for (const s of SUBLIMATIONS || []){
    const t = (s.type||'').toLowerCase();
    const tier = Math.min(4, Math.max(1, Number(s.tier)||1));
    const origin = `Sublimation - ${t.charAt(0).toUpperCase()+t.slice(1)}`;
    if (t === 'lethality'){
      hidden.weaponNeutral += 2 * tier;
      continue;
    }
    if (t === 'blessing'){
      hidden.magicBonus += 2 * tier;
      hidden.magicNature = s.nature || hidden.magicNature || '';
      continue;
    }
    if (t === 'excellence'){
      if (!s.skill) continue;
      const [ckey, sk] = s.skill.split('|');
      if (!ckey || !sk) continue;
      mods.push({ target:`skills.${ckey}.${sk}`, mode:'add', value:tier, origin:`${origin} (${sk})` });
      continue;
    }
    if (t === 'defense'){
      mods.push({ target:'derived.hp', mode:'add', value:12 * tier, origin });
      continue;
    }
    if (t === 'speed'){
      mods.push({ target:'derived.mo', mode:'add', value: tier, origin });
      continue;
    }
    if (t === 'devastation'){
      hidden.conditionDC += tier;
      continue;
    }
    if (t === 'clarity'){
      mods.push({ target:'derived.en', mode:'add', value: 2 * tier, origin });
      continue;
    }
    if (t === 'endurance'){
      mods.push({ target:'derived.fo', mode:'add', value: 2 * tier, origin });
      continue;
    }
  }
  SUB_HIDDEN = hidden;
  return { mods, hidden };
}

async function loadInventoriesList(){
  invStatusEl.textContent = 'Loading inventories...';
  try{
    const res = await api('/inventories');
    INVENTORIES = res.inventories || [];
    invSelectEl.innerHTML = '<option value="">-- Select inventory --</option>';
    INVENTORIES.forEach(inv=>{
      const opt = document.createElement('option');
      opt.value = inv.id;
      opt.textContent = inv.name || inv.id;
      if (inv.id === SELECTED_INV_ID) opt.selected = true;
      invSelectEl.appendChild(opt);
    });
    invStatusEl.textContent = '';
  }catch(e){
    invStatusEl.textContent = 'Load failed: ' + e.message;
  }
}

async function createInventoryAndLink(){
  const charName = nameEl.value?.trim() || 'Character';
  const invName = `${charName} Inventory`;
  try{
    invStatusEl.textContent = 'Creating inventory...';
    const res = await api('/inventories', {
      method:'POST',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ name: invName })
    });
    const inv = res.inventory || res;
    SELECTED_INV_ID = inv.id;
    CHAR.inventory_id = SELECTED_INV_ID;
    await loadInventoriesList();
    await loadInventoryById(SELECTED_INV_ID);
    invStatusEl.textContent = 'Created and linked.';
  }catch(e){
    invStatusEl.textContent = 'Create failed: ' + e.message;
    alert(e.message);
  }
}

async function duplicateAndLinkInventory(){
  if (!SELECTED_INV_ID){ invStatusEl.textContent = 'Load an inventory first to duplicate.'; return; }
  const charName = nameEl.value?.trim() || 'Character';
  const invName = `${charName} Inventory`;
  try{
    invStatusEl.textContent = 'Duplicating inventory...';
    const res = await api(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/duplicate`, {
      method:'POST',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ name: invName })
    });
    const inv = res.inventory || res;
    SELECTED_INV_ID = inv.id;
    CHAR.inventory_id = SELECTED_INV_ID;
    await loadInventoriesList();
    await loadInventoryById(SELECTED_INV_ID);
    invStatusEl.textContent = 'Duplicated and linked.';
  }catch(e){
    invStatusEl.textContent = 'Duplicate failed: ' + e.message;
    alert(e.message);
  }
}

function renderInventoryUI(){
  if (!LINKED_INV){
    invManagerEl.style.display = 'none';
    if (invOpenManagerBtn) invOpenManagerBtn.style.display = 'none';
    invFundOpenBtn?.setAttribute('disabled','disabled');
    invCatalogOpenBtn?.setAttribute('disabled','disabled');
    return;
  }
  pruneItemChoices();
  invManagerEl.style.display = '';
  if (invOpenManagerBtn){
    invOpenManagerBtn.style.display = '';
    invOpenManagerBtn.href = `inventory_view.html?inv=${encodeURIComponent(LINKED_INV.id||'')}`;
  }
  invFundOpenBtn?.removeAttribute('disabled');
  invCatalogOpenBtn?.removeAttribute('disabled');
  invTitleEl.textContent = LINKED_INV.name || 'Inventory';
  // Money + currency selects
  const cur = LINKED_INV.currencies || {};
  invMoneyEl.innerHTML = Object.keys(cur).length
    ? Object.entries(cur).map(([k,v])=>`<span class="pill">${k}: ${v}</span>`).join(' ')
    : '<span class="muted">No funds</span>';
  invFundCurEl.innerHTML = '';
  invGlobalCurEl.innerHTML = '';
  Object.keys(cur).concat(["Jelly"]).filter((v,i,arr)=>arr.indexOf(v)===i).forEach(k=>{
    const o1=document.createElement('option'); o1.value=k; o1.textContent=k; invFundCurEl.appendChild(o1);
    const o2=document.createElement('option'); o2.value=k; o2.textContent=k; invGlobalCurEl.appendChild(o2);
  });
  invEncTotalEl.textContent = Number(LINKED_INV.enc_total||0).toFixed(1);

  // Containers & items
  const containers = LINKED_INV.containers || [];
  const items = LINKED_INV.items || [];
  invContainersEl.innerHTML = '';
  if (!containers.length){
    invContainersEl.innerHTML = '<div class="muted">No containers yet.</div>';
  }else{
    containers.forEach(c=>{
      const div = document.createElement('div');
      div.className = 'container-card';
      div.innerHTML = `
        <div class="container-head">
          <strong>${c.name || 'Container'}</strong>
          <span class="muted">Enc: ${Number(c.enc_total||0).toFixed(1)} ${c.include===false? '(excluded)':''}</span>
          <label class="row muted" style="gap:6px; align-items:center;">
            <input type="checkbox" data-cont="${c.id}" ${c.include===false?'':'checked'}> Include
          </label>
          ${c.built_in ? '' : `<button class="btn small" data-del="${c.id}">Delete</button>`}
        </div>
        <div class="items"></div>
      `;
      const list = div.querySelector('.items');
      const its = items.filter(it=> ((it.equipped!==false) ? SELF_CONTAINER_ID : (it.container_id||'')) === c.id);
      if (!its.length){
        list.innerHTML = '<div class="muted">No items.</div>';
      }else{
        its.forEach(it=>{
          const row = document.createElement('div');
          row.className = 'item-row';
          row.title = buildModifierSummary(it) || "";
          const hasChoice = itemHasChoice(it);
          row.innerHTML = `
            <div class="grow">
              <div><strong>${invEscapeHtml(it.alt_name || it.name || 'Item')}</strong> <span class="muted">x${it.quantity||1}</span></div>
              <div class="muted">${it.kind||''}${it.variant?` - ${invEscapeHtml(it.variant)}`:''}</div>
            </div>
            <div class="pill">${Number(it.enc||0).toFixed(1)} enc</div>
            <button class="btn small toggle">${it.consumable ? 'Use' : (it.equipped!==false?'Unequip':'Equip')}</button>
            ${hasChoice ? '<button class="btn small choices">Choices</button>' : ''}
            <button class="btn small open">Open</button>
          `;
          row.querySelector('.toggle').addEventListener('click', ()=> it.consumable ? useItemInline(it) : toggleEquipInline(it));
          if (hasChoice) row.querySelector('.choices')?.addEventListener('click', ()=> openItemChoiceModal(it));
          row.querySelector('.open').addEventListener('click', ()=> openInvItemModal(it));
          list.appendChild(row);
        });
      }
      invContainersEl.appendChild(div);
    });
  }
  // Wire include toggles
  invContainersEl.querySelectorAll('input[data-cont]').forEach(cb=>{
    cb.addEventListener('change', ()=> toggleContainerInclude(cb.getAttribute('data-cont'), cb.checked));
  });
  invContainersEl.querySelectorAll('button[data-del]').forEach(btn=>{
    btn.addEventListener('click', ()=> deleteContainer(btn.getAttribute('data-del')));
  });

  // Global container select for purchases/moves
  invGlobalContEl.innerHTML = '';
  containers.forEach(c=>{
    const o=document.createElement('option'); o.value=c.id; o.textContent=c.name||c.id; invGlobalContEl.appendChild(o);
  });
  const firstNonSelf = Array.from(invGlobalContEl.options).map(o=>o.value).find(v=>v !== SELF_CONTAINER_ID);
  if (firstNonSelf) invGlobalContEl.value = firstNonSelf;

  // Transactions
  const txs = (LINKED_INV.transactions || []).slice(-12).reverse();
  invTxEl.innerHTML = txs.length ? txs.map(t=>`<div class="row"><span class="pill">${t.currency||''} ${t.amount||0}</span><span class="muted">${invEscapeHtml(t.note||'')}</span><span class="muted">${t.ts||''}</span></div>`).join('') : '<div class="muted">No transactions.</div>';
}

async function loadInventoryById(id){
  if (!id){ LINKED_INV=null; SELECTED_INV_ID=''; CHAR.inventory_id=''; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave(); return; }
  invStatusEl.textContent = 'Loading inventory...';
  try{
    const res = await api('/inventories/' + encodeURIComponent(id));
    if (res.inventory){
      LINKED_INV = res.inventory;
      SELECTED_INV_ID = LINKED_INV.id || id;
      CHAR.inventory_id = SELECTED_INV_ID;
      renderInventoryUI();
      recomputePassiveAgg();
      renderStatistics();
      updateDerived();
      invStatusEl.textContent = 'Inventory loaded';
      queueSave();
    }else{
      throw new Error('Not found');
    }
  }catch(e){
    invStatusEl.textContent = 'Load failed: ' + e.message;
  }
}

function invEscapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}
function escapeHtml(s){ return invEscapeHtml(s); }
function buildModifierSummary(it){
  const out = [];
  const mods = Array.isArray(it?.modifiers) ? it.modifiers : [];
  mods.forEach(m=>{
    const mode = m.mode || "add";
    const val = m.value ?? "";
    const tgt = m.target || "";
    out.push(`${mode} ${val}${tgt ? " -> " + tgt : ""}`);
  });
  const ups = Array.isArray(it?.upgrades) ? it.upgrades : [];
  ups.forEach(u=>{
    const pool = Array.isArray(u.holder_modifiers) && u.holder_modifiers.length
      ? u.holder_modifiers
      : (Array.isArray(u.modifiers) ? u.modifiers : []);
    pool.forEach(m=>{
      const mode = m.mode || "add";
      const val = m.value ?? "";
      const tgt = m.target || "";
      out.push(`${mode} ${val}${tgt ? " -> " + tgt : ""}`);
    });
  });
  return out.join(", ");
}
function invToggleModal(modal, backdrop, open){
  if (!modal || !backdrop) return;
  if (open){
    modal.classList.remove('hidden');
    modal.classList.add('open');
    backdrop.classList.remove('hidden');
    backdrop.classList.add('open');
  }else{
    modal.classList.add('hidden');
    modal.classList.remove('open');
    backdrop.classList.remove('open');
    backdrop.classList.add('hidden');
  }
}

function itemChoiceMods(it){
  const mods = [];
  (it.modifiers || []).forEach(m=>{
    if (String(m.target||'').startsWith('choice:')) mods.push({ ...m, __source:'Item' });
  });
  (it.upgrades || []).forEach(u=>{
    (u.modifiers || []).forEach(m=>{
      if (String(m.target||'').startsWith('choice:')) mods.push({ ...m, __source:`Upgrade: ${u.name || u.id || 'Upgrade'}` });
    });
  });
  return mods;
}
function itemHasChoice(it){
  return itemChoiceMods(it).length > 0;
}
function itemChoiceKey(it){
  const key = String(it?.item_id || it?.id || '').trim();
  if (key) return key;
  const name = String(it?.name || '').trim();
  return name || '';
}
function pruneItemChoices(){
  if (!LINKED_INV) return;
  const ids = new Set((LINKED_INV.items || []).map(it=> itemChoiceKey(it)).filter(Boolean));
  Object.keys(ITEM_CHOICES).forEach(id=>{ if (!ids.has(String(id))) delete ITEM_CHOICES[id]; });
}

async function invAddContainer(){
  const name = (invNewContNameEl.value || "Container").trim();
  if (!SELECTED_INV_ID) return;
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/containers`, {
    method: "POST",
    headers: { "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ name })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Create failed"); return; }
  invNewContNameEl.value = "";
  LINKED_INV = j.inventory;
  renderInventoryUI();
  recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function invAddFunds(){
  const currency = invFundCurEl.value || "Jelly";
  const amountRaw = parseInt(invFundAmtEl.value || "0", 10);
  const note = (invFundNoteEl.value || (amountRaw >= 0 ? "Top up" : "Withdrawal")).trim();
  if (!amountRaw){ invFundStatus.textContent = "Enter a non-zero amount."; return; }
  if (!SELECTED_INV_ID){ invFundStatus.textContent = "Link an inventory first."; return; }
  invFundStatus.textContent = "Saving transaction...";
  try{
    const path = `/inventories/${encodeURIComponent(SELECTED_INV_ID)}/deposit`;
    const r = await fetch(path, {
      method:"POST",
      headers:{ "Content-Type":"application/json", ...authHeaders() },
      body: JSON.stringify({ currency, amount: amountRaw, note })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success") throw new Error(j.message || "Update failed");
    invFundAmtEl.value = ""; invFundNoteEl.value = "";
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
    invFundStatus.textContent = "Saved.";
    invToggleModal(invFundModal, invFundBackdrop, false);
  }catch(e){
    invFundStatus.textContent = "Failed: " + e.message;
  }
}

function invGetRowCategory(r){
  if (r.kind === "weapon" || r.__kind === "weapon") return "weapon";
  if (r.kind === "equipment" || r.__kind === "equipment") return r.category ? `equipment:${r.category}` : "equipment";
  if (r.kind === "tool" || r.__kind === "tool") return "tool";
  return "object";
}

async function invFetchCatalog(kind, q, limit){
  const url = kind === "weapon" ? "/catalog/weapons"
            : kind === "equipment" ? "/catalog/equipment"
            : kind === "tool" ? "/catalog/tools"
            : "/catalog/objects";
  const params = new URLSearchParams();
  if (q) params.set("q", q);
  if (limit) params.set("limit", limit);
  const r = await fetch(`${url}?${params.toString()}`, { headers: authHeaders() });
  const j = await r.json();
  const key = Object.keys(j).find(k=>Array.isArray(j[k]));
  const rows = key ? j[key] : [];
  return rows.map(x=>({ ...x, __kind: kind }));
}

function invBuildCategoryOptions(rows){
  const cats = ["__all", ...new Set(rows.map(invGetRowCategory))];
  invCatEl.innerHTML = '';
  cats.forEach(c=>{
    const o=document.createElement('option'); o.value=c; o.textContent = c==="__all" ? "All" : c; invCatEl.appendChild(o);
  });
}

function invRenderResults(){
    const list = invResultsEl;
    list.innerHTML = '';
    if (!INV_FILTERED.length){
      list.innerHTML = '<div class="muted">No results.</div>';
      return;
    }
    const container = invGlobalContEl.value;
    const currency  = invGlobalCurEl.value || "Jelly";
  INV_FILTERED.forEach(r=>{
    const line = document.createElement("div");
    line.className = "row";
    line.style.borderBottom = "1px solid #222";
    line.style.padding = "6px 0";
      const cat = invGetRowCategory(r);
      const price = (r.price != null) ? `Price: ${r.price}` : "";
      const enc = (r.enc != null) ? `Enc: ${Number(r.enc||0).toFixed(1)}` : "";
      line.innerHTML = `
        <div style="flex:1;min-width:260px;">
          <div><b>${invEscapeHtml(r.name || r.title || "Item")}</b></div>
          <div class="muted">${invEscapeHtml(cat)} ${price ? " - "+price : ""} ${enc ? " - "+enc : ""}</div>
        </div>
        <input type="number" min="1" value="1" style="width:90px" class="qty">
        <button class="btn small buy">Add</button>
      `;
      line.querySelector(".buy").addEventListener("click", async ()=>{
        const qty = Math.max(1, parseInt(line.querySelector(".qty").value||"1", 10));
      const choice = await invPromptPricingChoice(r);
      if (!choice) return;
      await invBuyItem(r.__kind || "object", r.id, qty, container, currency, choice);
    });
    list.appendChild(line);
  });
}

function invParseCustomPriceInput(inputStr){
  if (inputStr == null) return null;
  const raw = String(inputStr).trim();
  if (!raw) return null;
  const percentMark = raw.startsWith('%') || raw.endsWith('%');
  const numeric = raw.replace('%','');
  const num = Number(numeric);
  if (!Number.isFinite(num) || num < 0) return null;
  if (percentMark){
    return { priceModifier: num / 100 };
  }
  return { customPrice: num };
}

async function invPromptPricingChoice(row){
  return await new Promise(resolve=>{
    const basePrice = row?.price != null ? Number(row.price) : 0;
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:4000; display:grid; place-items:center; padding:12px;';
    const card = document.createElement('div');
    card.style.cssText = 'background:#11121b; border:1px solid #2a2a3a; border-radius:12px; padding:14px; width:min(420px, 96vw); box-shadow:0 12px 40px rgba(0,0,0,0.45); color:#f3f3f5; font-family:inherit;';
    card.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:10px;">
        <div>
          <div style="font-weight:700;">${invEscapeHtml(row?.name || row?.title || 'Item')}</div>
          <div class="muted" style="font-size:0.9rem;">Base price: ${basePrice || 0}</div>
        </div>
        <button id="price-close" class="btn small" style="background:#222635; border-color:#2f3548;">?</button>
      </div>
      <div style="display:grid; gap:8px;">
        <label style="display:flex; gap:6px; align-items:center;">
          <input type="radio" name="price-mode" value="market" checked> <span>Buy at market price</span>
        </label>
        <label style="display:flex; gap:6px; align-items:center;">
          <input type="radio" name="price-mode" value="custom"> <span>Custom</span>
        </label>
        <div id="price-custom" style="display:grid; gap:6px; grid-template-columns: 1fr 1fr;">
          <div style="display:flex; gap:6px; align-items:center;">
            <span class="muted" style="min-width:80px;">% modifier</span>
            <input id="price-mod-input" type="number" step="1" min="0" style="flex:1; padding:8px; border-radius:8px; border:1px solid #2d3042; background:#181b2a; color:#f3f3f5;" value="${Math.round(((parseFloat(invPriceModEl?.value || '1') || 1) * 100))}">
          </div>
          <div style="display:flex; gap:6px; align-items:center;">
            <span class="muted" style="min-width:80px;">Exact price</span>
            <input id="price-exact-input" type="number" step="1" min="0" style="flex:1; padding:8px; border-radius:8px; border:1px solid #2d3042; background:#181b2a; color:#f3f3f5;" placeholder="${basePrice || 0}">
          </div>
          <div class="muted" style="grid-column:1/-1; font-size:0.9rem;">Tip: fill either % modifier or exact price. Leave both blank to cancel.</div>
        </div>
        <label style="display:flex; gap:6px; align-items:center;">
          <input type="radio" name="price-mode" value="take"> <span>Take (price 0)</span>
        </label>
        <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:6px;">
          <button id="price-cancel" class="btn small btn-secondary">Cancel</button>
          <button id="price-apply" class="btn small">Apply</button>
        </div>
      </div>
    `;
    overlay.appendChild(card);
    document.body.appendChild(overlay);

    const cleanup = (val)=>{ overlay.remove(); resolve(val); };
    card.querySelector('#price-close').addEventListener('click', ()=>cleanup(null));
    card.querySelector('#price-cancel').addEventListener('click', ()=>cleanup(null));
    overlay.addEventListener('click', (e)=>{ if (e.target === overlay) cleanup(null); });

    const applyBtn = card.querySelector('#price-apply');
    applyBtn.addEventListener('click', ()=>{
      const mode = card.querySelector('input[name="price-mode"]:checked')?.value || 'market';
      if (mode === 'take'){ cleanup({ pricingMode:'take', customPrice:0 }); return; }
      if (mode === 'market'){ cleanup({ pricingMode:'market' }); return; }
      const pctRaw = card.querySelector('#price-mod-input').value;
      const priceRaw = card.querySelector('#price-exact-input').value;
      const parsedPct = pctRaw ? invParseCustomPriceInput(`%${pctRaw}`) : null;
      const parsedPrice = priceRaw ? invParseCustomPriceInput(priceRaw) : null;
      const choice = parsedPrice || parsedPct;
      if (!choice){
        alert('Enter a % modifier or an exact price for custom mode.');
        return;
      }
      cleanup({ pricingMode:'custom', ...choice });
    });
  });
}


  async function invDoSearch(){
    const q = (invQEl.value || "").trim();
    const kind = invKindEl.value;
    const limit = parseInt(invLimitEl.value || "50", 10);
    INV_LAST_RESULTS = await invFetchCatalog(kind, q, limit);
  INV_FILTERED = INV_LAST_RESULTS.slice();
  invBuildCategoryOptions(INV_LAST_RESULTS);
  invRenderResults();
}

function invClearSearch(){
  invQEl.value = "";
  INV_LAST_RESULTS = [];
  INV_FILTERED = [];
  invBuildCategoryOptions([]);
  invRenderResults();
}

async function invBuyItem(kind, ref_id, quantity, container_id, currency, opts = {}){
    const equipFlag = invEquippedFlagEl.value === "1";
    if (!equipFlag && container_id === SELF_CONTAINER_ID){
      const firstNonSelf = Array.from(invGlobalContEl.options || []).map(o=>o.value).find(v=>v !== SELF_CONTAINER_ID);
      container_id = firstNonSelf || "";
    }
    const pricingMode = opts.pricingMode || 'market';
    const priceModifier = (opts.priceModifier != null) ? opts.priceModifier : (parseFloat(invPriceModEl?.value || "1") || 1);
    const customPrice = opts.customPrice;
    const payload = { kind, ref_id, quantity, container_id, currency, equipped: equipFlag, pricing_mode: pricingMode };
    if (pricingMode === 'custom'){
      if (priceModifier != null) payload.price_modifier = priceModifier;
      if (customPrice != null) payload.custom_price = customPrice;
    } else if (pricingMode === 'take') {
      payload.custom_price = 0;
    }
    const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/purchase`, {
      method: "POST",
      headers: { "Content-Type":"application/json", ...authHeaders() },
      body: JSON.stringify(payload)
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success") { alert(j.message || "Purchase failed"); return; }
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
    invToggleModal(invCatalogModal, invCatalogBackdrop, false);
  }

async function saveInvAltName(item_id, alt_name){
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(item_id)}`, {
    method:"PATCH",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ alt_name })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ throw new Error(j.message || "Save failed"); }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
  return j.inventory;
}

  async function upgradeQuality(item_id, to){
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(item_id)}/upgrade_quality`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ to })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ throw new Error(j.message || "Upgrade failed"); }
  return j.inventory;
}

async function installUpgrade(item_id, upgrade_id, targetOverride=""){
  const meta = (window.UPGRADE_META || {})[upgrade_id] || null;
  let target = targetOverride || "";
  if (!target && meta && Array.isArray(meta.targets) && meta.targets.length){
    const counts = {};
    const current = (LINKED_INV?.items || []).find(i=>i.item_id===item_id);
    const existing = current?.upgrades || [];
    existing.forEach(u=>{ if(u.target){ counts[u.target]=(counts[u.target]||0)+1; } });
    const options = meta.targets.map(t=>`${t} (${counts[t]||0}/2)`).join(", ");
    const choice = prompt(`Select target for ${meta.name || "upgrade"} [${options}]`, meta.targets[0]);
    if (!choice) return null;
    if (!meta.targets.includes(choice)){
      alert("Invalid target."); return null;
    }
    if ((counts[choice]||0) >= 2){
      alert("Target already has two upgrades."); return null;
    }
    target = choice;
  }
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(item_id)}/install_upgrade`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ upgrade_id, target })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ throw new Error(j.message || "Install failed"); }
  return j.inventory;
}

async function removeUpgrade(item_id, upgrade_id, target=""){
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(item_id)}/remove_upgrade`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ upgrade_id, target })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ throw new Error(j.message || "Remove failed"); }
  return j.inventory;
}

async function fetchUpgrades(kind, slot){
  const qs = [];
  if (kind) qs.push(`kind=${encodeURIComponent(kind)}`);
  if (slot) qs.push(`slot=${encodeURIComponent(slot)}`);
  const url = `/upgrades${qs.length ? '?'+qs.join('&') : ''}`;
  const r = await fetch(url, { headers: { ...authHeaders() } });
  const j = await r.json();
  if (j.status !== "success") throw new Error(j.message || "Load upgrades failed");
  const ups = j.upgrades || [];
  ups.forEach(u=>{ UPGRADE_META[u.id] = u; });
  return ups;
}

async function loadUpgradeOptions(labelEl, selectEl, it){
  if (!labelEl || !selectEl) return;
  labelEl.textContent = "Install upgrade (loading...)";
  selectEl.innerHTML = "";
  try{
    const slot = it.equipment_slot || it.slot || "";
    const ups = await fetchUpgrades(it.kind, slot);
    if (!ups.length){
      labelEl.textContent = "Install upgrade (none available)";
      const o = document.createElement("option"); o.textContent = "-- none --"; selectEl.appendChild(o);
      return;
    }
    labelEl.textContent = "Install upgrade";
    selectEl.innerHTML = '<option value=\"\">-- select upgrade --</option>';
    ups.forEach(u=>{
      const o = document.createElement("option");
      o.value = u.id;
      const ttxt = (u.targets && u.targets.length) ? ` - target: ${u.targets.join("/")}` : "";
      const excl = u.exclusive_group ? ` - excl:${u.exclusive_group}` : "";
      o.textContent = `${u.name}${u.slot ? ` (${u.slot})` : ""}${ttxt}${excl}`;
      selectEl.appendChild(o);
    });
  }catch(e){
    labelEl.textContent = "Install upgrade (load failed)";
    const o = document.createElement("option");
    o.textContent = "Error loading upgrades";
    selectEl.appendChild(o);
  }
}

async function toggleEquipInline(it){
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(it.item_id)}`, {
    method:"PATCH",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ equipped: it.equipped === false })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Update failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

function alchemyTierFromPrice(price){
  const ladder = [ [10000,6],[2000,5],[1000,4],[200,3],[100,2],[50,1] ];
  let tier = 1;
  const p = Number(price||0);
  for (const [min, t] of ladder){
    if (p >= min){ tier = t; break; }
  }
  return tier;
}

async function sellItemInline(it, price){
  const currency = invGlobalCurEl?.value || "Jelly";
  const payload = { price, currency };
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(it.item_id)}/sell`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify(payload)
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Sell failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function disposeItemInline(it){
  const currency = invGlobalCurEl?.value || "Jelly";
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(it.item_id)}/dispose`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Dispose failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function useItemInline(it){
  const currency = invGlobalCurEl?.value || "Jelly";
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(it.item_id)}/use`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Use failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function refillAlchemyInline(it){
  const currency = invGlobalCurEl?.value || "Jelly";
  const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(it.item_id)}/refill_alchemy`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Refill failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function toggleContainerInclude(containerId, include){
  if (!SELECTED_INV_ID || !containerId) return;
  try{
    const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/containers/${encodeURIComponent(containerId)}`, {
      method:"PATCH",
      headers:{ "Content-Type":"application/json", ...authHeaders() },
      body: JSON.stringify({ include })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success") throw new Error(j.message || "Update failed");
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
  }catch(e){
    alert(e.message);
    renderInventoryUI();
  }
}

async function moveItemToContainer(it, containerId){
  if (!SELECTED_INV_ID || !containerId) return;
  if (it.equipped===false && containerId === SELF_CONTAINER_ID){
    alert('Only equipped items can be on Self.');
    return;
  }
  try{
    const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/items/${encodeURIComponent(it.item_id)}`, {
      method:"PATCH",
      headers:{ "Content-Type":"application/json", ...authHeaders() },
      body: JSON.stringify({ container_id: containerId })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success"){ throw new Error(j.message || "Move failed"); }
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
  }catch(e){
    alert(e.message);
  }
}

async function deleteContainer(containerId){
  if (!SELECTED_INV_ID || !containerId) return;
  if (!confirm('Delete this container? Items will be moved to another container.')) return;
  try{
    const r = await fetch(`/inventories/${encodeURIComponent(SELECTED_INV_ID)}/containers/${encodeURIComponent(containerId)}`, {
      method:"DELETE",
      headers:{ ...authHeaders() }
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success"){ throw new Error(j.message || "Delete failed"); }
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
  }catch(e){
    alert(e.message);
  }
}

function openInvItemModal(it){
  const equipped = it.equipped !== false;
  const qty = Number(it.quantity || 1);
  const encUnit = Number(it.enc || 0);
  const encTotal = encUnit * qty;
  const paidUnit = Number(it.paid_unit ?? it.base_price ?? 0) || 0;
  const totalPaid = paidUnit * qty;
  const titleText = it.alt_name ? `${it.alt_name} (${it.name || 'Item'})` : (it.name || 'Item');
  invItemTitle.textContent = titleText;
  invItemBody.innerHTML = "";
  invItemActions.innerHTML = "";
  const hasChoice = itemHasChoice(it);

  const nameRow = document.createElement("div");
  nameRow.className = "row";
  nameRow.style.gap = "6px";
  const nameInput = document.createElement("input");
  nameInput.placeholder = "Display name (sets alt name)";
  nameInput.value = it.alt_name || it.name || "";
  nameInput.style.flex = "1";
  const commitName = debounce(async ()=>{
    try{ await saveInvAltName(it.item_id, nameInput.value || ""); }catch(e){ console.warn(e); }
  }, 500);
  nameInput.addEventListener("input", commitName);
  nameInput.addEventListener("blur", ()=>commitName());
  nameRow.appendChild(nameInput);
  invItemBody.appendChild(nameRow);

  const info = document.createElement("div");
  info.className = "info-grid";
  const totalPrice = Number.isFinite(totalPaid) ? totalPaid : 0;
  const cells = [
    { label: "Type", value: it.kind || "object" },
    { label: "Quality", value: it.quality || "—" },
    { label: "Enc (unit)", value: encUnit.toFixed(1) },
    { label: "Enc (total)", value: encTotal.toFixed(1) },
    { label: "Quantity", value: qty },
    { label: "Total price", value: totalPrice.toFixed(0) }
  ];
  cells.forEach(c=>{
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.innerHTML = `<div class="label">${invEscapeHtml(c.label)}</div><div><strong>${invEscapeHtml(c.value)}</strong></div>`;
    info.appendChild(cell);
  });
  invItemBody.appendChild(info);

  const modLine = buildModifierSummary(it);
  if (modLine){
    const mods = document.createElement("div");
    mods.className = "muted";
    mods.textContent = `Applies: ${modLine}`;
    invItemBody.appendChild(mods);
  }

  if (hasChoice){
    const choiceHint = document.createElement("div");
    choiceHint.className = "muted";
    choiceHint.textContent = "This item has configurable choices.";
    invItemBody.appendChild(choiceHint);
  }

  if (it.kind === "weapon" || it.kind === "equipment"){
    const upSection = document.createElement("div");
    upSection.className = "home-card";
    const capLabel = `${(it.upgrades || []).length} / ${slotsForQuality(it.quality) || 0}`;
    const upHead = document.createElement("div");
    upHead.className = "row";
    upHead.style.alignItems = "center";
    upHead.style.gap = "10px";
    upHead.innerHTML = `<h3 style="margin:0;">Upgrades</h3><span class="pill-soft">${capLabel}</span>`;
    upSection.appendChild(upHead);

    const installRow = document.createElement("div");
    installRow.className = "row";
    installRow.style.gap = "8px";
    const ulabel = document.createElement("label"); ulabel.className = "muted"; ulabel.textContent = "Install upgrade";
    const uselect = document.createElement("select"); uselect.id = "inv-up-select";
    uselect.innerHTML = '<option value="">-- select upgrade --</option>';
    const ubtn = document.createElement("button"); ubtn.className = "btn small"; ubtn.textContent = "Install";
    installRow.appendChild(ulabel); installRow.appendChild(uselect); installRow.appendChild(ubtn);
    upSection.appendChild(installRow);

    loadUpgradeOptions(ulabel, uselect, it);
    ubtn.addEventListener("click", async ()=>{
      const sel = uselect.value;
      if (!sel){ alert("Select an upgrade first."); return; }
      let target = "";
      const meta = (window.UPGRADE_META || {})[sel];
      if (meta && Array.isArray(meta.targets) && meta.targets.length){
        const choice = prompt(`Select target for ${meta.name || "upgrade"} (${meta.targets.join(", ")})`, meta.targets[0]);
        if (!choice || !meta.targets.includes(choice)){ alert("Invalid target."); return; }
        const existing = (it.upgrades || []).filter(u=>u.target===choice).length;
        if (existing >= 2){ alert("Target already has two upgrades."); return; }
        target = choice;
      }
      try{
        const inv = await installUpgrade(it.item_id, sel, target);
        if (inv){ LINKED_INV = inv; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave(); }
        closeInvItemModal();
      }catch(e){ alert(e.message); }
    });

    const upList = document.createElement("div");
    upList.className = "upg-list";
    const ups = it.upgrades || [];
    if (!ups.length){
      const empty = document.createElement("div");
      empty.className = "muted";
      empty.textContent = "No upgrades installed.";
      upList.appendChild(empty);
    }else{
      ups.forEach(u=>{
        const upgId = u.id || u.key || u;
        const meta = (window.UPGRADE_META || {})[upgId] || {};
        const title = meta.name || u.name || upgId || "Upgrade";
        const desc = u.description_html || u.description || meta.description_html || meta.description || "";

        const row = document.createElement("div");
        row.className = "upg-row";

        const head = document.createElement("div");
        head.className = "row";
        head.style.justifyContent = "space-between";
        head.style.alignItems = "center";
        head.innerHTML = `<h4 style="margin:0;">${invEscapeHtml(title)}</h4>${u.target ? `<span class="pill-soft">Target: ${invEscapeHtml(u.target)}</span>` : ""}`;
        row.appendChild(head);

        if (desc){
          const dd = document.createElement("div");
          dd.className = "muted";
          dd.innerHTML = desc;
          row.appendChild(dd);
        }

        const btns = document.createElement("div");
        btns.className = "btn-row";
        const rem = document.createElement("button");
        rem.className = "btn btn-secondary small";
        rem.textContent = "Remove";
        rem.addEventListener("click", async ()=>{
          try{
            const inv = await removeUpgrade(it.item_id, upgId, u.target || "");
            LINKED_INV = inv; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
            closeInvItemModal();
          }catch(e){ alert(e.message); }
        });
        const edit = document.createElement("button");
        edit.className = "btn small";
        edit.textContent = "Edit";
        edit.addEventListener("click", ()=>{ window.open(`upgrades_home.html?id=${encodeURIComponent(upgId)}`, "_blank"); });
        btns.appendChild(rem);
        btns.appendChild(edit);
        row.appendChild(btns);
        upList.appendChild(row);
      });
    }

    upSection.appendChild(upList);
    invItemBody.appendChild(upSection);
  }

  const btnRow = document.createElement("div");
  btnRow.className = "btn-row";

  if (it.consumable){
    const useBtn = document.createElement("button");
    useBtn.className = "btn small";
    useBtn.textContent = "Use";
    if ((Number(it.quantity)||0) <= 0) useBtn.disabled = true;
    useBtn.addEventListener("click", async ()=>{
      await useItemInline(it);
      closeInvItemModal();
    });
    btnRow.appendChild(useBtn);
  }else{
    const equipBtn = document.createElement("button");
    equipBtn.className = "btn small";
    equipBtn.textContent = equipped ? "Unequip" : "Equip";
    equipBtn.addEventListener("click", async ()=>{
      await toggleEquipInline(it);
      closeInvItemModal();
    });
    btnRow.appendChild(equipBtn);
  }

  const moveWrap = document.createElement("div");
  moveWrap.className = "row";
  moveWrap.style.gap = "6px";
  const moveSel = document.createElement("select");
  const stowedId = it.stowed_container_id || (it.container_id !== SELF_CONTAINER_ID ? it.container_id : "");
  const allowed = (LINKED_INV?.containers || []).filter(cc=> it.equipped!==false ? true : cc.id !== SELF_CONTAINER_ID);
  allowed.forEach(cc=>{
    const o=document.createElement("option");
    o.value = cc.id;
    o.textContent = cc.name || cc.id;
    moveSel.appendChild(o);
  });
  if (stowedId){ moveSel.value = stowedId; }
  const moveBtn = document.createElement("button");
  moveBtn.className = "btn small";
  moveBtn.textContent = "Move";
  if (!moveSel.children.length){
    moveSel.disabled = true;
    moveBtn.disabled = true;
    moveBtn.title = "Add another container to move items.";
  }
  moveBtn.addEventListener("click", async ()=>{
    const dest = moveSel.value;
    if (!dest) return;
    await moveItemToContainer(it, dest);
    closeInvItemModal();
  });
  moveWrap.appendChild(moveSel);
  moveWrap.appendChild(moveBtn);
  btnRow.appendChild(moveWrap);

  const sellBtn = document.createElement("button");
  sellBtn.className = "btn small";
  sellBtn.textContent = "Sell";
  sellBtn.addEventListener("click", async ()=>{
    const fallback = Number(it.base_price ?? it.paid_unit ?? 0) || 0;
    const ask = prompt("Sell price per unit (blank to cancel)", fallback);
    if (ask === null) return;
    const price = Number(ask);
    if (!Number.isFinite(price) || price < 0){ alert("Enter a valid price"); return; }
    await sellItemInline(it, price);
    closeInvItemModal();
  });
  btnRow.appendChild(sellBtn);

  const disposeBtn = document.createElement("button");
  disposeBtn.className = "btn btn-secondary small";
  disposeBtn.textContent = "Dispose";
  disposeBtn.addEventListener("click", async ()=>{
    if (!confirm("Dispose this item? This removes it with no revenue.")) return;
    await disposeItemInline(it);
    closeInvItemModal();
  });
  btnRow.appendChild(disposeBtn);

  if (it.kind === "weapon" || it.kind === "equipment"){
    const qBtn = document.createElement("button");
    qBtn.className = "btn small";
    qBtn.textContent = "Improve quality";
    qBtn.addEventListener("click", async ()=>{
      const target = prompt("Target quality? (e.g., Good, Excellent, ...)", (it.quality || "").toString());
      if (!target) return;
      try{
        const inv = await upgradeQuality(it.item_id, target);
        LINKED_INV = inv; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
        closeInvItemModal();
      }catch(e){
        alert(e.message);
      }
    });
    btnRow.appendChild(qBtn);
  }

  if (hasChoice){
    const choiceBtn = document.createElement("button");
    choiceBtn.className = "btn small";
    choiceBtn.textContent = "Configure choices";
    choiceBtn.addEventListener("click", async ()=>{
      await openItemChoiceModal(it);
      closeInvItemModal();
    });
    btnRow.appendChild(choiceBtn);
  }

  invItemActions.appendChild(btnRow);

  if (it.alchemy_tool){
    const refillRow = document.createElement("div");
    refillRow.className = "btn-row";
    const refillBtn = document.createElement("button");
    refillBtn.className = "btn small";
    const tier = alchemyTierFromPrice(it.base_price);
    const cost = 50 * tier;
    refillBtn.textContent = `Refill (+1, ${cost} Jelly)`;
    refillBtn.addEventListener("click", async ()=>{
      await refillAlchemyInline(it);
      closeInvItemModal();
    });
    refillRow.appendChild(refillBtn);
    invItemActions.appendChild(refillRow);
  }

  invItemModal.classList.remove("hidden");
  invItemModal.classList.add("open");
  invItemBackdrop.classList.remove("hidden");
  invItemBackdrop.classList.add("open");
}

function closeInvItemModal(){
  invItemModal.classList.add('hidden');
  invItemModal.classList.remove('open');
  invItemBackdrop.classList.remove('open');
}

function deriveSpellListInitialValuesFromChar(){
  if (!CHAR || !CHAR.stats) return null;
  const iv = {
    mag: totalFromInvest(investVal(CHAR.stats.magic?.invest, 0)),
    natures: {fire:0,water:0,wind:0,earth:0,sun:0,moon:0,lightning:0,ki:0},
    skills: {aura:0,incantation:0,enchantement:0,potential:0,restoration:0,stealth:0,investigation:0,charm:0,intimidation:0,absorption:0,spirit:0},
  };
  const ints = CHAR.stats.intensities || {};
  const intsLc = {};
  for (const [name, val] of Object.entries(ints)){
    intsLc[name.toLowerCase()] = investVal(val, 0);
  }
  for (const k of Object.keys(iv.natures)){
    iv.natures[k] = Math.max(0, Math.floor(intsLc[k] ?? 0));
  }
  for (const [key, ckey] of Object.entries(SKILL_TO_CHAR)){
    const label = SKILL_LABEL[key] || title(key);
    iv.skills[key] = skillTotalAdjustedFor(ckey, label).total;
  }
  return iv;
}

function drawAvatarCanvas(){
  if (!AVATAR_IMG) return;
  const ctx = avatarCanvas.getContext('2d');
  const zoom = parseFloat(avatarZoomEl.value || "1");
  const ox = parseFloat(avatarOffsetXEl.value || "0");
  const oy = parseFloat(avatarOffsetYEl.value || "0");
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,avatarCanvas.width, avatarCanvas.height);
  const w = AVATAR_IMG.width * zoom;
  const h = AVATAR_IMG.height * zoom;
  const x = (avatarCanvas.width - w)/2 + ox;
  const y = (avatarCanvas.height - h)/2 + oy;
  ctx.drawImage(AVATAR_IMG, x, y, w, h);
  avatarPreview.src = avatarCanvas.toDataURL('image/png');
}

avatarZoomEl?.addEventListener('input', drawAvatarCanvas);
avatarOffsetXEl?.addEventListener('input', drawAvatarCanvas);
avatarOffsetYEl?.addEventListener('input', drawAvatarCanvas);

avatarFileEl?.addEventListener('change', ()=>{
  const f = avatarFileEl.files?.[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = (e)=>{
    const img = new Image();
    img.onload = ()=>{
      AVATAR_IMG = img;
      // Fit the image in the 256x256 frame by default, then allow zooming in
      const fitZoom = Math.min(avatarCanvas.width / img.width, avatarCanvas.height / img.height);
      avatarZoomEl.min = (fitZoom * 0.5).toFixed(2);
      avatarZoomEl.max = (fitZoom * 4).toFixed(2);
      avatarZoomEl.step = "0.01";
      avatarZoomEl.value = fitZoom.toFixed(2);
      avatarOffsetXEl.value = "0";
      avatarOffsetYEl.value = "0";
      drawAvatarCanvas();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(f);
});

async function uploadAvatar(){
  if (!AVATAR_IMG){
    avatarStatusEl.textContent = 'Pick an image first.';
    return;
  }
  avatarStatusEl.textContent = 'Uploading...';
  await new Promise(res=> requestAnimationFrame(res));
  drawAvatarCanvas();
  await new Promise((resolve, reject)=>{
    avatarCanvas.toBlob(async (blob)=>{
      if (!blob){ reject(new Error("Cannot encode image")); return; }
      try{
        const fd = new FormData();
        fd.append('file', blob, 'avatar.png');
        const r = await fetch(`/characters/${encodeURIComponent(CID)}/avatar`, {
          method:'POST',
          headers: authHeaders(),
          body: fd
        });
        const j = await r.json().catch(()=>({}));
        if (j.status !== "success"){ throw new Error(j.message || "Upload failed"); }
        avatarStatusEl.textContent = 'Uploaded.';
        avatarPreview.src = `/characters/${encodeURIComponent(CID)}/avatar?ts=${Date.now()}`;
      }catch(e){
        avatarStatusEl.textContent = e.message;
      }
      resolve();
    }, 'image/png');
  });
}
avatarUploadBtn?.addEventListener('click', uploadAvatar);
function toggleAvatarModal(open){
  if (!avatarModal || !avatarBackdrop) return;
  if (open){
    avatarModal.classList.remove('hidden');
    avatarModal.classList.add('open');
    avatarBackdrop.classList.add('open');
  }else{
    avatarModal.classList.add('hidden');
    avatarModal.classList.remove('open');
    avatarBackdrop.classList.remove('open');
  }
}
avatarOpenBtn?.addEventListener('click', ()=>{
  toggleAvatarModal(true);
});
avatarClose?.addEventListener('click', ()=> toggleAvatarModal(false));
avatarCancel?.addEventListener('click', ()=> toggleAvatarModal(false));
avatarBackdrop?.addEventListener('click', (e)=>{ if (e.target===avatarBackdrop) toggleAvatarModal(false); });

function normalizeIV(iv){
  const defN = {fire:0,water:0,wind:0,earth:0,sun:0,moon:0,lightning:0,ki:0};
  const defS = {aura:0,incantation:0,enchantement:0,potential:0,restoration:0,stealth:0,investigation:0,charm:0,intimidation:0,absorption:0,spirit:0};
  const n = Object.assign({}, defN), s = Object.assign({}, defS);
  for (const k in (iv?.natures||{})) n[k.toLowerCase()] = +(iv.natures[k]||0);
  for (const k in (iv?.skills||{}))  s[k.toLowerCase()] = +(iv.skills[k]||0);
  return { mag: +(iv?.mag||0), natures:n, skills:s };
}

function title(str){
  const s = (str ?? '').toString();
  return s ? s.charAt(0).toUpperCase() + s.slice(1) : '';
}

const SKILL_ALIASES = {
  enchantment: "enchantement",
  enchante: "enchantement",
  incantation: "incantation",
  incantaion: "incantation",
  icnantaion: "incantation",
  incatation: "incantation",
  resto: "restoration",
};
const SKILL_LABEL = {
  aura: "Aura",
  incantation: "Incantation",
  enchantement: "Enchantment",
  potential: "Potential",
  restoration: "Restoration",
  stealth: "Stealth",
  investigation: "Investigation",
  charm: "Charm",
  intimidation: "Intimidation",
  absorption: "Absorption",
  spirit: "Spirit",
};
const SKILL_TO_CHAR = {
  aura: "magic",
  incantation: "magic",
  enchantement: "magic",
  potential: "magic",
  restoration: "magic",
  stealth: "dexterity",
  investigation: "wisdom",
  charm: "presence",
  intimidation: "willpower",
  absorption: "willpower",
  spirit: "willpower",
};
function normSkillKey(s){
  const cleaned = (s || "").toString().trim().toLowerCase().replace(/[^a-z]/g, "");
  return SKILL_ALIASES[cleaned] || cleaned;
}
function skillValFromIV(skillName, iv){
  const key = normSkillKey(skillName);
  if (!iv || !iv.skills) return 0;
  if (key && key in iv.skills) return numOr(iv.skills[key], 0);
  // fallback: loose match
  const found = Object.entries(iv.skills).find(([k])=> normSkillKey(k) === key);
  return found ? numOr(found[1], 0) : 0;
}
function skillValFromChar(skillName){
  const key = normSkillKey(skillName);
  const ckey = SKILL_TO_CHAR[key];
  if (!ckey) return null;
  const label = SKILL_LABEL[key] || title(key);
  return skillTotalAdjustedFor(ckey, label);
}

function currentIV(){
  return normalizeIV(deriveSpellListInitialValuesFromChar());
}

async function fetchSchools(){
  if (SCHOOLS.length) return SCHOOLS;
  const res = await api('/schools');
  SCHOOLS = res.schools || [];
  return SCHOOLS;
}

function renderSpellListSummary(){
  if (!LINKED_SPELL_LIST){
    slSummaryEl.textContent = 'No spell list linked.';
    return;
  }
  const count = Array.isArray(LINKED_SPELL_LIST.spells) ? LINKED_SPELL_LIST.spells.length : (LINKED_SPELL_LIST.count || 0);
  const iv = currentIV();
  slSummaryEl.textContent = `${LINKED_SPELL_LIST.name || 'Spell List'} • Spells: ${count} • MAG: ${iv.mag}`;
}

function renderXpProgress(){
  if (!xpProgressEl) return;
  const lvl = Math.max(1, Math.floor(Number(CHAR.level)||1));
  const xp = Math.max(0, Math.floor(Number(XP)||0));
  const nextCap = lvl >= MAX_LEVEL ? null : xpForLevel(lvl+1);
  const curCap = xpForLevel(lvl);
  const toNext = nextCap == null ? 0 : Math.max(0, nextCap - xp);
  if (nextCap == null){
    xpProgressEl.textContent = `XP: ${xp} (level ${lvl} maxed)`;
  }else{
    xpProgressEl.textContent = `XP: ${xp} (level ${lvl}) • Need ${toNext} more to reach level ${lvl+1}`;
  }
}

async function renderSchoolSpellCounters(){
  if (!CHAR || !CHAR.stats) return;
  try{ if (!SCHOOLS.length) await fetchSchools(); }catch{}
  const magVal = totalFromInvest(investVal(CHAR.stats.magic?.invest, 0));
  const msMAG = milestone('magic');
  let simpleSchools = 0, complexSchools = 0;
  ADDED_SCHOOLS.forEach(id=>{
    const s = (SCHOOLS||[]).find(x=>String(x.id||x.name)===String(id));
    if (!s) return;
    const type = (s.school_type || s.type || '').toLowerCase();
    if (type === 'complex') complexSchools++; else simpleSchools++;
  });
  const metaMap = SPELLLIST_META.spell_meta || {};
  const isPrepared = (sp)=> ((metaMap[sp.id]?.status || 'known') === 'learnt');
  const findSchoolByRef = (ref)=>{
    const id = String(ref.id || ref.name || '').toLowerCase();
    return (SCHOOLS||[]).find(s=> String(s.id||'').toLowerCase()===id || String(s.name||'').toLowerCase()===id);
  };
  const spellTypes = (sp)=>{
    const refs = sp.schools || [];
    const types = [];
    refs.forEach(r=>{
      const s = findSchoolByRef(r);
      if (!s || s.upgrade) return;
      const t = (s.school_type || s.type || '').toLowerCase();
      if (t) types.push(t);
    });
    return types;
  };
  let simplePrepared = 0, complexPrepared = 0;
  SPELLLIST_SPELLS.forEach(sp=>{
    if (!isPrepared(sp)) return;
    const types = spellTypes(sp);
    if (!types.length) return;
    const hasComplex = types.includes('complex');
    const onlySimple = types.every(t=>t==='simple');
    if (hasComplex) complexPrepared++;
    else if (onlySimple) simplePrepared++;
  });
  const maxSimpleSchools = null; // unlimited simple schools
  const maxComplexSchools = msMAG || 0;
  const maxSimplePrepared = magVal;
  const maxComplexPrepared = msMAG * 2;
  if (cntSchSimpleEl)  cntSchSimpleEl.textContent  = `Simple schools: ${simpleSchools}${maxSimpleSchools != null ? ` / ${maxSimpleSchools}` : ''}`;
  if (cntSchComplexEl) cntSchComplexEl.textContent = `Complex schools: ${complexSchools} / ${maxComplexSchools}`;
  if (cntSpSimpleEl)   cntSpSimpleEl.textContent   = `Simple spell slots: ${simplePrepared} / ${maxSimplePrepared}`;
  if (cntSpComplexEl)  cntSpComplexEl.textContent  = `Complex spell slots: ${complexPrepared} / ${maxComplexPrepared}`;
}
const MS_CATEGORIES = [
  {name:"Avant-Garde", min:44},
  {name:"Supreme Archmage", min:40},
  {name:"Archmage", min:36},
  {name:"Grand Master", min:32},
  {name:"Master", min:28},
  {name:"High Mage", min:24},
  {name:"Magister", min:20},
  {name:"Mage", min:16},
  {name:"Adept", min:12},
  {name:"Disciple", min:8},
  {name:"Apprentice", min:6},
  {name:"Novice", min:4},
];
function mapMsCategory(ms){
  const v = Number(ms) || 0;
  const hit = MS_CATEGORIES.find(c => v >= c.min);
  return hit ? hit.name : "--";
}

function msForSchool(school){
  const iv = currentIV() || {};
  const skillKeyRaw = school.linked_skill || '';
  const skillKey = normSkillKey(skillKeyRaw);
  const valFromIV = skillValFromIV(skillKeyRaw, iv);
  const valFromChar = skillValFromChar(skillKeyRaw);
  const skillVal = Math.max(valFromIV ?? 0, valFromChar ?? 0);
  const ints = (school.linked_intensities || []).map(lc);
  const vals = ints
    .map(k => ({ key:k, val:numOr(iv.natures?.[k], 0) }))
    .sort((a,b)=> (b.val - a.val) || a.key.localeCompare(b.key));
  const top1 = vals[0] || { key:null, val:0 };
  const top2 = vals[1] || { key:null, val:0 };
  const magMod = charAdjMod('magic').mod;

  let natureBase = top1.val;
  let natureName = top1.key;
  let magUsed = 0;

  if (top2.key){
    const secondPlusMag = top2.val + magMod;
    const useSecond = !(top1.val > secondPlusMag);
    natureBase = useSecond ? top2.val : top1.val;
    natureName = useSecond ? top2.key : top1.key;
    magUsed = useSecond ? magMod : 0;
  }

  const natureTotal = natureBase + magUsed;
  const ms = skillVal + natureTotal;
  return {
    ms,
    category: mapMsCategory(ms),
    skillVal,
    skillKey,
    top1: top1.val,
    top2: top2.val,
    natureName,
    natureBase,
    natureTotal,
    magUsed,
    magMod,
  };
}
function msForSchoolWithMods(school){
  const base = msForSchool(school);
  const key = String(school.id || school.name || '').toLowerCase();
  const adj = applyOps(base.ms, PASSIVE.school[key]);
  return { ...base, ms: adj.value, notes: adj.notes };
}

function isComplexEligible(school){
  const magTotal = totalFromInvest(investVal(CHAR.stats.magic?.invest, 0));
  if (magTotal < 10) return false;
  const linked = (school.linked_intensities || []).map(lc);
  const needed = linked.length <= 1 ? 1 : 2;
  const iv = currentIV() || {};
  const count = linked.map(k=> numOr(iv.natures?.[k], 0)).filter(v=> v >= 10).length;
  return count >= needed;
}

function toggleSchoolModal(open){
  if (!slSchModal || !slSchBackdrop) return;
  if (open){
    slSchModal.classList.remove('hidden'); slSchBackdrop.classList.remove('hidden');
    slSchModal.classList.add('open'); slSchBackdrop.classList.add('open');
  }else{
    slSchModal.classList.add('hidden'); slSchBackdrop.classList.add('hidden');
    slSchModal.classList.remove('open'); slSchBackdrop.classList.remove('open');
    if (slSchStatus) slSchStatus.textContent = '';
  }
}

async function renderAddedSchools(){
  if (!slSchoolsEl) return;
  if (!SCHOOLS.length){
    try{ await fetchSchools(); }catch{}
  }
  slSchoolsEl.innerHTML = '';
  if (!ADDED_SCHOOLS.size){
    slSchoolsEl.innerHTML = '<div class="muted">No schools added yet.</div>';
    return;
  }
  const list = Array.from(ADDED_SCHOOLS).map(id=>{
    const s = (SCHOOLS||[]).find(x=>String(x.id||x.name)===String(id));
    return s ? { id, s } : null;
  }).filter(Boolean);
  if (!list.length){
    slSchoolsEl.innerHTML = '<div class="muted">No schools added yet.</div>';
    return;
  }
  list.forEach(({id,s})=>{
    const msInfo = msForSchoolWithMods(s);
    const ms = msInfo.ms;
    const cat = mapMsCategory(ms) || s.category || s.type || '--';
    const tipLines = [
      `Skill (${s.linked_skill || 'skill'}): ${msInfo.skillVal || 0}`,
      `Top nature: ${msInfo.top1 || 0}`,
      `Second nature: ${msInfo.top2 || 0}`,
      `Used: ${msInfo.natureName ? title(msInfo.natureName) : 'â€”'} ${msInfo.natureBase || 0}${msInfo.magUsed ? ` + MAG ${msInfo.magUsed}` : ''}`,
      `Total MS: ${ms}`,
    ];
    if (msInfo.notes && msInfo.notes.length){
      tipLines.push('MS modifiers:');
      msInfo.notes.forEach(n=> tipLines.push(`- ${n}`));
    }
    const div = document.createElement('div');
    div.className = 'abi-item';
    div.innerHTML = `
      <div class="grow">
        <div><strong>${s.name || id}</strong></div>
        <div class="muted" title="${tipLines.join('\n').replace(/"/g,'&quot;')}">MS: ${ms} | Category: ${cat}</div>
      </div>
      <span class="tag">${(s.school_type || s.type || '').toUpperCase()}</span>
      <button class="btn small" data-remove="${id}">Remove</button>
    `;
    div.querySelector('button').addEventListener('click', async ()=>{
      ADDED_SCHOOLS.delete(String(id));
      try{ await saveSpellListMeta({ selected_schools: Array.from(ADDED_SCHOOLS) }); }catch{}
      if (CHAR && CHAR.stats) CHAR.stats.selected_schools = Array.from(ADDED_SCHOOLS);
      queueSave();
      renderAddedSchools();
      renderSchoolSpellCounters();
    });
    slSchoolsEl.appendChild(div);
  });
}


async function quickAddSchools(){
  if (!SCHOOLS.length){ await fetchSchools(); }
  const before = new Set(ADDED_SCHOOLS);
  SCHOOLS.forEach(s=>{
    const type = (s.school_type || s.type || '').toLowerCase();
    if (type === 'simple'){
      ADDED_SCHOOLS.add(String(s.id||s.name));
    }else if (type === 'complex' && isComplexEligible(s)){
      ADDED_SCHOOLS.add(String(s.id||s.name));
    }
  });
  const addedCount = ADDED_SCHOOLS.size - before.size;
  if (slSchoolsStatusEl) slSchoolsStatusEl.textContent = addedCount ? `Added ${addedCount} school(s).` : 'No new schools met the requirements.';
  CHAR.stats.selected_schools = Array.from(ADDED_SCHOOLS);
  const payload = { selected_schools: Array.from(ADDED_SCHOOLS), pinned_schools: Array.from(ADDED_SCHOOLS) };
  try{ await saveSpellListMeta(payload); }catch{}
  renderAddedSchools();
  renderSchoolSpellCounters();
  queueSave();
}

async function openManualAddModal(){
  if (!SELECTED_SPELL_LIST_ID){
    slSchoolsStatusEl.textContent = 'Link a spell list first.';
    return;
  }
  if (!slSchBody) return;
  slSchBody.innerHTML = '<tr><td colspan="4" class="empty">Loading...</td></tr>';
  if (!SCHOOLS.length){ await fetchSchools(); }
  const available = (SCHOOLS||[]).filter(s=> !ADDED_SCHOOLS.has(String(s.id||s.name)));
  available.sort((a,b)=> (b.category||'').localeCompare(a.category||'') || (a.name||'').localeCompare(b.name||''));
  slSchBody.innerHTML = '';
  if (!available.length){
    slSchBody.innerHTML = '<tr><td colspan="4" class="empty">No remaining schools to add.</td></tr>';
  }else{
    available.forEach(s=>{
      const id = String(s.id||s.name);
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input type="checkbox" value="${id}"></td>
        <td>${s.name || id}</td>
        <td>${s.school_type || s.type || ''}</td>
        <td>${s.category || ''}</td>
      `;
      slSchBody.appendChild(tr);
    });
  }
  toggleSchoolModal(true);
}

async function applyManualAdd(){
  if (!slSchBody) return;
  if (!SELECTED_SPELL_LIST_ID){
    slSchoolsStatusEl.textContent = 'Link a spell list first.';
    return;
  }
  const selected = Array.from(slSchBody.querySelectorAll('input[type="checkbox"]:checked')).map(el=>el.value);
  selected.forEach(id=> ADDED_SCHOOLS.add(String(id)));
  const payload = { selected_schools: Array.from(ADDED_SCHOOLS), pinned_schools: Array.from(ADDED_SCHOOLS) };
  try{ await saveSpellListMeta(payload); }catch{}
  toggleSchoolModal(false);
  renderAddedSchools();
  if (slSchoolsStatusEl) slSchoolsStatusEl.textContent = selected.length ? `Added ${selected.length} school(s).` : 'No schools selected.';
  renderSchoolSpellCounters();
  queueSave();
}

function addXp(amount){
  const inc = Math.max(0, Math.floor(Number(amount)||0));
  if (!inc) return;
  XP = Math.max(0, XP + inc);
  CHAR.xp = XP;
  const lvl = levelFromXp(XP);
  CHAR.level = lvl;
  CHAR.stats.level = CHAR.level;
  levelEl.value = lvl;
  renderXpProgress();
  renderSublimations();
  updatePointCounters();
  updateDerived();
  queueSave();
}

function setLevelManual(lvl){
  const val = Math.max(1, Math.min(MAX_LEVEL, Math.floor(Number(lvl)||1)));
  CHAR.level = val;
  CHAR.stats.level = CHAR.level;
  levelEl.value = val;
  if (XP < xpForLevel(val)) XP = xpForLevel(val);
  CHAR.xp = XP;
  renderXpProgress();
  renderSublimations();
  updatePointCounters();
  updateDerived();
  queueSave();
}

function renderSpellRows(){
  if (!slSpellsBody) return;
  const metaMap = SPELLLIST_META.spell_meta || {};
  if (!SPELLLIST_SPELLS.length){
    slSpellsBody.innerHTML = '<tr><td colspan="5" class="empty">No spells. Add some.</td></tr>';
    return;
  }
  slSpellsBody.innerHTML = '';
  SPELLLIST_SPELLS.forEach(sp=>{
    const meta = metaMap[sp.id] || {};
    const alt = meta.alt_name || '';
    const status = meta.status || 'known';
    const nameDisplay = alt || sp.name || 'Spell';
    const tr = document.createElement('tr');
    const schools = (sp.schools||[]).map(s=>s.name||s.id).join(', ');
    tr.innerHTML = `
      <td><div class="k">${nameDisplay}</div><div class="muted">id: ${sp.id}</div></td>
      <td>${schools || 'â€”'}</td>
      <td>${sp.category || 'â€”'}</td>
      <td>
        <select class="sl-status" data-id="${sp.id}">
        <option value="known" ${status==="known"?"selected":""}>Learnt</option>
        <option value="learnt" ${status==="learnt"?"selected":""}>Prepared</option>
        </select>
      </td>
      <td><button class="btn small" data-remove="${sp.id}">Remove</button></td>
    `;
    slSpellsBody.appendChild(tr);
  });
  slSpellsBody.querySelectorAll('.sl-status').forEach(sel=>{
    sel.addEventListener('change', ()=>{
      const id = sel.getAttribute('data-id');
      SPELLLIST_META.spell_meta = SPELLLIST_META.spell_meta || {};
      const cur = SPELLLIST_META.spell_meta[id] || {};
      SPELLLIST_META.spell_meta[id] = { ...cur, status: sel.value };
      saveSpellListMeta({ spell_meta: SPELLLIST_META.spell_meta }).catch(()=>{});
      renderAbilitySpellsBucket();
      renderSchoolSpellCounters();
    });
  });
  slSpellsBody.querySelectorAll('button[data-remove]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-remove');
      if (!confirm(`Remove spell ${id}?`)) return;
      await removeSpellFromList(id);
    });
  });
}

function renderAbilitySpellsBucket(){
  const el = document.getElementById('abi-list-spells');
  if (!el) return;
  el.innerHTML = '';
  if (!SPELLLIST_SPELLS.length){ el.innerHTML = '<div class="muted">No linked spells.</div>'; return; }
  // lazy-load effects for descriptions
  if (!Object.keys(EFFECTS_BY_ID).length && !EFFECTS_PROMISE){
    ensureEffectsLoaded().then(()=> renderAbilitySpellsBucket());
  }
  const metaMap = SPELLLIST_META.spell_meta || {};
  const onlyLearned = !!(abiSpellsOnlyLearnedEl && abiSpellsOnlyLearnedEl.checked);
  SPELLLIST_SPELLS.filter(sp=> !onlyLearned || (metaMap[sp.id]?.status === 'learnt')).forEach(sp=>{
    const meta = metaMap[sp.id] || {};
    const alt = meta.alt_name || '';
    const nameDisplay = alt || sp.name || 'Spell';
    const desc = meta.description || sp.description || sp.description_long || sp.desc || '';
    const flavor = sp.flavor || sp.flavour || '';
    const userFlavor = meta.flavor || meta.flavour || '';
    const effectDetails = Array.isArray(sp.effects_detail) ? sp.effects_detail : [];
    let effectsDesc = effectDetails.map(e=> e.description || e.detail || e).filter(Boolean).join(' | ');
    const effectCounts = {};
    (sp.effects || []).forEach(eid=>{
      const k = String(eid||'').toLowerCase();
      effectCounts[k] = (effectCounts[k]||0) + 1;
    });
    const resolvedEffects = Object.entries(effectCounts).map(([id,count])=>{
      const eff = EFFECTS_BY_ID[id] || {};
      const base = eff.description || eff.effect || eff.text || eff.name || id;
      const countTxt = count > 1 ? ` x${count}` : '';
      return `${base}${countTxt}`;
    }).filter(Boolean);
    if (resolvedEffects.length){
      effectsDesc = effectsDesc ? `${effectsDesc} | ${resolvedEffects.join(' | ')}` : resolvedEffects.join(' | ');
    }else if (!effectsDesc){
      const rawEffect = sp.effect || sp.effect_text || sp.effectText || sp.effect_description || sp.effects_description;
      if (rawEffect) effectsDesc = String(rawEffect);
    }
    const costParts = [];
    if (sp.mp_cost != null) costParts.push(`MP: ${sp.mp_cost}`);
    if (sp.en_cost != null) costParts.push(`EN: ${sp.en_cost}`);
    const cost = costParts.join(' • ');
    const range = sp.range != null ? `Range: ${sp.range}` : '';
    const aoe = sp.aoe ? `AoE: ${sp.aoe}` : '';
    const div = document.createElement('div');
    div.className = 'abi-item';
    const statusLabel = (meta.status === 'learnt') ? 'Prepared' : 'Learnt';
    div.innerHTML = `
      <div class="grow">
        <div><strong>${nameDisplay}</strong> <span class="muted">${statusLabel}</span></div>
        <div class="muted" style="font-size:.85rem">${desc}</div>
        ${flavor ? `<div class="muted" style="font-size:.8rem"><em>${flavor}</em></div>` : ''}
        ${userFlavor ? `<div class="muted" style="font-size:.8rem"><em>User note: ${userFlavor}</em></div>` : ''}
        ${effectsDesc ? `<div class="muted" style="font-size:.8rem">Effects: ${effectsDesc}</div>` : ''}
        <div class="muted" style="font-size:.8rem">${cost} ${range?` • ${range}`:''} ${aoe?` • ${aoe}`:''}</div>
      </div>
      <span class="tag">${sp.category || ''}</span>
    `;
    el.appendChild(div);
  });
}

function openSpellAddModal(){
  slAddModal.classList.remove('hidden');
  slAddModal.classList.add('open');
  slAddBackdrop.classList.add('open');
}
function closeSpellAddModal(){
  slAddModal.classList.add('hidden');
  slAddModal.classList.remove('open');
  slAddBackdrop.classList.remove('open');
  slAddStatus.textContent = '';
}

async function loadSpellListsList(){
  slStatusEl.textContent = 'Loading spell lists...';
  try{
    const res = await api('/spell_lists/mine');
    SPELL_LISTS = res.lists || [];
    slSelectEl.innerHTML = '<option value="">-- Select spell list --</option>';
    SPELL_LISTS.forEach(lst=>{
      const opt = document.createElement('option');
      opt.value = lst.id;
      opt.textContent = lst.name || lst.id;
      if (lst.id === SELECTED_SPELL_LIST_ID) opt.selected = true;
      slSelectEl.appendChild(opt);
    });
    slStatusEl.textContent = '';
  }catch(e){
    slStatusEl.textContent = 'Load failed: ' + e.message;
  }
}

async function loadSpellListMeta(id){
  const res = await api(`/spell_lists/${encodeURIComponent(id)}/meta`);
  SPELLLIST_META = res.meta || {};
  const metaSel = Array.isArray(SPELLLIST_META.selected_schools) ? SPELLLIST_META.selected_schools : null;
  const metaPinned = Array.isArray(SPELLLIST_META.pinned_schools) ? SPELLLIST_META.pinned_schools : null;
  const statSel = Array.isArray(CHAR.stats?.selected_schools) ? CHAR.stats.selected_schools : null;
  const raw = (metaSel && metaSel.length) ? metaSel
            : (metaPinned && metaPinned.length) ? metaPinned
            : (statSel && statSel.length) ? statSel
            : (metaSel ?? metaPinned ?? statSel ?? []);
  setAddedSchools(raw || []);
}

async function saveSpellListMeta(patch){
  if (!SELECTED_SPELL_LIST_ID) return;
  const res = await fetch(`/spell_lists/${encodeURIComponent(SELECTED_SPELL_LIST_ID)}/meta`, {
    method:"PUT",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify(patch)
  });
  const j = await res.json();
  if (j.status !== "success") throw new Error(j.message || "Save failed");
  SPELLLIST_META = { ...SPELLLIST_META, ...(patch || {}) };
  if (patch && Array.isArray(patch.selected_schools)){
    ADDED_SCHOOLS = new Set(patch.selected_schools.map(String));
  }
}

async function fetchSpellListSpells(id){
  const res = await api(`/spell_lists/${encodeURIComponent(id)}/spells`);
  return res.spells || [];
}

async function removeSpellFromList(id){
  const r = await fetch(`/spell_lists/${encodeURIComponent(SELECTED_SPELL_LIST_ID)}/spells/${encodeURIComponent(id)}`, {
    method:"DELETE",
    headers: authHeaders()
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Remove failed"); return; }
  await reloadSpellListData();
}

async function addSpellsToList(ids){
  const r = await fetch(`/spell_lists/${encodeURIComponent(SELECTED_SPELL_LIST_ID)}/spells`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ ids })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ slAddStatus.textContent = j.message || "Add failed"; return; }
  slAddStatus.textContent = `Added ${j.added?.length || ids.length} spell(s).`;
  await reloadSpellListData();
}

async function searchSpells(q){
  const qs = q ? `?name=${encodeURIComponent(q)}` : '';
  const res = await api('/spells'+qs);
  return res.spells || [];
}

async function renderSpellSearch(){
  const q = slSearchQ.value.trim();
  slAddStatus.textContent = '';
  slSearchBody.innerHTML = '<tr><td colspan="4" class="empty">Searching...</td></tr>';
  try{
    const rows = await searchSpells(q);
    if (!rows.length){
      slSearchBody.innerHTML = '<tr><td colspan="4" class="empty">No results.</td></tr>';
      return;
    }
    slSearchBody.innerHTML = '';
    rows.forEach(sp=>{
      const tr = document.createElement('tr');
      const schools = (sp.schools||[]).map(s=>s.name||s.id).join(', ');
      tr.innerHTML = `
        <td>${sp.name || 'Spell'}</td>
        <td>${schools || 'â€”'}</td>
        <td>${sp.category || 'â€”'}</td>
        <td><button class="btn small" data-add="${sp.id}">Add</button></td>
      `;
      tr.querySelector('button').addEventListener('click', ()=> addSpellsToList([sp.id]));
      slSearchBody.appendChild(tr);
    });
  }catch(e){
    slSearchBody.innerHTML = `<tr><td colspan="4" class="empty">Error: ${e.message}</td></tr>`;
  }
}

async function reloadSpellListData(){
  if (!SELECTED_SPELL_LIST_ID){
    SPELLLIST_SPELLS=[]; SPELLLIST_META={};
    if (CHAR && CHAR.stats) setAddedSchools(CHAR.stats.selected_schools || []);
    renderSpellRows(); renderAddedSchools(); renderSpellListSummary(); renderAbilitySpellsBucket(); renderSchoolSpellCounters(); recomputePassiveAgg(); renderStatistics(); updateDerived(); return;
  }
  await loadSpellListMeta(SELECTED_SPELL_LIST_ID);
  SPELLLIST_SPELLS = await fetchSpellListSpells(SELECTED_SPELL_LIST_ID);
  await ensureEffectsLoaded();
  renderSpellListSummary();
  await fetchSchools();
  renderAddedSchools();
  renderSpellRows();
  renderAbilitySpellsBucket();
  renderSchoolSpellCounters();
  recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function loadArchetypesList(){
  try{
    const res = await api('/archetypes');
    ARCHETYPES = res.archetypes || [];
    arcSelectEl.innerHTML = '<option value=\"\">-- Select archetype --</option>';
    ARCHETYPES.forEach(a=>{
      const opt = document.createElement('option');
      opt.value = a.id;
      opt.textContent = a.name || a.id;
      if (CHAR?.archetype_id === a.id) opt.selected = true;
      arcSelectEl.appendChild(opt);
    });
  }catch(e){
    arcStatusEl.textContent = 'Load archetypes failed: '+e.message;
  }
}

async function fetchAbilitiesByIds(ids){
  if (!ids || !ids.length) return [];
  const qs = '?ids=' + encodeURIComponent(ids.join(','));
  const res = await api('/abilities/bulk'+qs);
  return res.abilities || [];
}

async function renderArchetypePanel(){
  if (!CHAR?.archetype_id){
    arcSummaryEl.textContent = 'No archetype linked.';
    arcAbilitiesEl.innerHTML = '<div class="muted">Select an archetype.</div>';
    return;
  }
  const arc = ARCHETYPES.find(a=>a.id===CHAR.archetype_id);
  const rank = CHAR.archetype_rank || _archetype_rank_for_level(Number(CHAR.level||1));
  arcSummaryEl.textContent = `${arc?.name || CHAR.archetype_id} • Rank: ${rank}`;
  COMPUTED_ARC_ABILITIES = (CHAR.computed_archetype_abilities || []).slice();
  if (!COMPUTED_ARC_ABILITIES.length){
    arcAbilitiesEl.innerHTML = '<div class="muted">No unlocked abilities yet.</div>';
    return;
  }
  const docs = await fetchAbilitiesByIds(COMPUTED_ARC_ABILITIES);
  const byId = {};
  docs.forEach(d=>{ if(d?.id) byId[d.id]=d; });
  arcAbilitiesEl.innerHTML = '';
  COMPUTED_ARC_ABILITIES.forEach(id=>{
    const a = byId[id] || { name:id, description:'' };
    const div = document.createElement('div');
    div.className = 'abi-item';
    div.innerHTML = `
      <div class="grow">
        <div><strong>${a.name || id}</strong></div>
        <div class="muted" style="font-size:.85rem">${a.description || ''}</div>
      </div>
      <span class="tag">Archetype</span>
    `;
    arcAbilitiesEl.appendChild(div);
  });
}

async function loadSpellListById(id){
  if (!id){
    LINKED_SPELL_LIST = null;
    SELECTED_SPELL_LIST_ID = '';
    if (CHAR) CHAR.spell_list_id = '';
    slStatusEl.textContent = '';
    await reloadSpellListData();
    queueSave();
    return;
  }
  slStatusEl.textContent = 'Loading spell list...';
  try{
    const res = await api('/spell_lists/' + encodeURIComponent(id));
    if (res.list){
      LINKED_SPELL_LIST = res.list;
      SELECTED_SPELL_LIST_ID = LINKED_SPELL_LIST.id || id;
      if (CHAR) CHAR.spell_list_id = SELECTED_SPELL_LIST_ID;
      slStatusEl.textContent = 'Spell list loaded';
      await reloadSpellListData();
      queueSave();
    }else{
      throw new Error('Not found');
    }
  }catch(e){
    slStatusEl.textContent = 'Load failed: ' + e.message;
  }
}

async function duplicateAndLinkSpellList(){
  if (!SELECTED_SPELL_LIST_ID){
    slStatusEl.textContent = 'Select a spell list first.';
    return;
  }
  const charName = nameEl.value?.trim() || 'Character';
  const listName = `${charName}'s Spell List`;
  slStatusEl.textContent = 'Duplicating...';
  try{
    const res = await api('/spell_lists/' + encodeURIComponent(SELECTED_SPELL_LIST_ID) + '/duplicate', {
      method:'POST',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ name: listName })
    });
    if (res.list){
      LINKED_SPELL_LIST = res.list;
      SELECTED_SPELL_LIST_ID = res.list.id;
      if (CHAR) CHAR.spell_list_id = SELECTED_SPELL_LIST_ID;
      await loadSpellListsList();
      await reloadSpellListData();
      slStatusEl.textContent = 'Duplicated and linked as ' + SELECTED_SPELL_LIST_ID;
      queueSave();
    }
  }catch(e){
    slStatusEl.textContent = 'Duplicate failed: ' + e.message;
  }
}

async function createAndLinkSpellList(){
  const charName = nameEl.value?.trim() || 'Character';
  const listName = `${charName}'s Spell List`;
  slStatusEl.textContent = 'Creating spell list...';
  try{
    const res = await api('/spell_lists', {
      method:'POST',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ name: listName })
    });
    const list = res.list || res.spell_list || res;
    SELECTED_SPELL_LIST_ID = list.id;
    LINKED_SPELL_LIST = list;
    CHAR.spell_list_id = SELECTED_SPELL_LIST_ID;
    await loadSpellListsList();
    await reloadSpellListData();
    slStatusEl.textContent = 'Created and linked.';
    queueSave();
  }catch(e){
    slStatusEl.textContent = 'Create failed: ' + e.message;
    alert(e.message);
  }
}

function charBaseMod(key){
  const invest = investVal(CHAR.stats?.[key]?.invest, 0);
  return modFromTotal(totalFromInvest(invest));
}
function charAdjMod(key){
  const base = charBaseMod(key);
  const { value, notes } = applyOps(base, PASSIVE.char[key]);
  return { mod:value, notes };
}
function skillBaseTotal(key, skill){
  // Intensities are stored under stats.intensities instead of magic.skills
  const lowerSkill = String(skill || '').toLowerCase();
  const isIntensity = key === 'magic' && INTENSITIES.some(n => n.toLowerCase() === lowerSkill);
  const inv = isIntensity
    ? investVal((CHAR.stats?.intensities || {})[skill] ?? (CHAR.stats?.intensities || {})[INTENSITIES.find(n => n.toLowerCase() === lowerSkill)], 0)
    : investVal(CHAR.stats?.[key]?.skills?.[skill], 0);
  return inv + charBaseMod(key);
}
function skillAdjTotal(key, skill){
  const base = skillBaseTotal(key, skill);
  const agg = PASSIVE.skill[`${key}|${skill}`];
  const { value, notes } = applyOps(base, agg);
  return { total:value, notes };
}

function renderStatistics(){
  gridEl.innerHTML = '';
  for (const c of CHARACS){
    const rec = (CHAR.stats && CHAR.stats[c.key]) || { invest:0, skills:{} };
    const investedChar = investVal(rec.invest, 0);
    const total = totalFromInvest(investedChar);
    const modInfo = charAdjMod(c.key);

    const details = document.createElement('details'); details.className='panel'; details.open = true;
    details.classList.add(c.skills.length >= 5 ? 'skill-5' : 'skill-4');
    const sum = document.createElement('summary'); sum.className='hdr';
    sum.innerHTML = `
      <strong>${c.name}</strong>
      <span class="pill">${c.code}</span>
      <span class="charac-badge mod-toggle" data-target="mods-char-${c.key}" title="${modInfo.notes.join('\n')}">[ <span class="total" id="${c.key}-total">${total}</span> | <span id="${c.key}-mod">${modInfo.mod>=0? '+'+modInfo.mod : modInfo.mod}</span> ]</span>
      <span class="grow"></span>
      <span class="k">Invested</span>
      <input type="number" class="num" min="0" id="${c.key}-invest" value="${investedChar}">
    `;
    details.appendChild(sum);

    const body = document.createElement('div'); body.className='panel-body';
    const skills = document.createElement('div'); skills.className='skills';

    for (const s of c.skills){
      const invested = investVal((rec.skills||{})[s], 0);
      const adj = skillAdjTotal(c.key, s);
      const investId = skillId(c.key, s, 'invest');
      const totalId = skillId(c.key, s, 'total');
      const line = document.createElement('div'); line.className='skill-line';
      line.innerHTML = `
        <div class="k">${s}</div>
        <input type="number" class="num" min="0" id="${investId}" value="${invested}">
        <div class="skill-total badge mod-toggle" data-target="mods-${totalId}" id="${totalId}" title="${adj.notes.join('\n')}">${adj.total>=0? '+'+adj.total : adj.total}</div>
      `;
      const noteList = setNotesList(`mods-${totalId}`, adj.notes);
      line.appendChild(noteList);
      skills.appendChild(line);
    }

    const charNotesList = setNotesList(`mods-char-${c.key}`, modInfo.notes);
    body.appendChild(charNotesList);
    body.appendChild(skills);
    details.appendChild(body);
    gridEl.appendChild(details);
  }

  // Intensities (scale with MAGIC)
  const intPanel = document.createElement('details'); intPanel.className='panel'; intPanel.open = true;
  intPanel.classList.add('intensities-panel');
  const intSummary = document.createElement('summary'); intSummary.className = 'hdr';
  intSummary.innerHTML = `<strong>Intensities</strong><span class="muted">(scale on MAGIC)</span>`;
  intPanel.appendChild(intSummary);
  const intBody = document.createElement('div'); intBody.className = 'panel-body';
  const intGrid = document.createElement('div'); intGrid.className = 'skills intensities-grid';
  intGrid.id = 'intensities-grid';
    INTENSITIES.forEach(n=>{
      const invested = investVal((CHAR.stats.intensities||{})[n], 0);
      const adj = skillAdjTotal('magic', n);
      const investId = `intensity-${n}-invest`;
      const totalId = `intensity-${n}-total`;
      const line = document.createElement('div'); line.className = 'intensity-line';
      line.innerHTML = `
        <div class="k">${n}</div>
        <input type="number" class="num" min="0" id="${investId}" value="${invested}">
        <div class="skill-total badge mod-toggle" data-target="mods-${totalId}" id="${totalId}" title="${adj.notes.join('\n')}">${adj.total>=0? '+'+adj.total : adj.total}</div>
      `;
    line.appendChild(setNotesList(`mods-${totalId}`, adj.notes));
    intGrid.appendChild(line);
  });
  intBody.appendChild(intGrid);
  intPanel.appendChild(intBody);
  gridEl.appendChild(intPanel);

  // Intensity listeners (once)
  INTENSITIES.forEach(n=>{
    const input = document.getElementById(`intensity-${n}-invest`);
    input.addEventListener('input', ()=>{
      const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
      const cap = skillMaxForLevel(lvl);
      const pool = skillPointPool(lvl);
      const currentVal = investVal(CHAR.stats.intensities?.[n], 0);
      const totalOther = totalSkillInvest() - currentVal;
      const desired = Math.max(0, Math.floor(investVal(input.value, 0)));
      const allowed = Math.max(0, pool - totalOther);
      const val = Math.min(desired, cap, allowed);
      input.value = val;
      CHAR.stats.intensities[n] = val;
      const adj = skillAdjTotal('magic', n);
      const totalId = `intensity-${n}-total`;
      document.getElementById(totalId).textContent = adj.total>=0? '+'+adj.total : adj.total;
      document.getElementById(totalId).title = adj.notes.join('\\n');
      setNotesList(`mods-${totalId}`, adj.notes);
      updatePointCounters();
      updateDerived();
      renderAddedSchools();
      queueSave();
    });
  });

  // Wire listeners
  for (const c of CHARACS){
    const input = document.getElementById(`${c.key}-invest`);
    input.addEventListener('input', ()=>{
      const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
      const pool = statPointPool(lvl);
      const currentVal = investVal(CHAR.stats[c.key].invest, 0);
      const totalOther = totalStatInvest() - currentVal;
      const desired = Math.max(0, Math.floor(investVal(input.value, 0)));
      const allowed = Math.max(0, pool - totalOther);
      const capInvest = statInvestCap(lvl);
      const val = Math.min(desired, allowed, capInvest);
      if (val !== desired) input.value = val;
      CHAR.stats[c.key].invest = val;

      // update characteristic header
      const total = totalFromInvest(val);
      const modInfo = charAdjMod(c.key);
      document.getElementById(`${c.key}-total`).textContent = total;
      document.getElementById(`${c.key}-mod`).textContent = (modInfo.mod>=0? '+'+modInfo.mod : modInfo.mod);
      document.querySelector(`#${c.key}-mod`).parentElement.title = modInfo.notes.join('\\n');
      setNotesList(`mods-char-${c.key}`, modInfo.notes);

      // update skill rows
      for (const s of c.skills){
        const adj = skillAdjTotal(c.key, s);
        const el = document.getElementById(skillId(c.key, s, 'total'));
        el.textContent = (adj.total>=0? '+'+adj.total : adj.total);
        el.title = adj.notes.join('\\n');
        setNotesList(`mods-${skillId(c.key, s, 'total')}`, adj.notes);
      }
      updatePointCounters();
      updateDerived();
      renderAddedSchools();
      queueSave();
    });

    for (const s of c.skills){
      const si = document.getElementById(skillId(c.key, s, 'invest'));
      si.addEventListener('input', ()=>{
        const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
        const cap = skillMaxForLevel(lvl);
        const pool = skillPointPool(lvl);
        const currentVal = investVal(CHAR.stats[c.key].skills?.[s], 0);
        const totalOther = totalSkillInvest() - currentVal;
        const desired = Math.max(0, Math.floor(investVal(si.value, 0)));
        const allowed = Math.max(0, pool - totalOther);
        const val = Math.min(desired, cap, allowed);
        if (val !== desired) si.value = val;
        CHAR.stats[c.key].skills[s] = val;
        const adj = skillAdjTotal(c.key, s);
        const el = document.getElementById(skillId(c.key, s, 'total'));
        el.textContent = (adj.total>=0? '+'+adj.total : adj.total);
        el.title = adj.notes.join('\\n');
        setNotesList(`mods-${skillId(c.key, s, 'total')}`, adj.notes);
        updatePointCounters();
        updateDerived();
        renderAddedSchools();
        queueSave();
      });
    }
  }
  updatePointCounters();
}
/* simple defense placeholder */
function renderDefenseSummary(){
  const box = document.getElementById('defense-summary');
  box.innerHTML = '<div class="muted">--</div>';
}

/* --------- PASSIVE on DERIVED (existing behavior) ---------- */
function applyPassiveModifiersToDerived(base, currentEnc = 0){
  const out = { ...base };
  out.current_enc = Number(currentEnc || 0);
  const notes = {
    hp: [`Base = ${base.hp}`],
    en: [`Base = ${base.en}`],
    fo: [`Base = ${base.fo}`],
    mo: [`Base = ${base.mo}`],
    et: [`Base = ${base.et}`],
    tx: [`Base = ${base.tx}`],
    enc:[`Base = ${base.enc}`],
    spcap:[],
    talent_max:[`Base = ${base.talent_max ?? 0}`]
  };
  notes.enc.unshift(`Current enc = ${Number(currentEnc||0).toFixed(1)}`);
  if (base._notes){
    Object.entries(base._notes).forEach(([k, arr])=>{
      if (notes[k]) notes[k].push(...arr);
    });
  }

  const ops = { set:[], mul:[], add:[] };
  const passiveAbilities = (ASSIGNED||[]).filter(a=>{
    const t = (a.type||'').toLowerCase();
    return t==='passive' || t==='mixed';
  });

  const allMods = [];
  for (const ab of passiveAbilities){
    const mods = resolvedPassiveMods(ab);
    for (const m of mods){
      allMods.push({
        target:(m.target || m.key || '').toLowerCase().trim(),
        mode:(m.mode||'add').toLowerCase(),
        val:modEffectiveValue(m),
        origin:`${ab.name}${m.note?` (${m.note})`:''}`
      });
    }
  }
  for (const m of getEquippedInventoryModifiers()){
    allMods.push({
      target:(m.target||'').toLowerCase(),
      mode:(m.mode||'add').toLowerCase(),
      val:modEffectiveValue(m),
      origin:m.origin
    });
  }
  for (const m of getSpellEffectModifiers()){
    allMods.push({
      target:(m.target||'').toLowerCase(),
      mode:(m.mode||'add').toLowerCase(),
      val:modEffectiveValue(m),
      origin:m.origin
    });
  }
  const { mods: subMods } = getSublimationEffects();
  for (const m of subMods){
    allMods.push({
      target:(m.target||'').toLowerCase(),
      mode:(m.mode||'add').toLowerCase(),
      val:modEffectiveValue(m),
      origin:m.origin
    });
  }

  const map = {
    'derived.hp':'hp','derived.en':'en','derived.fo':'fo','derived.mo':'mo',
    'derived.et':'et','derived.tx':'tx','derived.enc':'enc','derived.spcap':'spcap','derived.talent_max':'talent_max'
  };
  for (const m of allMods){
    if (map[m.target]){
      ops[m.mode]?.push({ k: map[m.target], v: m.val, origin: m.origin });
    }
  }

  // set -> mul -> add
  for (const op of ops.set){ out[op.k] = op.v; notes[op.k].push(`Set to ${op.v} -> ${op.origin}`); }
  for (const op of ops.mul){ const before = out[op.k]; out[op.k] = Math.round(before * op.v); notes[op.k].push(`*${op.v} (from ${before}) -> ${op.origin}`); }
  for (const op of ops.add){ out[op.k] = out[op.k] + op.v; notes[op.k].push(`${op.v>=0?'+':''}${op.v} -> ${op.origin}`); }

  // Recompute spcap off final HP, then apply any spcap-specific modifiers that were already added
  const baseSpcap = Math.floor(out.hp * 0.10);
  const spcapOps = {
    set: ops.set.filter(op=>op.k==='spcap'),
    mul: ops.mul.filter(op=>op.k==='spcap'),
    add: ops.add.filter(op=>op.k==='spcap'),
  };
  notes.spcap = [`Base = ${baseSpcap}`];
  out.spcap = baseSpcap;
  for (const op of spcapOps.set){ out.spcap = op.v; notes.spcap.push(`Set to ${op.v} -> ${op.origin}`); }
  for (const op of spcapOps.mul){ const before = out.spcap; out.spcap = Math.round(before * op.v); notes.spcap.push(`*${op.v} (from ${before}) -> ${op.origin}`); }
  for (const op of spcapOps.add){ out.spcap = out.spcap + op.v; notes.spcap.push(`${op.v>=0?'+':''}${op.v} -> ${op.origin}`); }

  TALENT_MAX = out.talent_max ?? base.talent_max ?? TALENT_MAX;

  // Tooltips with breakdown
  hpEl.title = notes.hp.join('\n');   setNotesList('mods-derived-hp', notes.hp);
  enEl.title = notes.en.join('\n');   setNotesList('mods-derived-en', notes.en);
  foEl.title = notes.fo.join('\n');   setNotesList('mods-derived-fo', notes.fo);
  moEl.title = notes.mo.join('\n');   setNotesList('mods-derived-mo', notes.mo);
  spcapEl.title = notes.spcap.join('\n'); setNotesList('mods-derived-spcap', notes.spcap);
  encEl.title = notes.enc.join('\n'); setNotesList('mods-derived-enc', notes.enc);
  etEl.title = notes.et.join('\n');   setNotesList('mods-derived-et', notes.et);
  txEl.title = notes.tx.join('\n');   setNotesList('mods-derived-tx', notes.tx);

  out.current_enc = Number(currentEnc || 0);
  out.enc_max = out.enc;
  return out;
}

/* Derived computations (use characteristic mods & skills that may be adjusted) */
function milestone(key){
  // milestone uses the **adjusted** characteristic mod (>=0)
  return Math.max(0, charAdjMod(key).mod);
}
function baseTalentMax(lvl){
  const levelVal = 1 + Math.floor((Math.max(1, lvl) - 1) / 10);
  return levelVal + milestone('tech') + milestone('wisdom');
}
function talentMax(){
  return TALENT_MAX || baseTalentMax(Math.max(1, Math.floor(Number(levelEl.value)||1)));
}
function talentCount(){
  return (ASSIGNED || []).filter(a=> (a.source_category || '').toLowerCase() === 'talent').length;
}
function updateTalentCounter(){
  if (!talentCounterEl) return;
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const base = 1 + Math.floor((lvl - 1) / 10);
  const msTec = milestone('tech');
  const msWis = milestone('wisdom');
  const max = talentMax();
  const count = talentCount();
  const over = count > max;
  talentCounterEl.textContent = `Talents: ${count} / ${max}`;
  talentCounterEl.style.color = over ? '#f66' : '';
  talentCounterEl.title = `Base ${base} + TEC milestone ${msTec} + WIS milestone ${msWis}`;
}
function skillTotalAdjustedFor(key, name){
  return skillAdjTotal(key, name).total;
}

function updateDerived(){
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const msBOD = milestone('body');
  const msWIL = milestone('willpower');
  const msMAG = milestone('magic');
  const msPRE = milestone('presence');
  const msREF = milestone('reflex');
  const msDEX = milestone('dexterity');
  const msWIS = milestone('wisdom');

  // Base
  const base = {};
  const msTEC = milestone('tech');
  base.hp = 39 + lvl + 12*msBOD + 6*msWIL;
  base.en = 5 + Math.floor(lvl/5) + msWIL + 2*msMAG;
  base.fo = 2 + Math.floor(lvl/5) + msWIL + (2*msPRE) + msWIS;
  base.mo = 4 + msDEX + msREF;
  base.spcap = Math.floor(base.hp * 0.10);
  base.enc = 10 + (10 * msBOD) + (5 * msWIL);
  const invEnc = LINKED_INV?.enc_total || 0;
  base.et = 1 + Math.floor(lvl/10) + msMAG;
  const etTech = 1 + Math.floor(lvl/10) + msTEC;
  base._notes = Object.assign(base._notes || {}, { et: [`Alt (TEC): ${etTech}`] });
  base.tx = 2 + msBOD + (2 * msTEC);
  base.talent_max = baseTalentMax(lvl);

  // Apply passive modifiers to derived
  const final = applyPassiveModifiersToDerived(base, invEnc);
  // Overrides
  const maxVals = { ...final };
  if (OVERRIDE_ENABLED){
    maxVals.hp = numOr(OVERRIDE_VALUES.hp ?? final.hp, final.hp);
    maxVals.en = numOr(OVERRIDE_VALUES.en ?? final.en, final.en);
    maxVals.fo = numOr(OVERRIDE_VALUES.fo ?? final.fo, final.fo);
    maxVals.mo = numOr(OVERRIDE_VALUES.mo ?? final.mo, final.mo);
    maxVals.spcap = numOr(OVERRIDE_VALUES.spcap ?? final.spcap, final.spcap);
    // allow overriding derived enc/et/tx if provided
    maxVals.enc = numOr(OVERRIDE_VALUES.enc ?? final.enc, final.enc);
    maxVals.et  = numOr(OVERRIDE_VALUES.et  ?? final.et, final.et);
    maxVals.tx  = numOr(OVERRIDE_VALUES.tx  ?? final.tx, final.tx);
  }else{
    // ensure all are finite
    Object.keys(maxVals).forEach(k=>{
      maxVals[k] = numOr(maxVals[k], 0);
    });
  }
  const cur = {
    hp: Math.max(0, Math.min(numOr(CURRENT.hp ?? maxVals.hp, maxVals.hp), maxVals.hp)),
    en: Math.max(0, Math.min(numOr(CURRENT.en ?? maxVals.en, maxVals.en), maxVals.en)),
    fo: Math.max(0, Math.min(numOr(CURRENT.fo ?? maxVals.fo, maxVals.fo), maxVals.fo)),
    sp: Math.max(0, Math.min(numOr(CURRENT.sp ?? maxVals.spcap, maxVals.spcap), maxVals.spcap)),
  };
  if (CURRENT.hp == null) cur.hp = maxVals.hp;
  if (CURRENT.en == null) cur.en = maxVals.en;
  if (CURRENT.fo == null) cur.fo = maxVals.fo;
  if (CURRENT.sp == null) cur.sp = maxVals.spcap;
  CURRENT = cur;
  if (curHpEl) curHpEl.value = cur.hp;
  if (curEnEl) curEnEl.value = cur.en;
  if (curFoEl) curFoEl.value = cur.fo;
  if (curSpEl) curSpEl.value = cur.sp;
  if (overrideInputsWrap) overrideInputsWrap.style.display = OVERRIDE_ENABLED ? 'grid' : 'none';
  [ [ovHpEl, maxVals.hp], [ovEnEl, maxVals.en], [ovFoEl, maxVals.fo], [ovMoEl, maxVals.mo], [ovSpEl, maxVals.spcap] ].forEach(([el,val])=>{
    if (!el) return;
    el.disabled = !OVERRIDE_ENABLED;
    if (OVERRIDE_ENABLED && (el.value==="" || Number.isNaN(Number(el.value)))) el.value = val;
    if (!OVERRIDE_ENABLED) el.value = '';
  });

  // Display
  hpEl.textContent = `${cur.hp} / ${maxVals.hp}`;
  enEl.textContent = `${cur.en} / ${maxVals.en}`;
  foEl.textContent = `${cur.fo} / ${maxVals.fo}`;
  moEl.textContent = maxVals.mo;
  spcapEl.textContent = `${cur.sp} / ${maxVals.spcap}`;
  encEl.textContent = `${Number(final.current_enc || 0).toFixed(1)} / ${maxVals.enc ?? final.enc}`;
  const etDisplay = (()=> {
    const etVal = maxVals.et ?? final.et;
    const etTech = 1 + Math.floor(lvl/10) + milestone('tech');
    return `${etVal} (TEC ${etTech})`;
  })();
  etEl.textContent = etDisplay;
  txEl.textContent = maxVals.tx ?? final.tx;
  updatePointCounters();
  renderAddedSchools();
  updateTalentCounter();
}

/* LOAD & SAVE */
async function loadCharacter(){
  if (!CID){ statusEl.textContent = 'Missing id'; return; }
  const res = await api('/characters/' + encodeURIComponent(CID));
  CHAR = res.character || {};
  if (!CHAR.stats) CHAR.stats = makeDefaultStats();
  if (!CHAR.stats.intensities) CHAR.stats.intensities = makeDefaultStats().intensities;
  setAddedSchools(CHAR.stats.selected_schools || []);
  XP = numOr(CHAR.xp, 0);
  const storedLevel = numOr(CHAR.level ?? CHAR.stats?.level, 0);
  const levelFromData = storedLevel || levelFromXp(XP) || 1;
  CHAR.level = Math.max(1, Math.min(MAX_LEVEL, Math.floor(levelFromData)));
  CHAR.xp = XP;
  CHAR.stats.level = CHAR.level;
  if (!Array.isArray(CHAR.abilities)) CHAR.abilities = [];
  ABILITY_CHOICES = CHAR.ability_choices || {};
  ITEM_CHOICES = CHAR.item_choices || {};
  SUBLIMATIONS = normalizeSublimations(CHAR.sublimations || []);
  if (!CHAR.archetype_id) CHAR.archetype_id = '';
  SELECTED_SPELL_LIST_ID = CHAR.spell_list_id || '';
  SELECTED_INV_ID = CHAR.inventory_id || '';
   COMPUTED_ARC_ABILITIES = CHAR.computed_archetype_abilities || [];
  CURRENT = Object.assign({hp:null,en:null,fo:null,sp:null}, CHAR.current || {});
  OVERRIDE_ENABLED = !!CHAR.override_stats?.enabled;
  OVERRIDE_VALUES = Object.assign({hp:null,en:null,fo:null,mo:null,spcap:null,enc:null,et:null,tx:null}, CHAR.override_stats?.values || {});
  if (overrideToggle) overrideToggle.checked = OVERRIDE_ENABLED;
  if (!CHAR.archetype_rank) CHAR.archetype_rank = _archetypeRankForLevel(CHAR.level);
  LINKED_SPELL_LIST = null;
  renderSpellListSummary();
  PERSONAL = CHAR.stats?.personal || {};
  fillPersonal();

  // Name
  titleEl.textContent = 'Edit: ' + (CHAR.name || '(unnamed)');
  nameEl.value = (CHAR.name || '').slice(0,22);
  nameEl.addEventListener('input', ()=>{
    if (nameEl.value.length > 22) nameEl.value = nameEl.value.slice(0,22);
    queueSave();
  });
  avatarPreview.src = `/characters/${encodeURIComponent(CID)}/avatar?ts=${Date.now()}`;

  // Level
  levelEl.value = Math.max(1, Number(CHAR.level)||1);
  levelEl.addEventListener('input', ()=>{
    const lvl = Math.max(1, Math.min(MAX_LEVEL, Math.floor(Number(levelEl.value)||1)));
    CHAR.level = lvl;
    if (XP < xpForLevel(lvl)) XP = xpForLevel(lvl);
    CHAR.xp = XP;
    CHAR.stats.level = CHAR.level;
    renderXpProgress();
    renderSublimations();
    updatePointCounters();
    updateDerived();
    queueSave();
  });
  renderXpProgress();

  renderSublimations();

  // Render stats/skills
  renderStatistics();
  updatePointCounters();

  // Resolve abilities â†’ recalc passive agg â†’ render abilities â†’ derived
  await resolveAssignedAbilities();
  recomputePassiveAgg();
  renderAbilitiesTab();
  // refresh visuals that depend on passive agg
  renderStatistics();
  updateDerived();
  await loadArchetypesList();
  renderArchetypePanel();
  await loadSpellListsList();
  if (SELECTED_SPELL_LIST_ID) await loadSpellListById(SELECTED_SPELL_LIST_ID);
  await loadInventoriesList();
  if (SELECTED_INV_ID) loadInventoryById(SELECTED_INV_ID);
  wirePersonal();
}

function queueSave(){
  statusEl.textContent = 'Saving...';
  if (SAVE_TIMER) clearTimeout(SAVE_TIMER);
  SAVE_TIMER = setTimeout(saveNow, 350);
}

async function deleteCharacter(){
  if (!CID) { alert('Missing character id.'); return; }
  const typed = prompt('Type "I CONFIRM" to delete this character. This cannot be undone.');
  if ((typed || '').trim() !== 'I CONFIRM') return;
  try{
    statusEl.textContent = 'Deleting...';
    const res = await fetch('/characters/' + encodeURIComponent(CID), {
      method:'DELETE',
      headers: authHeaders()
    });
    const j = await res.json().catch(()=>({}));
    if (j.status !== 'success') throw new Error(j.message || 'Delete failed');
    statusEl.textContent = 'Character deleted.';
    location.href = 'characters.html';
  }catch(e){
    statusEl.textContent = 'Delete failed: ' + e.message;
    alert(e.message);
  }
}

async function saveNow(){
  try{
    const payload = {
      name: nameEl.value || '',
      level: CHAR.level || 1,
      xp: Math.max(0, Math.floor(XP||0)),
      stats: { ...CHAR.stats, level: CHAR.level, selected_schools: Array.from(ADDED_SCHOOLS) },
      selected_schools: Array.from(ADDED_SCHOOLS),
      abilities: CHAR.abilities || [],
      ability_choices: ABILITY_CHOICES || {},
      item_choices: ITEM_CHOICES || {},
      inventory_id: SELECTED_INV_ID || '',
      spell_list_id: SELECTED_SPELL_LIST_ID || '',
      archetype_id: CHAR.archetype_id || '',
      sublimations: SUBLIMATIONS,
      current: CURRENT,
      override_stats: { enabled: OVERRIDE_ENABLED, values: OVERRIDE_VALUES }
    };
    const res = await api('/characters/' + encodeURIComponent(CID), {
      method:'PUT', headers:{ 'content-type':'application/json' }, body: JSON.stringify(payload)
    });
    titleEl.textContent = 'Edit: ' + (res.character?.name || '(unnamed)');
    statusEl.textContent = 'Saved at ' + new Date().toLocaleTimeString();
  }catch(err){
    statusEl.textContent = 'Save failed: ' + err.message;
  }
}

/* ------- Abilities: search/add/remove/render ------- */
function openAbilityAddModal(){
  if (!abiAddModal || !abiAddBackdrop) return;
  abiAddModal.classList.remove('hidden');
  abiAddModal.classList.add('open');
  abiAddBackdrop.classList.add('open');
  abiSearchEl?.focus();
}
function closeAbilityAddModal(){
  if (!abiAddModal || !abiAddBackdrop) return;
  abiAddModal.classList.add('hidden');
  abiAddModal.classList.remove('open');
  abiAddBackdrop.classList.remove('open');
}
async function searchAbilities(){
  try{
    const params = [];
    if (abiSearchEl.value) params.push('name='+encodeURIComponent(abiSearchEl.value));
    if (abiFilterTypeEl.value) params.push('typ='+encodeURIComponent(abiFilterTypeEl.value));
    if (abiFilterSrcEl.value) params.push('source='+encodeURIComponent(abiFilterSrcEl.value));
    const qs = params.length ? '?'+params.join('&') : '';
    const res = await api('/abilities'+qs);
    const arr = res.abilities || [];
    renderSearchResults(arr);
  }catch(e){
    abiResultsEl.innerHTML = `<div class="muted">Error: ${e.message}</div>`;
  }
}
abiSearchBtn.addEventListener('click', searchAbilities);
abiSearchEl.addEventListener('keydown', (e)=>{ if (e.key==='Enter') searchAbilities(); });
abiOpenAddBtn?.addEventListener('click', openAbilityAddModal);
abiAddClose?.addEventListener('click', closeAbilityAddModal);
abiAddCancel?.addEventListener('click', closeAbilityAddModal);
abiAddBackdrop?.addEventListener('click', (e)=>{ if (e.target===abiAddBackdrop) closeAbilityAddModal(); });
deleteBtn?.addEventListener('click', deleteCharacter);

invLoadBtn.addEventListener('click', ()=> loadInventoryById(invSelectEl.value));
invSelectEl.addEventListener('change', ()=> loadInventoryById(invSelectEl.value));
invCreateBtn?.addEventListener('click', createInventoryAndLink);
invDupLinkBtn?.addEventListener('click', duplicateAndLinkInventory);
invAddContBtn.addEventListener('click', invAddContainer);
invFundOpenBtn?.addEventListener('click', ()=>{ invFundStatus.textContent=''; invToggleModal(invFundModal, invFundBackdrop, true); });
invFundClose?.addEventListener('click', ()=> invToggleModal(invFundModal, invFundBackdrop, false));
invFundCancel?.addEventListener('click', ()=> invToggleModal(invFundModal, invFundBackdrop, false));
invFundBackdrop?.addEventListener('click', (e)=>{ if (e.target===invFundBackdrop) invToggleModal(invFundModal, invFundBackdrop, false); });
invFundSave?.addEventListener('click', invAddFunds);
invCatalogOpenBtn?.addEventListener('click', ()=> invToggleModal(invCatalogModal, invCatalogBackdrop, true));
invCatalogClose?.addEventListener('click', ()=> invToggleModal(invCatalogModal, invCatalogBackdrop, false));
invCatalogBackdrop?.addEventListener('click', (e)=>{ if (e.target===invCatalogBackdrop) invToggleModal(invCatalogModal, invCatalogBackdrop, false); });
invSearchBtn.addEventListener('click', invDoSearch);
invClearBtn.addEventListener('click', invClearSearch);
invCatEl.addEventListener('change', ()=>{
  const val = invCatEl.value;
  INV_FILTERED = val && val !== "__all" ? INV_LAST_RESULTS.filter(r=>invGetRowCategory(r)===val) : INV_LAST_RESULTS.slice();
  invRenderResults();
});
invKindEl.addEventListener('change', invClearSearch);
document.getElementById('inv-item-close').addEventListener('click', closeInvItemModal);
invItemBackdrop.addEventListener('click', (e)=>{ if (e.target===invItemBackdrop) closeInvItemModal(); });

arcApplyBtn.addEventListener('click', async ()=>{
  const arcId = arcSelectEl.value || '';
  try{
    arcStatusEl.textContent = 'Saving archetype...';
    const res = await api('/characters/' + encodeURIComponent(CID), {
      method:'PUT',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ archetype_id: arcId, stats: CHAR.stats })
    });
    CHAR.archetype_id = arcId;
    CHAR.archetype_rank = _archetypeRankForLevel(CHAR.level);
    CHAR.computed_archetype_abilities = res.character?.computed_archetype_abilities || [];
    COMPUTED_ARC_ABILITIES = CHAR.computed_archetype_abilities;
    renderArchetypePanel();
    arcStatusEl.textContent = 'Archetype saved.';
  }catch(e){
    arcStatusEl.textContent = 'Save failed: ' + e.message;
  }
});

slLoadBtn.addEventListener('click', ()=> loadSpellListById(slSelectEl.value));
slSelectEl.addEventListener('change', ()=> loadSpellListById(slSelectEl.value));
slCreateBtn?.addEventListener('click', createAndLinkSpellList);
slDupBtn.addEventListener('click', duplicateAndLinkSpellList);
slOpenAddBtn.addEventListener('click', openSpellAddModal);
slAddClose.addEventListener('click', closeSpellAddModal);
slAddCancel.addEventListener('click', closeSpellAddModal);
slAddBackdrop.addEventListener('click', (e)=>{ if (e.target===slAddBackdrop) closeSpellAddModal(); });
slAddMenuBtn?.addEventListener('click', ()=>{
  if (!slAddMenu) return;
  const shown = slAddMenu.style.display !== 'none';
  slAddMenu.style.display = shown ? 'none' : 'flex';
});
slQuickAddBtn?.addEventListener('click', ()=>{ if (slAddMenu) slAddMenu.style.display = 'none'; quickAddSchools(); });
slManualAddBtn?.addEventListener('click', ()=>{ if (slAddMenu) slAddMenu.style.display = 'none'; openManualAddModal(); });
slSchApply?.addEventListener('click', applyManualAdd);
slSchCancel?.addEventListener('click', ()=> toggleSchoolModal(false));
slSchClose?.addEventListener('click', ()=> toggleSchoolModal(false));
slSchBackdrop?.addEventListener('click', (e)=>{ if (e.target===slSchBackdrop) toggleSchoolModal(false); });
xpAddBtn?.addEventListener('click', ()=>{
  const raw = prompt('Add how much XP?', '100');
  if (raw === null) return;
  const val = Math.floor(Number(raw)||0);
  if (val > 0) addXp(val);
});
levelSetBtn?.addEventListener('click', ()=>{
  const raw = prompt('Set level (1-100)', String(CHAR.level||1));
  if (raw === null) return;
  const val = Math.max(1, Math.min(MAX_LEVEL, Math.floor(Number(raw)||1)));
  setLevelManual(val);
});
slSearchBtn.addEventListener('click', renderSpellSearch);
slSearchQ.addEventListener('keydown', (e)=>{ if (e.key==='Enter') renderSpellSearch(); });

function renderSearchResults(arr){
  abiResultsEl.innerHTML = '';
  if (!arr.length){ abiResultsEl.innerHTML = '<div class="muted">No results.</div>'; return; }
  for (const a of arr){
    const div = document.createElement('div');
    div.className = 'abi-item';
    div.innerHTML = `
      <div class="grow">
        <div><strong>${a.name}</strong></div>
        <div class="muted" style="font-size:.85rem">${a.description||''}</div>
      </div>
      <span class="tag">${a.type||''}</span>
      <span class="tag">${a.source_category||''}</span>
      <button>Add</button>
    `;
    div.querySelector('button').addEventListener('click', ()=> addAbilityToChar(a.id));
    abiResultsEl.appendChild(div);
  }
}

async function resolveAssignedAbilities(){
  const ids = (CHAR.abilities||[]);
  if (!ids.length){ ASSIGNED = []; return; }
  const uniqueIds = Array.from(new Set(ids));
  const qs = '?ids=' + encodeURIComponent(uniqueIds.join(','));
  const bulk = await api('/abilities/bulk'+qs);
  const byId = {};
  (bulk.abilities||[]).forEach(a=>{ if (a && a.id) byId[a.id] = a; });
  ASSIGNED = ids.map(id=> byId[id]).filter(Boolean); // preserve order and duplicates
}
function abilityHasChoice(ab){
  return !!((ab?.passive?.modifiers||[]).find(m=> String(m.target||'').startsWith('choice:') || (m.group || '').trim()));
}
function skillOptionsList(){
  const out = [];
  for (const c of CHARACS){
    for (const s of c.skills){
      out.push({ key:`skills.${c.key}.${s}`, label:`${s} (${c.name})`, charKey:c.key });
    }
  }
  return out;
}
function charKeyForSkillName(name){
  const norm = normSkillKey(name);
  if (SKILL_TO_CHAR[norm]) return SKILL_TO_CHAR[norm];
  const lcName = String(name||'').toLowerCase();
  const hit = CHARACS.find(c=> (c.skills||[]).some(s=> String(s||'').toLowerCase() === lcName));
  return hit ? hit.key : '';
}
async function choiceItemsForKind(kind, restrict, allowed){
  const rset = new Set((restrict||[]).map(x=> String(x).trim().toLowerCase()));
  const aset = new Set((allowed||[]).map(x=> String(x).trim().toLowerCase()));
  const useAllow = aset.size > 0;
  const isRestricted = (...cands)=>{
    for (const c of cands){
      if (c == null) continue;
      const base = String(c).trim().toLowerCase();
      if (!base) continue;
      if (rset.has(base)) return true;
      const noPrefix = base.replace(/^(skills|schools|intensities)\./,'');
      if (rset.has(noPrefix)) return true;
      const beforeParen = base.split('(')[0].trim();
      if (beforeParen && rset.has(beforeParen)) return true;
      const noDots = noPrefix.replace(/[\\.\\s]+/g,'');
      if (noDots && rset.has(noDots)) return true;
    }
    return false;
  };
  const isAllowed = (...cands)=>{
    if (!useAllow) return true;
    for (const c of cands){
      if (c == null) continue;
      const base = String(c).trim().toLowerCase();
      if (!base) continue;
      if (aset.has(base)) return true;
      const noPrefix = base.replace(/^(skills|schools|intensities)\./,'');
      if (aset.has(noPrefix)) return true;
    }
    return false;
  };
  if (kind === 'skill_ms'){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const skillsWithSchools = new Set(
      (SCHOOLS || [])
        .filter(s=> s.linked_skill)
        .map(s=> normSkillKey(s.linked_skill))
    );
    if (!skillsWithSchools.size) return [];
    return skillOptionsList().filter(o=>{
      const skillName = (o.label || '').split('(')[0].trim();
      const norm = normSkillKey(skillName);
      if (skillsWithSchools.size && !skillsWithSchools.has(norm)) return false;
      return !isRestricted(o.key, o.label, o.charKey, norm, skillName);
    });
  }
  if (kind === 'char_skill'){
    return skillOptionsList().filter(o=>{
      const skillName = (o.label || '').split('(')[0].trim();
      const norm = normSkillKey(skillName);
      if (!isAllowed(o.key, o.label, o.charKey, norm, skillName)) return false;
      return !isRestricted(o.charKey, skillName, norm, o.key, o.label);
    });
  }
  const charGroup = kind.match(/^skills\.by_char\.(.+)$/i);
  if (charGroup){
    const key = charGroup[1].toLowerCase();
    const hit = CHARACS.find(c=> c.key === key);
    if (!hit) return [];
    return (hit.skills || []).map(sk=>({ key:`skills.${key}.${sk}`, label:`${sk} (${hit.name||hit.label||key})` })).filter(o=>{
      const skillName = (o.label || '').split('(')[0].trim();
      const norm = normSkillKey(skillName);
      if (!isAllowed(o.key, o.label, key, norm, skillName)) return false;
      return !isRestricted(o.key, o.label, key, norm, skillName);
    });
  }
  if (kind === 'nature_ms' || kind === 'magic_weapon' || kind === 'magic_spell'){
    if (kind === 'nature_ms' && !SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const linkedNatures = new Set();
    if (kind === 'nature_ms' && SCHOOLS.length){
      (SCHOOLS||[]).forEach(s=> (s.linked_intensities||[]).forEach(n=> linkedNatures.add(lc(n))));
    }
    return INTENSITIES.map(n=>({ key:`intensities.${n}`, label:n })).filter(o=>{
      const base = lc(o.label);
      if (kind === 'nature_ms' && linkedNatures.size && !linkedNatures.has(base)) return false;
      if (!isAllowed(o.key, o.label, base)) return false;
      return !isRestricted(o.label, o.key, base);
    });
  }
  if (kind === 'intensity_any'){
    return INTENSITIES.map(n=>({ key:`intensities.${n}`, label:n })).filter(o=> !isRestricted(o.key, o.label));
  }
  const schoolSkill = kind.match(/^schools\.by_skill\.(.+)$/i);
  if (schoolSkill){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const skillName = schoolSkill[1];
    return (SCHOOLS||[]).filter(s=> String(s.linked_skill || '').toLowerCase() === String(skillName).toLowerCase())
      .map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||'simple'})` }))
      .filter(o=>{
        const baseLabel = (o.label || '').split('(')[0].trim().toLowerCase();
        const rawId = String(o.key||'').replace(/^schools\./i,'');
        if (!isAllowed(o.key, baseLabel, rawId)) return false;
        return !isRestricted(o.label, o.key, baseLabel, rawId);
      });
  }
  const schoolNature = kind.match(/^schools\.by_nature\.(.+)$/i);
  if (schoolNature){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const nature = schoolNature[1];
    return (SCHOOLS||[]).filter(s=> (s.linked_intensities || []).some(n=> String(n).toLowerCase() === String(nature).toLowerCase()))
      .map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||'simple'})` }))
      .filter(o=>{
        const baseLabel = (o.label || '').split('(')[0].trim().toLowerCase();
        const rawId = String(o.key||'').replace(/^schools\./i,'');
        if (!isAllowed(o.key, baseLabel, rawId)) return false;
        return !isRestricted(o.label, o.key, baseLabel, rawId);
      });
  }
  if (kind === 'school_ms' || kind === 'school_any'){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    return (SCHOOLS||[]).map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||'simple'})` })).filter(o=>{
      const baseLabel = (o.label || '').split('(')[0].trim().toLowerCase();
      const rawId = String(o.key||'').replace(/^schools\./i,'');
      if (!isAllowed(o.key, baseLabel, rawId)) return false;
      return !isRestricted(o.label, o.key, baseLabel, rawId);
    });
  }
  return [];
}

async function openGroupModal(ab){
  const groups = abilityGroups(ab);
  if (!groups.length) return false;
  try{ if (!SCHOOLS.length) await fetchSchools(); }catch{}
  const stored = abilityGroupSelections(ab);

  choiceTitle.textContent = `Configure: ${ab.name || 'Ability'}`;
  choiceBody.innerHTML = '';
  choiceModal.classList.remove('hidden'); choiceModal.classList.add('open'); choiceBackdrop.classList.add('open');

  const blocks = [];
  groups.forEach(g=>{
    const allowedIdx = g.options.map(o=> o.idx);
    const max = g.max || 1;
    const block = document.createElement('div');
    block.className = 'panel';
    const maxLabel = max > 0 ? `max ${max}` : 'no limit';
    block.innerHTML = `<strong>${g.name}</strong> <span class=\"muted\">(${maxLabel})</span>`;
    const list = document.createElement('div');
    list.style.display = 'grid';
    list.style.gridTemplateColumns = 'repeat(auto-fit,minmax(240px,1fr))';
    list.style.gap = '6px';
    const counter = document.createElement('div');
    counter.className = 'muted';
    counter.style.marginTop = '6px';

    const savedArr = Array.isArray(stored[g.name]) ? stored[g.name] : [];
    let selected = new Set(savedArr.map(x=> Number(x)).filter(i=> allowedIdx.includes(i)));
    if (!selected.size){
      const limit = max > 0 ? max : allowedIdx.length;
      allowedIdx.slice(0, limit).forEach(i=> selected.add(i));
    }

    const updateCounter = ()=>{
      const checked = list.querySelectorAll(`input[data-group=\"${g.name}\"]:checked`).length;
      counter.textContent = `Selected ${checked}${max>0?` / ${max}`:''}`;
    };

    g.options.forEach(opt=>{
      const row = document.createElement('label');
      row.style.display = 'flex';
      row.style.gap = '8px';
      row.style.alignItems = 'center';
      row.style.margin = '2px 0';
      const input = document.createElement('input');
      input.type = max === 1 ? 'radio' : 'checkbox';
      input.name = `group-${g.name}`;
      input.dataset.group = g.name;
      input.value = String(opt.idx);
      input.checked = selected.has(opt.idx);
      input.addEventListener('change', ()=>{
        const checked = list.querySelectorAll(`input[data-group=\"${g.name}\"]:checked`);
        if (max === 1){
          checked.forEach(cb=>{ if (cb !== input) cb.checked = false; });
        }else if (max > 0 && checked.length > max){
          input.checked = false;
        }
        updateCounter();
      });
      row.appendChild(input);
      const span = document.createElement('span');
      span.textContent = `${prettyTargetLabel(opt.mod.target)} (${(opt.mod.mode||'add')} ${opt.mod.value>=0?'+':''}${opt.mod.value})`;
      row.appendChild(span);
      list.appendChild(row);
    });

    block.appendChild(list);
    block.appendChild(counter);
    updateCounter();
    blocks.push({ group:g.name, max, node:list, counter });
    choiceBody.appendChild(block);
  });

  return new Promise(resolve=>{
    const close = ()=>{
      choiceModal.classList.add('hidden'); choiceModal.classList.remove('open'); choiceBackdrop.classList.remove('open');
      resolve(false);
    };
    const save = ()=>{
      const selections = {};
      for (const b of blocks){
        const picks = Array.from(b.node.querySelectorAll('input[data-group]')).filter(cb=> cb.checked).map(cb=> Number(cb.value));
        if (!picks.length){
          alert(`Select at least one option for ${b.group}.`);
          return;
        }
        if (b.max > 0 && picks.length > b.max){
          alert(`Select at most ${b.max} option(s) for ${b.group}.`);
          return;
        }
        selections[b.group] = picks;
      }
      setAbilityGroupSelections(ab.id, selections);
      queueSave();
      recomputePassiveAgg(); renderStatistics(); updateDerived();
      choiceModal.classList.add('hidden'); choiceModal.classList.remove('open'); choiceBackdrop.classList.remove('open');
      resolve(true);
    };
    choiceClose.onclick = close;
    choiceCancel.onclick = close;
    choiceBackdrop.onclick = (e)=>{ if (e.target===choiceBackdrop) close(); };
    choiceSave.onclick = save;
  });
}

async function openChoiceModalGeneric(mods, existingMap = {}, saveHandler = ()=>{}, { titleText = 'Configure choices', entityLabel = '' } = {}){
  if (!mods.length) return false;
  try{ if (!SCHOOLS.length) await fetchSchools(); }catch{}
  choiceTitle.textContent = titleText || 'Configure choices';
  choiceBody.innerHTML = '<div class="muted">Loading choices...</div>';
  choiceModal.classList.remove('hidden'); choiceModal.classList.add('open'); choiceBackdrop.classList.add('open');

  const blocks = [];
  choiceBody.innerHTML = '';

  const normalizeMsBase = (kind, picks)=>{
    if (!picks || !picks.length || !SCHOOLS.length) return '';
    const first = String(picks[0]||'').replace(/^schools\./i, '');
    const school = (SCHOOLS||[]).find(s=> String(s.id||'').toLowerCase() === first.toLowerCase() || String(s.name||'').toLowerCase() === first.toLowerCase());
    if (!school) return '';
    if (kind === 'skill_ms' && school.linked_skill){
      const ck = charKeyForSkillName(school.linked_skill);
      return ck ? `skills.${ck}.${school.linked_skill}` : '';
    }
    if (kind === 'nature_ms'){
      const n = (school.linked_intensities || [])[0];
      return n ? `intensities.${n}` : '';
    }
    return '';
  };
  const buildMsBaseOptions = (kind, restrict=[])=>{
    const rset = new Set((restrict||[]).map(x=> String(x).toLowerCase()));
    if (kind === 'skill_ms'){
      const map = new Map();
      (SCHOOLS||[]).forEach(s=>{
        if (!s.linked_skill) return;
        const ck = charKeyForSkillName(s.linked_skill);
        if (!ck) return;
        const norm = normSkillKey(s.linked_skill);
        if (rset.has(norm) || rset.has(lc(s.linked_skill)) || rset.has(ck.toLowerCase())) return;
        const key = `skills.${ck}.${s.linked_skill}`;
        const list = map.get(key) || [];
        list.push(s.name || s.id);
        map.set(key, list);
      });
      return Array.from(map.entries()).map(([key, schools])=>{
        const parts = key.split('.');
        const skillName = parts.slice(2).join('.');
        const ck = parts[1] || '';
        const label = `${skillName} (${title(ck)}) - Schools: ${Array.from(new Set(schools)).join(', ')}`;
        return { key, label };
      }).sort((a,b)=> a.label.localeCompare(b.label));
    }
    if (kind === 'nature_ms'){
      const map = new Map();
      (SCHOOLS||[]).forEach(s=>{
        (s.linked_intensities || []).forEach(n=>{
          const norm = lc(n);
          if (rset.has(norm) || rset.has(`intensities.${norm}`)) return;
          const key = `intensities.${n}`;
          const list = map.get(key) || [];
          list.push(s.name || s.id);
          map.set(key, list);
        });
      });
      return Array.from(map.entries()).map(([key, schools])=>{
        const label = `${key.replace(/^intensities\./i,'')} - Schools: ${Array.from(new Set(schools)).join(', ')}`;
        return { key, label };
      }).sort((a,b)=> a.label.localeCompare(b.label));
    }
    return [];
  };
  const schoolsForMsBase = (kind, baseKey, restrict=[])=>{
    if (!baseKey) return [];
    const rset = new Set((restrict||[]).map(x=> String(x).toLowerCase()));
    const matches = (SCHOOLS||[]).filter(s=>{
      if (kind === 'skill_ms'){
        const skillName = baseKey.split('.').slice(2).join('.');
        return lc(s.linked_skill) === lc(skillName);
      }
      if (kind === 'nature_ms'){
        const nature = baseKey.replace(/^intensities\./i,'');
        return (s.linked_intensities || []).some(n=> lc(n) === lc(nature));
      }
      return false;
    });
    return matches.map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||'simple'})` })).filter(opt=>{
      const base = (opt.label || '').split('(')[0].trim().toLowerCase();
      const key = String(opt.key||'').toLowerCase();
      const plain = key.replace(/^schools\./i,'');
      return !(rset.has(base) || rset.has(key) || rset.has(plain));
    });
  };

  for (const m of mods){
    const kind = String(m.target||'').replace('choice:','');
    const restrict = normalizeRestrict(m);
    const allowed = normalizeChoiceAllowed(m);
    const max = Number(m.choice?.max_choices||0);
    const block = document.createElement('div');
    block.className = 'panel';
    const title = document.createElement('div');
    const srcNote = m.__source ? `<div class="muted" style="font-size:0.85rem;">${m.__source}</div>` : '';
    title.innerHTML = `<strong>${kind.replace(/_/g,' ')}</strong> <span class="muted">(max ${max||'no limit'})</span>${srcNote}`;
    block.appendChild(title);

    if (kind === 'skill_ms' || kind === 'nature_ms'){
      const state = normalizeChoiceEntry(existingMap[kind]);
      const baseOpts = buildMsBaseOptions(kind, restrict);
      const baseWrap = document.createElement('div');
      baseWrap.className = 'row';
      const baseLabel = document.createElement('label');
      baseLabel.className = 'muted';
      baseLabel.textContent = kind === 'skill_ms' ? 'Select skill' : 'Select nature';
      const baseSelect = document.createElement('select');
      baseSelect.innerHTML = '<option value="">-- choose --</option>';
      baseOpts.forEach(opt=>{
        const o = document.createElement('option');
        o.value = opt.key; o.textContent = opt.label;
        baseSelect.appendChild(o);
      });
      const inferredBase = state.base || normalizeMsBase(kind, state.picks);
      if (inferredBase && baseOpts.some(o=> o.key === inferredBase)){
        baseSelect.value = inferredBase;
      }
      baseWrap.appendChild(baseLabel);
      baseWrap.appendChild(baseSelect);

      const schoolsWrap = document.createElement('div');
      schoolsWrap.className = 'choice-wrap';
      schoolsWrap.style.display = 'grid';
      schoolsWrap.style.gridTemplateColumns = 'repeat(auto-fit,minmax(220px,1fr))';
      schoolsWrap.style.gap = '8px';

      const counter = document.createElement('div');
      counter.className = 'muted';
      counter.style.marginTop = '4px';

      const renderSchools = ()=>{
        schoolsWrap.innerHTML = '';
        const baseVal = baseSelect.value;
        if (!baseVal){
          const hint = document.createElement('div'); hint.className='muted'; hint.textContent='Choose a base option to see linked schools.'; schoolsWrap.appendChild(hint); counter.textContent='Selected 0'; return;
        }
        const schools = schoolsForMsBase(kind, baseVal, restrict);
        if (!schools.length){
          const empty = document.createElement('div'); empty.className='muted'; empty.textContent='No schools linked to that choice.'; schoolsWrap.appendChild(empty); counter.textContent='Selected 0'; return;
        }
        const picked = new Set(state.picks || []);
        schools.forEach(opt=>{
          const row = document.createElement('label');
          row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.margin='2px 0';
          const cb = document.createElement('input');
          cb.type='checkbox'; cb.dataset.kind = kind; cb.value = opt.key;
          cb.checked = picked.has(opt.key);
          row.appendChild(cb);
          const span = document.createElement('span'); span.textContent = opt.label; row.appendChild(span);
          cb.addEventListener('change', ()=>{
            const checked = schoolsWrap.querySelectorAll('input[type="checkbox"][data-kind]:checked').length;
            counter.textContent = `Selected ${checked}${max>0?` / ${max}`:''}`;
          });
          schoolsWrap.appendChild(row);
        });
        const hint = document.createElement('div'); hint.className='muted'; hint.textContent = max > 0 ? `Select up to ${max} school(s).` : 'Select any number of schools.'; schoolsWrap.appendChild(hint);
        const checked = schoolsWrap.querySelectorAll('input[type="checkbox"][data-kind]:checked').length;
        counter.textContent = `Selected ${checked}${max>0?` / ${max}`:''}`;
      };
      baseSelect.addEventListener('change', ()=>{ state.picks = []; renderSchools(); });
      renderSchools();

      block.appendChild(baseWrap);
      block.appendChild(schoolsWrap);
      block.appendChild(counter);

      blocks.push({
        kind,
        type:'ms',
        getValue: ()=>{
          const baseVal = baseSelect.value;
          if (!baseVal){
            alert('Select a base option first.');
            return { ok:false };
          }
          const checks = Array.from(schoolsWrap.querySelectorAll('input[type="checkbox"][data-kind]'));
          const selected = checks.filter(cb=>cb.checked).map(cb=>cb.value);
          if (!selected.length){
            alert('Select at least one school.');
            return { ok:false };
          }
          if (max > 0 && selected.length > max){
            alert(`Select at most ${max} option(s) for ${kind.replace(/_/g,' ')}.`);
            return { ok:false };
          }
          return { ok:true, value:{ base: baseVal, picks: selected } };
        }
      });
      choiceBody.appendChild(block);
      continue;
    }

    const items = await choiceItemsForKind(kind, restrict, allowed);
    if (!items.length){
      const empty = document.createElement('div'); empty.className='muted'; empty.textContent='No options available.'; block.appendChild(empty);
    }else{
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(auto-fit,minmax(240px,1fr))';
      grid.style.gap = '6px';
      const counter = document.createElement('div'); counter.className='muted'; counter.style.marginTop='6px';
      const updateCounter = ()=>{
        const checked = block.querySelectorAll('input[type="checkbox"][data-kind]:checked').length;
        counter.textContent = `Selected ${checked}${max>0?` / ${max}`:''}`;
      };
      items.forEach(opt=>{
        const row = document.createElement('label');
        row.style.display='flex'; row.style.gap='8px'; row.style.alignItems='center'; row.style.margin='2px 0';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.dataset.kind = kind; cb.value = opt.key;
        if (normalizeChoiceEntry(existingMap[kind]).picks.includes(opt.key)) cb.checked = true;
        cb.addEventListener('change', updateCounter);
        row.appendChild(cb);
        const span = document.createElement('span'); span.textContent = opt.label; row.appendChild(span);
        grid.appendChild(row);
      });
      block.appendChild(grid);
      block.appendChild(counter);
      updateCounter();
    }
    blocks.push({ kind, type:'simple', node: block, max });
    choiceBody.appendChild(block);
  }

  return new Promise(resolve=>{
    const close = ()=>{
      choiceModal.classList.add('hidden'); choiceModal.classList.remove('open'); choiceBackdrop.classList.remove('open');
      resolve(false);
    };
    const save = ()=>{
      const selections = {};
      for (const b of blocks){
        if (b.type === 'ms'){
          const res = b.getValue();
          if (!res.ok) return;
          selections[b.kind] = res.value;
          continue;
        }
        const boxes = b.node.querySelectorAll('input[type="checkbox"][data-kind]');
        const arr = [];
        boxes.forEach(box=>{ if (box.checked) arr.push(box.value); });
        if (b.max > 0 && arr.length > b.max){
          alert(`Select at most ${b.max} option(s) for ${b.kind.replace(/_/g,' ')}.`);
          return;
        }
        selections[b.kind] = arr;
      }
      saveHandler(selections);
      choiceModal.classList.add('hidden'); choiceModal.classList.remove('open'); choiceBackdrop.classList.remove('open');
      resolve(true);
    };
    choiceClose.onclick = close;
    choiceCancel.onclick = close;
    choiceBackdrop.onclick = (e)=>{ if (e.target===choiceBackdrop) close(); };
    choiceSave.onclick = save;
  });
}

// Ability choice modal wrapper
async function openChoiceModal(ab){
  const hasGroups = abilityGroups(ab).length > 0;
  let opened = false;
  if (hasGroups){
    const res = await openGroupModal(ab);
    opened = opened || res;
  }
  const { active: activeGroups } = resolveGroupSelections(ab);
  const choiceMods = (ab.passive?.modifiers||[]).map((m, idx)=>({ ...m, __idx: idx }))
    .filter(m=> {
      if (!String(m.target||'').startsWith('choice:')) return false;
      const grouped = (m.group || '').trim();
      if (!grouped) return true;
      return activeGroups.has(m.__idx);
    });
  if (choiceMods.length){
    const res = await openChoiceModalGeneric(choiceMods, ABILITY_CHOICES[ab.id] || {}, (selections)=>{
      const existing = ABILITY_CHOICES[ab.id] || {};
      ABILITY_CHOICES[ab.id] = { ...existing, ...selections, _groups: existing._groups || {} };
      queueSave();
      recomputePassiveAgg(); renderStatistics(); updateDerived();
    }, { titleText: `Configure: ${ab.name || 'Ability'}` });
    opened = opened || res;
  }
  return opened;
}

// Inventory item choice modal wrapper
async function openItemChoiceModal(it){
  const mods = itemChoiceMods(it);
  if (!mods.length) return false;
  const key = itemChoiceKey(it);
  return openChoiceModalGeneric(mods, ITEM_CHOICES[key] || {}, (selections)=>{
    if (!key) return;
    ITEM_CHOICES[key] = selections;
    queueSave();
    recomputePassiveAgg(); renderStatistics(); updateDerived();
  }, { titleText: `Configure: ${it.alt_name || it.name || 'Item'}` });
}

async function addAbilityToChar(aid){
  if (!Array.isArray(CHAR.abilities)) CHAR.abilities = [];
  CHAR.abilities.push(aid);
  queueSave();
  await resolveAssignedAbilities();
  const ab = ASSIGNED.find(x=>x.id===aid);
  if (ab && abilityHasChoice(ab)){
    await openChoiceModal(ab);
  }
  recomputePassiveAgg();
  renderAbilitiesTab();
  renderStatistics();
  updateDerived();
}

async function removeAbilityFromChar(aid){
  const arr = CHAR.abilities || [];
  const idx = arr.indexOf(aid);
  if (idx >= 0) arr.splice(idx, 1);
  CHAR.abilities = arr;
   if (ABILITY_CHOICES[aid]) delete ABILITY_CHOICES[aid];
  queueSave();
  await resolveAssignedAbilities();
  recomputePassiveAgg();
  renderAbilitiesTab();
  renderStatistics();
  updateDerived();
}

function renderAbilitiesBucket(el, list){
  if (!el) return;
  el.innerHTML = '';
  if (!list.length){ el.innerHTML = '<div class="muted">--</div>'; return; }
  for (const a of list){
    const div = document.createElement('div');
    div.className = 'abi-item';
    const isPassive = (a.type||'').toLowerCase()!=='active';
    const hasChoice = abilityHasChoice(a);
    const desc = isPassive ? (a.passive?.description||a.description||'') : (a.description||'');
    div.innerHTML = `
      <div class="grow">
        <div><strong>${a.name}</strong></div>
        <div class="muted" style="font-size:.85rem">${desc}</div>
      </div>
      <span class="tag">${a.type||''}</span>
      <span class="tag">${a.source_category||''}</span>
      <div class="row" style="gap:6px; flex-wrap:wrap;">
        ${hasChoice ? '<button class="btn small mod-config" title="Configure choices">Configure</button>' : ''}
        <button class="btn small mod-remove" title="Remove">×</button>
      </div>
    `;
    div.querySelector('.mod-remove')?.addEventListener('click', ()=> removeAbilityFromChar(a.id));
    if (hasChoice){
      div.querySelector('.mod-config')?.addEventListener('click', ()=> openChoiceModal(a));
    }
    el.appendChild(div);
  }
}

function renderAbilitiesTab(){
  const docs = ASSIGNED.slice();
  const passive   = docs.filter(a=> ((a.type||'').toLowerCase()!=='active'));
  const active    = docs.filter(a=> ((a.type||'').toLowerCase()==='active'));

  renderAbilitiesBucket(listPassiveEl,   passive);
  renderAbilitiesBucket(listActiveEl,    active);
  renderAbilitySpellsBucket();
  updateTalentCounter();
}

function fillPersonal(){
  const p = CHAR.stats.personal || {};
  pNickEl.value = p.nicknames || '';
  pHeightEl.value = p.height || '';
  pWeightEl.value = p.weight || '';
  pEloEl.value = p.elo || '';
  pRankEl.value = p.rank || '';
  pFriendsEl.innerHTML = p.friends || '';
  pEnemiesEl.innerHTML = p.enemies || '';
  pNotesEl.innerHTML = p.notes || '';
  pBackstoryEl.innerHTML = p.backstory || '';
}

function wirePersonal(){
  const bind = (el, key, { rich=false } = {}) => {
    el.addEventListener('input', ()=>{
      CHAR.stats.personal[key] = rich ? el.innerHTML : el.value;
      queueSave();
    });
  };
  bind(pNickEl, 'nicknames');
  bind(pHeightEl, 'height');
  bind(pWeightEl, 'weight');
  bind(pEloEl, 'elo');
  bind(pRankEl, 'rank');
  bind(pFriendsEl, 'friends', { rich:true });
  bind(pEnemiesEl, 'enemies', { rich:true });
  bind(pNotesEl, 'notes', { rich:true });
  bind(pBackstoryEl, 'backstory', { rich:true });
}

/* boot */
checkMe().then(loadCharacter).catch(()=>{ statusEl.textContent='Please log in.'; });
</script>
