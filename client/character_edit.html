<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NoE -- Edit Character (with Abilities)</title>

  <style>
    :root {
      color-scheme: dark;
      --bg: #14090c;
      --bg-2: #0c0b12;
      --panel: #121219;
      --border: #252533;
      --accent: #c53535;
      --accent-2: #f04a4a;
      --text: #f3f3f5;
    }
    html,body { height: 100%; }
    body {
      margin: 0;
      font-family: "Segoe UI", "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text);
      background: linear-gradient(180deg, #1a0c0f 0%, #0b0b10 100%);
      background-repeat: no-repeat;
      background-attachment: fixed;
      background-size: 100% 100%;
    }
    .page { min-height: 100vh; display: grid; place-items: start center; }
    .wrap { width: 100%; max-width: 1100px; padding: 28px 16px 60px; }
    .wrap.sheet-layout { max-width: 1400px; }
    .sheet-layout { display:grid; grid-template-columns: minmax(0, 1fr) 320px; gap:16px; align-items:start; }
    .sheet-main { min-width:0; }

    .topbar { display:flex; gap:12px; align-items:center; margin-bottom:16px; }
    .topbar h1 { font-size: 22px; margin: 0; }
    a.btn, button, input, select, textarea {
      padding:10px 12px; border-radius:12px; border:1px solid var(--border);
      background: #181821; color: var(--text); text-decoration:none;
      transition: background .15s ease, border .15s ease, transform .1s ease;
    }
    a.btn:hover, button:hover { background:#1f1f2a; border-color:#2f2f42; }
    button:active { transform: translateY(1px); }
    input, select, textarea { width:100%; }
    textarea { resize: vertical; }
    .muted { opacity:.78; font-size:.9rem; }
    .grow { flex: 1 1 auto; }
    .right { margin-left:auto; }

    .tabs { display:flex; gap:8px; border-bottom:1px solid var(--border); margin:16px 0 12px; flex-wrap:wrap; }
    .tab { padding:10px 14px; border:1px solid var(--border); border-bottom:none; border-radius:14px 14px 0 0; background:#14141d; cursor:pointer; }
    .tab.active { background: linear-gradient(135deg, rgba(197,53,53,0.25), rgba(20,20,29,0.9)); border-color: var(--accent); font-weight:700; box-shadow: 0 8px 16px rgba(0,0,0,0.3); }
    .tabpanes { border:1px solid var(--border); border-radius:0 18px 18px 18px; background: #11111a; padding:16px; box-shadow: 0 10px 30px rgba(0,0,0,0.28); }

    .stats-grid { display:grid; gap:14px; grid-template-columns: repeat(auto-fit, minmax(460px, 1fr)); align-items:stretch; }
    .panel { border:1px solid var(--border); border-radius:16px; overflow:hidden; background: var(--panel); box-shadow: 0 8px 24px rgba(0,0,0,0.25); height:100%; display:flex; flex-direction:column; }
    details.panel > summary { list-style:none; cursor:pointer; padding:14px 16px; display:flex; align-items:center; gap:10px; }
    details.panel > summary::-webkit-details-marker { display:none; }
    .pill { font-size:.85rem; opacity:.9; border:1px solid #2f2f3f; border-radius:999px; padding:3px 10px; }
    .panel-body { padding:0 16px 16px; display:grid; gap:10px; }
    .panel.skill-4 .panel-body { min-height: 260px; }
    .panel.skill-5 .panel-body { min-height: 320px; }

    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .row > .grow { flex:1 1 auto; }
    .k { opacity:.88; font-size:.9rem; }
    .num { width:90px; } /* Base numeric inputs stay comfortable; size specific rows below */
    .total { font-weight:600; }
    .hdr { display:flex; align-items:center; gap:10px; }
    .hdr-left { display:flex; align-items:center; gap:10px; }
    .hdr-right { margin-left:auto; }
    .xp-card{
      display:grid;
      gap:6px;
      min-width:260px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #2a2a3c;
      background: linear-gradient(135deg, rgba(197,53,53,0.12), rgba(30,30,42,0.65));
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
    }
    .xp-top{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .xp-bar{ width:100%; height:12px; border-radius:999px; background:#1a1a24; border:1px solid #2f2f42; overflow:hidden; }
    .xp-bar-fill{ height:100%; display:flex; align-items:center; justify-content:center; font-size:.75rem; background:linear-gradient(90deg, #c53535, #f04a4a); color:#fff; min-width:16px; }
    .xp-meta{ font-size:.9rem; opacity:.9; }
    .skills { display:grid; gap:8px; margin-top:10px; }
    .skill-line { display:grid; grid-template-columns: minmax(120px, 1fr) 78px 58px; gap:8px; align-items:center; }
    .skill-line input.num { width:40px; max-width:40px; } /* tighter inputs for skill rows */
    .skill-total { min-width:48px; text-align:center; font-variant-numeric: tabular-nums; padding:2px 4px; }
    .roll-link { background:none; border:none; padding:0; color:inherit; font:inherit; cursor:pointer; text-align:left; }
    .roll-link:hover { text-decoration:underline; }
    .charac-badge { font-variant-numeric: tabular-nums; }
    .badge { border:1px solid #2f2f3f; border-radius:999px; padding:2px 8px; font-variant-numeric: tabular-nums; background:#181821; }
    .hdr input.num { width:88px; }
    .intensities-panel { grid-column: 1 / -1; }
    .intensities-grid {
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:10px 12px;
    }
    .intensity-line {
      display:grid;
      grid-template-columns: minmax(80px, 1fr) 70px 62px;
      gap:6px;
      align-items:center;
    }
    .intensity-line input.num { width:40px; max-width:40px; }
    .intensity-line .skill-total { text-align:center; min-width:48px; }
    @media (max-width: 900px){
      .intensities-grid { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
    }

    .derived-grid { display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); }
    .kv { display:grid; grid-template-columns: auto 1fr; gap:6px 8px; align-items:center; }
    .kv .val { justify-self:end; font-variant-numeric: tabular-nums; }

    /* Abilities tab */
    .abi-grid { display:grid; gap:12px; grid-template-columns: 1fr; }
    .abi-bucket h3 { margin:6px 0 8px; font-size:1rem; }
    .abi-list { display:grid; gap:8px; }
    .abi-item { display:flex; align-items:center; gap:10px; padding:8px 10px; border:1px solid #2b2b3b; border-radius:12px; background:linear-gradient(145deg, #14141d, #0f0f16); box-shadow: inset 0 1px 0 rgba(255,255,255,0.03); }
    .abi-item.abi-block { flex-direction: column; align-items: stretch; }
    .abi-item .tag { border:1px solid #3b3b4b; border-radius:999px; padding:3px 8px; font-size:.75rem; opacity:.9; }
    .title-color-target { cursor:pointer; }
    .title-color-target:hover { text-shadow: 0 0 8px rgba(255,255,255,0.15); }
    .color-picker-card { max-width:520px; }
    .color-preview-row { display:flex; align-items:center; gap:10px; margin-bottom:10px; }
    .color-preview-chip { width:36px; height:36px; border-radius:10px; border:1px solid #2a2a3a; background:#15151d; }
    .color-preview-title { font-weight:600; }
    .color-gradient-track { height:16px; border-radius:999px; border:1px solid #2a2a3a; background:linear-gradient(90deg, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00); padding:0; overflow:hidden; box-sizing:border-box; }
    .color-gradient-track input { width:100%; margin:0; background:transparent; appearance:none; height:100%; display:block; }
    .color-gradient-track input::-webkit-slider-thumb { appearance:none; width:16px; height:16px; border-radius:50%; background:#f3f3f5; border:1px solid #2a2a3a; }
    .color-gradient-track input::-moz-range-thumb { width:16px; height:16px; border-radius:50%; background:#f3f3f5; border:1px solid #2a2a3a; }
    .color-palette { display:grid; grid-template-columns: repeat(auto-fit, minmax(26px, 1fr)); gap:6px; margin-top:8px; }
    .color-swatch { width:26px; height:26px; border-radius:8px; border:1px solid #2a2a3a; background:var(--swatch, #333); cursor:pointer; }
    .color-swatch:focus { outline:2px solid var(--accent); outline-offset:2px; }
    .abi-item button { padding:6px 10px; font-size:.85rem; }
    .prereq-warn { color:#f66; font-size:.85rem; }
    .abi-add { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .abi-add input, .abi-add select { flex:1 1 auto; }
    .abi-hint { opacity:.75; font-size:.85rem; margin-top:6px; }
    /* Modifiers breakdown */
    .mod-list { margin:6px 0 4px 16px; padding:0; list-style:disc; display:none; opacity:0.9; }
    .mod-list li { margin:0 0 3px 0; font-size:0.9rem; }
    .mod-toggle { cursor:pointer; }
    .stat-counter { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0; }
    .stat-counter .pill { border-color:#2f2f2f; }
    .current-row { display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:8px; margin-top:8px; }
    .current-row label { display:flex; align-items:center; gap:6px; }
    .current-row input { width:100%; }
    .combat-grid { display:grid; gap:12px; grid-template-columns: 1fr; }
    .combat-col { display:grid; gap:12px; }
    .combat-vitals { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .combat-vitals input { width:6ch; min-width:6ch; }
    .combat-row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .combat-inline { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .combat-actions-row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .combat-list { display:grid; gap:8px; }
    .combat-entry {
      display:flex; align-items:center; gap:10px; padding:8px 10px;
      border:1px solid #2a2a38; border-radius:12px; background:#151520;
    }
    .combat-entry .meta { font-size:.82rem; opacity:.8; }
    .combat-entry .muted { font-size:.82rem; }
    .combat-entry .tag { border:1px solid #343446; border-radius:999px; padding:2px 8px; font-size:.75rem; }
    .combat-entry .grow { min-width:0; }
    .combat-entry input[type="checkbox"],
    .combat-entry input[type="radio"] { width:auto; }
    .combat-pill-list { display:flex; gap:6px; flex-wrap:wrap; }
    .combat-pill { border:1px solid #2d2d3d; border-radius:999px; padding:4px 10px; background:#141420; font-size:.82rem; }
    .combat-pill button { padding:0 6px; border:none; background:none; color:inherit; cursor:pointer; }
    .combat-mini { font-size:.82rem; opacity:.85; }
    .combat-table { width:100%; border-collapse:collapse; }
    .combat-table th, .combat-table td { text-align:left; padding:6px 8px; border-bottom:1px solid #222233; vertical-align:top; font-size:.9rem; }
    .combat-table th { font-size:.8rem; opacity:.8; }
    .combat-block { border:1px solid #242436; border-radius:12px; padding:10px; background:#12121c; }
    .combat-header { display:flex; align-items:center; gap:10px; }
    .combat-header .right { margin-left:auto; }
    .combat-subtitle { font-size:.85rem; opacity:.75; }
    .combat-badge { border:1px solid #2f2f3f; border-radius:999px; padding:3px 8px; background:#181821; font-variant-numeric: tabular-nums; }
    .combat-actions-grid { display:grid; gap:8px; }
    .combat-actions-grid .combat-entry { align-items:flex-start; }
    .combat-actions-grid .btn { white-space:nowrap; }
    .combat-num { width:4ch; min-width:4ch; text-align:right; }
      .override-row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:8px; }
      #override-inputs { display:none; grid-template-columns: repeat(auto-fit, minmax(160px,1fr)); gap:8px; margin-top:10px; }
  /* Avatar */
  .avatar-card { display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap; }
  .avatar-frame { width:180px; height:180px; border:1px solid #333; border-radius:18px; overflow:hidden; background:#08080e; display:grid; place-items:center; box-shadow: inset 0 1px 0 rgba(255,255,255,0.05); }
  .avatar-frame img { width:100%; height:100%; object-fit:cover; }
  .avatar-tools { display:grid; gap:8px; min-width:280px; flex:1 1 320px; }
  .name-input { font-size:1.3rem; font-weight:600; letter-spacing:0.2px; }
  .avatar-actions { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  .public-toggle { display:flex; align-items:center; gap:8px; }
  .public-toggle input { width:auto; }
  .avatar-crop { border:1px solid #333; border-radius:14px; background:#0b0b12; }
  @media (max-width: 720px){
    .avatar-frame { width:160px; height:160px; }
  }
  /* Inventory UI */
  .home-card { border:1px solid var(--border); border-radius:14px; padding:12px; background: #14141d; margin-bottom:12px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
  .container-card { border:1px solid #2a2a38; border-radius:12px; padding:12px; margin-bottom:10px; background: linear-gradient(135deg, #12121a, #0f0f17); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
  .container-head { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px; }
  .items { display:grid; gap:8px; }
  .item-row { display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; padding:8px 10px; border:1px solid #292938; border-radius:10px; background:#161623; }
  .item-actions { display:flex; align-items:center; gap:8px; flex-wrap:nowrap; }
  .item-actions .pill { white-space:nowrap; }
  .item-row .pill { white-space:nowrap; }
  .inv-summary { display:grid; gap:6px; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); align-items:center; }
  .inv-actions { display:flex; gap:8px; flex-wrap:wrap; }
  .info-grid { display:grid; gap:10px; grid-template-columns: repeat(auto-fit,minmax(160px,1fr)); margin:10px 0; }
  .info-grid .cell { border:1px solid #242436; border-radius:10px; padding:8px; background:#12121c; }
  .info-grid .label { font-size:.85rem; opacity:.75; }
  .inv-desc-box{ border:1px solid #2a2a3a; border-radius:12px; padding:10px 12px; background:#141420; color:#e7e7ee; }
  .inv-desc-box > *:first-child{ margin-top:0; }
  .inv-desc-box > *:last-child{ margin-bottom:0; }
  .arc-desc{ border:1px solid #2a2a3a; border-radius:12px; padding:10px 12px; background:#141420; color:#e7e7ee; }
  .arc-desc > *:first-child{ margin-top:0; }
  .arc-desc > *:last-child{ margin-bottom:0; }
  .pill-soft { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:10px; background:#111827; border:1px solid #1f2b3f; }
  .upg-list { display:grid; gap:10px; }
  .upg-row { border:1px solid #242436; border-radius:10px; padding:8px; background:#12121c; }
  .upg-row h4 { margin:0 0 4px; font-size:1rem; }
  .roll-chat { border:1px solid var(--border); border-radius:16px; padding:12px; background: #14141d; box-shadow: 0 10px 24px rgba(0,0,0,0.35); display:flex; flex-direction:column; gap:10px; position:sticky; top:24px; }
  .roll-chat-header { display:flex; align-items:center; gap:8px; }
  .roll-chat-body { display:grid; gap:8px; overflow:auto; max-height: calc(100vh - 220px); }
  .roll-chat-panel { display:flex; flex-direction:column; gap:10px; }
  .chat-log { border:1px solid #2a2a38; border-radius:12px; padding:10px; background:#101018; max-height: calc(100vh - 320px); overflow:auto; display:grid; gap:12px; }
  .chat-group { display:grid; gap:6px; }
  .chat-head { display:flex; gap:10px; align-items:center; }
  .chat-avatar { width:36px; height:36px; border-radius:10px; border:1px solid #333; overflow:hidden; background:#0b0b10; display:grid; place-items:center; }
  .chat-avatar img { width:100%; height:100%; object-fit:cover; }
  .chat-user { font-weight:600; }
  .chat-lines { --chat-indent:46px; display:grid; gap:4px; padding-left:var(--chat-indent); }
  .chat-line { background:#121623; border:1px solid #232839; border-radius:10px; padding:8px 10px; }
  .chat-line .muted { font-size:.85rem; }
  .chat-line.whisper { border-color:#5a4a22; }
  .chat-line.self { border-color:#34555a; }
  .chat-line.chat-roll { background:transparent; border:none; padding:0; margin-left:calc(-1 * var(--chat-indent)); }
  .roll-card{
    --roll-accent:#a6b2ff;
    border:1px solid #2b303e;
    border-radius:16px;
    padding:12px 12px 10px;
    background:linear-gradient(180deg, rgba(18,20,33,0.98), rgba(12,13,20,0.96));
    display:grid;
    gap:8px;
    box-shadow:0 12px 18px rgba(0,0,0,0.35);
  }
  .roll-card.roll-skill{--roll-accent:#a6b2ff;}
  .roll-card.crit-success{--roll-accent:#b632ff;}
  .roll-card.crit-fail{--roll-accent:#e0672c;}
  .roll-card.crit-max{
    --roll-accent:#ff3b3b;
    border-color:#6a1010;
    background:linear-gradient(180deg, rgba(6,6,10,0.98), rgba(8,8,12,0.95));
    box-shadow:0 0 0 1px rgba(140,0,0,0.7), 0 16px 30px rgba(120,0,0,0.65), 0 0 18px rgba(255,0,0,0.45);
  }
  .roll-card.crit-max .roll-title,
  .roll-card.crit-max .roll-total{ text-shadow:0 0 12px rgba(255,40,40,0.6); }
  .roll-card.is-active{--roll-accent:#c9a227;}
  .roll-card.is-passive{--roll-accent:#d4d7e8;}
  .roll-card.roll-damage{--roll-accent:#c96b52;}
  .roll-title{
    font-weight:700;
    text-align:center;
    text-transform:uppercase;
    letter-spacing:.08em;
    color:var(--roll-accent);
  }
  .roll-divider{
    height:1px;
    background:linear-gradient(90deg, transparent, rgba(210,210,230,0.35), transparent);
  }
  .roll-sub{
    text-align:center;
    font-size:.82rem;
    opacity:.8;
  }
  .roll-total{
    text-align:center;
    font-size:2.6rem;
    font-weight:700;
    color:var(--roll-accent);
    letter-spacing:.02em;
  }
  .roll-total::before,
  .roll-total::after{
    color:var(--roll-accent);
  }
  .roll-total::before{content:'{';margin-right:4px;}
  .roll-total::after{content:'}';margin-left:4px;}
  .roll-formula{
    font-size:.78rem;
    opacity:.7;
    text-align:center;
  }
  .roll-card .roll-image{
    width:100%;
    border-radius:12px;
    border:1px solid #2a2a38;
    display:block;
  }
  .roll-desc{
    border:1px solid #2b303e;
    border-radius:12px;
    padding:10px;
    background:#121622;
    font-size:.88rem;
    line-height:1.4;
  }
  .roll-meta-line{
    text-align:center;
    font-size:.75rem;
    text-transform:uppercase;
    letter-spacing:.08em;
    opacity:.75;
  }
  .roll-dmg-row{
    display:grid;
    grid-template-columns:1fr auto;
    gap:8px;
    align-items:baseline;
  }
  .roll-dmg-type{
    font-size:.78rem;
    text-transform:uppercase;
    letter-spacing:.08em;
    opacity:.85;
  }
  .roll-dmg-value{
    font-size:2rem;
    font-weight:700;
    color:var(--roll-accent);
  }
  .roll-foot{
    text-align:center;
    font-size:.72rem;
    opacity:.6;
  }
  .roll-entry img{ width:100%; border-radius:12px; border:1px solid #2a2a38; display:block; }
  .chat-line.chat-image{ background:#121623; border:1px solid #232839; padding:8px; }
  .chat-line.chat-image img{ width:100%; border-radius:12px; border:1px solid #2a2a38; display:block; }
  .chat-line.chat-image .caption{ font-size:.85rem; margin-bottom:6px; }
  .chat-controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #campaign-chat-input{ width:100%; max-width:100%; box-sizing:border-box; }
  .roll-entry { border:1px solid #2a2a38; border-radius:12px; padding:8px 10px; background:#14141d; }
  .roll-entry .title { font-weight:600; }
  .roll-entry .meta { font-size:.8rem; opacity:.75; }
  .roll-grid { display:grid; gap:8px; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); margin-top:8px; }
  .roll-grid label { display:grid; gap:4px; }
  .roll-grid input[type="number"]{ width:7ch; max-width:7ch; justify-self:start; }
  .roll-conditions { margin-top:10px; }
  .roll-cond-grid { display:grid; gap:6px 12px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
  .roll-conditions label { display:flex; align-items:center; gap:8px; }
  .roll-conditions input[type="checkbox"]{ width:auto; margin:0; }
    .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .sl-sch-controls { display:flex; align-items:center; gap:8px; margin-bottom:8px; flex-wrap:nowrap; }
    .sl-sch-controls .sl-sch-left,
    .sl-sch-controls .sl-sch-right { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .sl-sch-controls .sl-sch-right { margin-left:auto; }
    @media (max-width: 900px){
      .sl-sch-controls { flex-wrap:wrap; }
      .sl-sch-controls .sl-sch-right { margin-left:0; }
    }
    @media (max-width: 1200px){
      .sheet-layout { grid-template-columns: 1fr; }
      .roll-chat { position:static; }
      .roll-chat-body { max-height:none; }
      .chat-log { max-height:none; }
    }
    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:3000; display:none; }
    .modal{ position:fixed; inset:0; display:none; z-index:3001; align-items:center; justify-content:center; padding:16px; }
    .modal.open, .modal-backdrop.open{ display:flex; }
    .modal-card{
      width:100%; max-width:520px; background:#11111a; border:1px solid #2a2a3a;
      border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.6);
      max-height:90vh; overflow:auto;
    }
    .price-choice-card{ max-width:520px; width:min(520px, 96vw); }
    .price-choice-title{ font-weight:700; line-height:1.2; word-break:break-word; }
    .price-choice-grid{ display:grid; gap:8px; }
    .price-choice-option{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .price-choice-option input{ margin:0; }
    .price-choice-custom{ display:grid; gap:8px; grid-template-columns: minmax(0,1fr) minmax(0,1fr); }
    .price-choice-field{ display:flex; gap:6px; align-items:center; min-width:0; }
    .price-choice-actions{ display:flex; justify-content:flex-end; gap:8px; margin-top:6px; }
    /* Personal tab */
    .personal-grid { display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); align-items:start; margin-bottom:10px; }
    .kv-field { display:grid; gap:6px; min-width:0; }
    .kv-field input, .kv-field textarea, .kv-field .richtext { width:100%; box-sizing:border-box; }
    .richtext{
      min-height:100px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#181821;
      outline:none;
      overflow:auto;
    }
    .richtext:focus{ border-color:#2f2f42; box-shadow:0 0 0 1px #2f2f42; }
    .richtext:empty:before{
      content: attr(data-placeholder);
      opacity: .55;
      pointer-events:none;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="page"><div class="wrap sheet-layout"><div class="sheet-main">

    <div class="topbar">
      <h1 id="title">Edit Character</h1>
      <span id="login-chip" class="muted right"></span>
      <a class="btn" id="back-link" href="characters.html">Back to My Characters</a>
      <a class="btn" href="portal.html">Portal</a>
      <a class="btn" href="character_admin.html" id="admin-link" style="display:none">All Characters</a>
      <button class="btn secondary" id="unlink-campaign" style="display:none;">Unlink from Campaign</button>
      <button class="btn" id="delete-char" style="border-color:#7a1b1b; background:linear-gradient(135deg, rgba(197,53,53,0.35), rgba(60,10,14,0.9)); color:#fff;">Delete</button>
      <label class="row" style="gap:6px; margin-left:8px;">
        <input type="checkbox" id="override-derived"> <span class="muted">Override values (GM)</span>
      </label>
    </div>

    <!-- Name card -->
    <div class="panel" style="margin-bottom:12px;">
      <details open class="panel">
        <summary class="hdr">
          <div class="hdr-left">
            <strong>Name</strong>
            <span class="muted">(autosaves)</span>
            <span class="muted status" id="status">Loaded.</span>
            <span class="pill" id="readonly-pill" style="display:none;">Read-only</span>
          </div>
          <div class="hdr-right xp-card">
            <div class="xp-top">
              <span class="k">Level</span>
              <input id="level" type="text" class="num" value="1" readonly />
              <button class="btn small" id="xp-add-btn" title="Add XP">+ XP</button>
              <button class="btn small" id="level-set-btn" title="Set level">Set</button>
              <button class="btn small" id="xp-ledger-btn" title="Open XP ledger">Ledger</button>
            </div>
            <div class="xp-bar" aria-label="XP progress">
              <div class="xp-bar-fill" id="xp-bar-fill"><span id="xp-bar-text">--</span></div>
            </div>
            <div class="xp-meta" id="xp-progress">XP: --</div>
          </div>
        </summary>
          <div class="panel-body">
            <div class="avatar-card">
              <div class="avatar-frame"><img id="avatar-preview" alt="Avatar preview"></div>
              <div class="avatar-tools">
                <input id="name" placeholder="Enter a name..." class="grow name-input" maxlength="22" />
                <div class="avatar-actions">
                  <button id="avatar-open" class="btn small">Set avatar</button>
                  <label class="public-toggle muted">
                    <input type="checkbox" id="public-toggle">
                    <span>Public Character</span>
                  </label>
                </div>
                <div id="avatar-status" class="muted"></div>
              </div>
            </div>
          </div>
        </details>
    </div>

    <!-- Tabs -->
    <div class="tabs" role="tablist">
      <div class="tab active" data-tab="tab-stat">Statistic</div>
      <div class="tab" data-tab="tab-inv">Inventory</div>
      <div class="tab" data-tab="tab-spell">Spell List</div>
      <div class="tab" data-tab="tab-abi">Abilities</div>
      <div class="tab" data-tab="tab-com">Combat</div>
      <div class="tab" data-tab="tab-per">Personal</div>
    </div>

    <div class="tabpanes">
      <!-- STATISTICS TAB -->
      <div id="tab-stat" class="tabpane">
        <div class="panel" style="margin-bottom:12px;">
          <details open class="panel">
            <summary class="hdr">
              <strong>Derived Stats</strong>
              <span class="muted">(auto from Level, Milestones & skills)</span>
              <span class="grow"></span>
            </summary>
            <div class="panel-body">
              <div class="derived-grid">
                <div class="kv"><div class="k">HP</div> <div class="val badge mod-toggle" id="hp-val" data-target="mods-derived-hp" title="">--</div>
                <ul class="mod-list" id="mods-derived-hp" style="display:none"></ul></div>
                <div class="kv"><div class="k">EN</div> <div class="val badge mod-toggle" id="en-val" data-target="mods-derived-en" title="">--</div>
                <ul class="mod-list" id="mods-derived-en" style="display:none"></ul></div>
                <div class="kv"><div class="k">FO</div> <div class="val badge mod-toggle" id="fo-val" data-target="mods-derived-fo" title="">--</div>
                <ul class="mod-list" id="mods-derived-fo" style="display:none"></ul></div>
                <div class="kv"><div class="k">MO</div> <div class="val badge mod-toggle" id="mo-val" data-target="mods-derived-mo" title="">--</div>
                <ul class="mod-list" id="mods-derived-mo" style="display:none"></ul></div>
                <div class="kv"><div class="k">Initiative</div> <div class="val badge mod-toggle" id="init-val" data-target="mods-derived-initiative" title="">--</div>
                <ul class="mod-list" id="mods-derived-initiative" style="display:none"></ul></div>
                <div class="kv"><div class="k">SP cap (10% HP)</div> <div class="val badge mod-toggle" id="spcap-val" data-target="mods-derived-spcap" title="">--</div>
                <ul class="mod-list" id="mods-derived-spcap" style="display:none"></ul></div>
                <div class="kv"><div class="k">Encumbrance</div> <div class="val badge mod-toggle" id="enc-val" data-target="mods-derived-enc" title="">--</div>
                <ul class="mod-list" id="mods-derived-enc" style="display:none"></ul></div>
                <div class="kv"><div class="k">Eclipse Threshold (ET)</div> <div class="val badge mod-toggle" id="et-val" data-target="mods-derived-et" title="">--</div>
                <ul class="mod-list" id="mods-derived-et" style="display:none"></ul></div>
                <div class="kv"><div class="k">Max Toxicity (TX)</div> <div class="val badge mod-toggle" id="tx-val" data-target="mods-derived-tx" title="">--</div>
                <ul class="mod-list" id="mods-derived-tx" style="display:none"></ul></div>
                <div class="kv"><div class="k">Neutral weapon damage</div> <div class="val badge mod-toggle" id="weapon-neutral-val" data-target="mods-derived-weapon-neutral" title="">--</div>
                <ul class="mod-list" id="mods-derived-weapon-neutral" style="display:none"></ul></div>
              </div>
              <div id="override-inputs">
                <label>HP <input id="ov-hp" type="number" step="1"></label>
                <label>EN <input id="ov-en" type="number" step="1"></label>
                <label>FO <input id="ov-fo" type="number" step="1"></label>
                <label>MO <input id="ov-mo" type="number" step="1"></label>
                <label>Initiative <input id="ov-init" type="number" step="1"></label>
                <label>SP cap <input id="ov-spcap" type="number" step="1"></label>
                <label>Encumbrance <input id="ov-enc" type="number" step="0.1"></label>
                <label>Eclipse Threshold <input id="ov-et" type="number" step="1"></label>
                <label>Max Toxicity <input id="ov-tx" type="number" step="1"></label>
                <label>Talent Max <input id="ov-talent-max" type="number" step="1"></label>
                <label>Skill points <input id="ov-skill-points" type="number" step="1"></label>
                <label>Stat points <input id="ov-stat-points" type="number" step="1"></label>
                <label>Sublimation slots <input id="ov-sub-slots" type="number" step="1"></label>
                <label>Complex schools <input id="ov-complex-schools" type="number" step="1"></label>
              </div>
            </div>
          </details>
        </div>

        <!-- Sublimations -->
        <div class="panel" style="margin-bottom:12px;">
          <details open class="panel">
            <summary class="hdr">
              <strong>Sublimations</strong>
              <span class="pill" id="sub-slot-pill"></span>
              <span class="muted" id="sub-warning"></span>
            </summary>
            <div class="panel-body">
              <div class="row" style="justify-content:flex-end; margin-bottom:8px; gap:8px;">
                <button id="sub-open-btn" class="btn small">Add sublimation</button>
              </div>
              <div id="sub-list" class="abi-list"></div>
              <div class="muted" id="sub-hidden"></div>
            </div>
          </details>
        </div>

        <div class="stat-counter">
          <span class="pill" id="skill-counter">Skills: -- / --</span>
          <span class="pill" id="stat-counter">Characteristics: -- / --</span>
          <span class="pill" id="skill-cap">Max per skill: --</span>
          <span class="pill" id="stat-cap">Max per characteristic: --</span>
        </div>

        <div class="stats-grid" id="stats-grid"><!-- injected --></div>

      </div>

      <!-- INVENTORY -->
      <div id="tab-inv" class="tabpane" style="display:none;">
        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Inventory</strong>
              <span class="muted">(linked & fully managed here)</span>
            </summary>
            <div class="panel-body">
              <div class="row" style="margin-bottom:10px; flex-wrap:wrap; gap:8px;">
                <select id="inv-select" class="grow"></select>
                <button id="inv-load-btn">Load</button>
                <button id="inv-create-btn" class="btn small">Create & Link</button>
                <button id="inv-dup-link" class="btn small">Duplicate & Link</button>
                <a class="btn" id="inv-open-manager" target="_blank" rel="noopener">Open manager</a>
                <span id="inv-status" class="muted"></span>
              </div>

              <div id="inv-manager" style="display:none;">
                <div class="home-card">
                  <h3 id="inv-title">Inventory</h3>
                  <div class="inv-summary">
                    <div id="inv-money"></div>
                    <div class="row muted" style="gap:6px;">Total Encumbrance: <strong id="inv-enc-total">0</strong></div>
                  </div>
                  <div class="inv-actions" style="margin-top:8px;">
                    <button id="inv-fund-open" class="btn small">Add / Remove funds</button>
                    <button id="inv-catalog-open" class="btn small">Add from catalog</button>
                  </div>
                </div>

                <div class="home-card">
                  <h3>Containers & Items</h3>
                  <div id="inv-containers"></div>
                  <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap;">
                    <input id="inv-new-cont-name" placeholder="New container name">
                    <button id="inv-add-cont" class="btn small">+ Add Container</button>
                  </div>
                </div>

                <div class="home-card">
                  <h3>Recent Transactions</h3>
                  <div id="inv-tx" class="list"></div>
                </div>
              </div>
            </div>
          </details>
        </div>

        <!-- Item modal -->
        <div id="inv-item-backdrop" class="modal-backdrop" aria-hidden="true"></div>
        <div id="inv-item-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="inv-item-title">
          <div class="modal-card">
            <button class="modal-close" id="inv-item-close" aria-label="Close">&times;</button>
            <h2 id="inv-item-title">Item</h2>
            <div id="inv-item-body" class="list" style="margin-top:10px;"></div>
            <div id="inv-item-actions" style="margin-top:12px;"></div>
          </div>
        </div>

        <!-- Craftomancy modal -->
        <div id="craft-add-backdrop" class="modal-backdrop" aria-hidden="true"></div>
        <div id="craft-add-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="craft-add-title">
          <div class="modal-card" style="max-width:980px;">
            <header class="row" style="justify-content:space-between; align-items:center;">
              <div class="modal-title" id="craft-add-title">Add Craftomancy</div>
              <button class="modal-close" id="craft-add-close" aria-label="Close">&times;</button>
            </header>
            <div id="craft-add-info" class="muted" style="margin:6px 0 8px;"></div>
            <div class="row" style="gap:10px; flex-wrap:wrap; margin-bottom:8px;">
              <input id="craft-search-q" placeholder="Search approved spells..." style="flex:1; min-width:240px;">
              <label class="row muted" style="gap:6px; align-items:center;">
                <input type="checkbox" id="craft-supreme"> Supreme Enchantment (+1 category)
              </label>
              <button class="btn" id="craft-search-btn">Search</button>
            </div>
            <div class="table-wrap">
              <table class="table">
                <thead><tr><th>Name</th><th>Category</th><th>Cost</th><th>Craft</th></tr></thead>
                <tbody id="craft-search-body">
                  <tr><td colspan="4" class="empty">Use search to list approved spells.</td></tr>
                </tbody>
              </table>
            </div>
            <div class="row" style="margin-top:10px; gap:8px;">
              <button class="btn btn-secondary" id="craft-add-cancel">Close</button>
            </div>
            <div id="craft-add-status" class="muted" style="margin-top:6px;"></div>
          </div>
        </div>
      </div>

      <!-- ABILITIES TAB -->
      <div id="tab-abi" class="tabpane" style="display:none;">
        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Species</strong>
              <span class="muted">(auto bonus ability)</span>
            </summary>
            <div class="panel-body">
              <div class="row" style="gap:8px; flex-wrap:wrap;">
                <select id="species-select" class="grow"></select>
                <span id="species-status" class="muted"></span>
              </div>
              <div id="species-desc" class="arc-desc" style="display:none;"></div>
            </div>
          </details>
        </div>

        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Boon</strong>
              <span class="muted">(auto bonus ability)</span>
            </summary>
            <div class="panel-body">
              <div class="row" style="gap:8px; flex-wrap:wrap;">
                <select id="boon-select" class="grow"></select>
                <span id="boon-status" class="muted"></span>
              </div>
              <div id="boon-desc" class="arc-desc" style="display:none;"></div>
            </div>
          </details>
        </div>

        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Archetype</strong>
              <span class="muted">(auto unlock by level)</span>
            </summary>
            <div class="panel-body">
              <div class="row" style="gap:8px; flex-wrap:wrap;">
                <select id="arc-select" class="grow"></select>
                <button id="arc-apply" class="btn">Apply</button>
                <span id="arc-status" class="muted"></span>
              </div>
              <div id="arc-summary" class="muted"></div>
              <div id="arc-description" class="arc-desc" style="display:none;"></div>
              <div class="abi-list" id="arc-abilities"></div>
            </div>
          </details>
        </div>

        <div class="panel" id="exp-panel" style="display:none;">
          <details open class="panel">
            <summary class="hdr">
              <strong>Expertise</strong>
              <span class="muted">(unlock by linked skill)</span>
            </summary>
            <div class="panel-body">
              <div id="exp-summary" class="muted"></div>
              <div class="abi-list" id="exp-abilities"></div>
            </div>
          </details>
        </div>

        <div class="panel" id="dima-panel" style="display:none;">
          <details open class="panel">
            <summary class="hdr">
              <strong>Divine Manifestation</strong>
              <span class="muted">(unlock by linked skill)</span>
            </summary>
            <div class="panel-body">
              <div id="dima-summary" class="muted"></div>
              <div class="abi-list" id="dima-abilities"></div>
            </div>
          </details>
        </div>

        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Abilities on this Character</strong>
              <span class="muted">(Archetype / Passive / Active)</span>
              <span class="grow"></span>
              <button class="btn small" id="abi-open-add">Add ability</button>
              <button class="btn small" id="exp-open-add">Add expertise</button>
              <button class="btn small" id="dima-open-add">Add divine manifestation</button>
            </summary>
            <div class="panel-body">
              <div class="abi-hint" id="talent-counter">Talents: -- / --</div>
              <div class="stat-counter" style="margin-top:6px;">
                <span class="pill" id="expertise-counter">Expertise: -- / --</span>
                <span class="pill" id="dima-counter">Divine Manifestation: -- / --</span>
                <span class="pill" id="craftomancy-counter">Craftomancy Focus: -- / --</span>
              </div>

              <div class="abi-grid" style="margin-top:16px;">
                <div class="abi-bucket">
                  <h3>Passive</h3>
                  <div class="row" style="gap:6px; align-items:center; margin-bottom:6px;">
                    <label class="muted" for="abi-passive-order">Order</label>
                    <select id="abi-passive-order" style="min-width:160px;">
                      <option value="manual">Manual</option>
                      <option value="az">A->Z</option>
                      <option value="za">Z->A</option>
                    </select>
                    <button class="btn small" id="abi-passive-sort">Sort</button>
                  </div>
                  <div id="abi-list-passive" class="abi-list"></div>
                </div>
                <div class="abi-bucket">
                  <h3>Active</h3>
                  <div class="row" style="gap:6px; align-items:center; margin-bottom:6px;">
                    <label class="muted" for="abi-active-order">Order</label>
                    <select id="abi-active-order" style="min-width:160px;">
                      <option value="manual">Manual</option>
                      <option value="az">A->Z</option>
                      <option value="za">Z->A</option>
                    </select>
                    <button class="btn small" id="abi-active-sort">Sort</button>
                  </div>
                  <div id="abi-list-active" class="abi-list"></div>
                </div>
                <div class="abi-bucket">
                  <h3>Spells (from linked list)</h3>
                  <div class="row" style="gap:6px; align-items:center; margin-bottom:6px;">
                    <label class="muted" for="abi-spell-order">Order</label>
                    <select id="abi-spell-order" style="min-width:160px;">
                      <option value="manual">Manual</option>
                      <option value="az">A->Z</option>
                      <option value="za">Z->A</option>
                    </select>
                    <button class="btn small" id="abi-spell-sort">Sort</button>
                    <label class="row muted" style="gap:6px; align-items:center; margin-left:8px;">
                      <input type="checkbox" id="abi-spells-only-learned" checked> Prepared Only
                    </label>
                  </div>
                  <div id="abi-list-spells" class="abi-list"></div>
                </div>
              </div>
            </div>
          </details>
        </div>
      </div>

      <!-- SPELL LIST TAB -->
      <div id="tab-spell" class="tabpane" style="display:none;">
        <div class="panel">
          <details open class="panel">
            <summary class="hdr">
              <strong>Spell List</strong>
              <span class="muted">(linked & managed here)</span>
            </summary>
            <div class="panel-body">
              <div class="row" style="margin-bottom:10px; flex-wrap:wrap; gap:8px;">
                <select id="sl-select" class="grow"></select>
                <button id="sl-load-btn">Load</button>
                <button id="sl-create-btn">Create & Link</button>
                <button id="sl-dup-btn">Duplicate & Link</button>
                <a class="btn" href="spell_list_home.html" target="_blank" rel="noopener">Open manager</a>
                <span id="sl-status" class="muted"></span>
              </div>
              <div id="sl-summary" class="muted" style="margin-bottom:8px;"></div>
              <div class="row" id="sl-counters" style="gap:8px; flex-wrap:wrap; margin-bottom:10px;">
                <span class="pill" id="cnt-sch-simple">Simple schools: --</span>
                <span class="pill" id="cnt-sch-complex">Complex schools: --</span>
                <span class="pill" id="cnt-sp-simple">Simple spell slots: --</span>
                <span class="pill" id="cnt-sp-complex">Complex spell slots: --</span>
              </div>

              <div class="panel" style="margin-bottom:12px;">
                <details open class="panel">
                  <summary class="hdr">
                    <strong>Schools</strong>
                    <span class="muted">(add and track MS)</span>
                  </summary>
                  <div class="panel-body">
                    <div class="sl-sch-controls">
                      <div class="sl-sch-left">
                        <button class="btn small" id="sl-add-menu-btn">Add schools</button>
                        <div id="sl-add-menu" class="row" style="gap:6px; display:none; flex-wrap:wrap;">
                          <button class="btn small" id="sl-quick-add">Quick Add</button>
                          <button class="btn small" id="sl-manual-add">Manual Add</button>
                        </div>
                        <span class="muted" id="sl-schools-status"></span>
                      </div>
                      <div class="sl-sch-right">
                        <label class="muted" for="sl-sch-order">Order</label>
                        <select id="sl-sch-order" style="min-width:180px;">
                          <option value="manual">Manual</option>
                          <option value="name">Name (A-Z)</option>
                          <option value="ms">MS (high to low)</option>
                        </select>
                        <button class="btn small" id="sl-sch-sort">Sort</button>
                        <span class="muted" id="sl-sch-order-status"></span>
                      </div>
                    </div>
                    <div id="sl-schools" class="abi-list"></div>
                  </div>
                </details>
              </div>

              <div class="panel">
                <details open class="panel">
                  <summary class="hdr">
                    <strong>My Spells</strong>
                    <span class="muted">(from linked list)</span>
                    <span class="grow"></span>
                    <button class="btn small" id="sl-open-add">Add spells</button>
                  </summary>
                  <div class="panel-body">
                    <div class="table-wrap">
                      <table class="table">
                        <thead>
                          <tr>
                            <th style="width:30%;">Name</th>
                            <th>Schools</th>
                            <th style="width:10%;">Category</th>
                            <th style="width:12%;">Status</th>
                            <th style="width:18%;">Actions</th>
                          </tr>
                        </thead>
                        <tbody id="sl-spells-body">
                          <tr><td colspan="5" class="empty">Load a spell list.</td></tr>
                        </tbody>
                      </table>
                    </div>
                  </div>
                </details>
              </div>
            </div>
          </details>
        </div>

        <div id="sl-add-backdrop" class="modal-backdrop" aria-hidden="true"></div>
        <div id="sl-add-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="sl-add-title">
          <div class="modal-card" style="max-width:960px;">
            <header class="row" style="justify-content:space-between; align-items:center;">
              <div class="modal-title" id="sl-add-title">Add Spells</div>
              <button class="modal-close" id="sl-add-close" aria-label="Close">✕</button>
            </header>
            <div class="row" style="gap:10px; flex-wrap:wrap; margin-bottom:8px;">
              <input id="sl-search-q" placeholder="Search spells..." style="flex:1; min-width:240px;">
              <button class="btn" id="sl-search-btn">Search</button>
            </div>
            <div class="table-wrap">
              <table class="table">
                <thead><tr><th>Name</th><th>Schools</th><th>Category</th><th>Add</th></tr></thead>
                <tbody id="sl-search-body">
                  <tr><td colspan="4" class="empty">Use search to list spells.</td></tr>
                </tbody>
              </table>
            </div>
            <div class="row" style="margin-top:10px; gap:8px;">
              <button class="btn btn-secondary" id="sl-add-cancel">Close</button>
            </div>
            <div id="sl-add-status" class="muted" style="margin-top:6px;"></div>
          </div>
        </div>

        <div id="sl-sch-modal-backdrop" class="modal-backdrop" aria-hidden="true"></div>
        <div id="sl-sch-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="sl-sch-title">
          <div class="modal-card" style="max-width:720px;">
            <header class="row" style="justify-content:space-between; align-items:center;">
              <div class="modal-title" id="sl-sch-title">Add Schools</div>
              <button class="modal-close" id="sl-sch-close" aria-label="Close" style="font-size:20px;">×</button>
            </header>
            <div class="table-wrap">
              <table class="table">
                <thead><tr><th style="width:8%;">Add</th><th>School</th><th style="width:20%;">Type</th><th style="width:18%;">Category</th></tr></thead>
                <tbody id="sl-sch-body">
                  <tr><td colspan="4" class="empty">Loading...</td></tr>
                </tbody>
              </table>
            </div>
            <div class="row" style="margin-top:10px; gap:8px;">
              <button class="btn btn-secondary" id="sl-sch-cancel">Cancel</button>
              <button class="btn" id="sl-sch-apply">Add selected</button>
            </div>
            <div id="sl-sch-status" class="muted" style="margin-top:6px;"></div>
          </div>
        </div>
      </div>

      <!-- COMBAT -->
      <div id="tab-com" class="tabpane" style="display:none;">
        <div class="combat-grid">
          <div class="panel">
            <details open class="panel">
              <summary class="hdr">
                <strong>Vitals</strong>
                <span class="muted">(resources and tension)</span>
              </summary>
              <div class="panel-body">
                <div class="combat-vitals">
                  <label class="muted">HP <input id="cur-hp" type="number" min="0" class="combat-num"></label>
                  <label class="muted">EN <input id="cur-en" type="number" min="0" class="combat-num"></label>
                  <label class="muted">FO <input id="cur-fo" type="number" min="0" class="combat-num"></label>
                  <label class="muted">SP <input id="cur-sp" type="number" min="0" class="combat-num"></label>
                  <label class="muted">Max HP Dmg <input id="max-hp-dmg" type="number" min="0" step="1" class="combat-num"></label>
                  <label class="muted">Tension <input id="tension-value" type="number" min="0" step="1" class="combat-num"></label>
                  <span class="combat-badge">Cap <span id="tension-cap">--</span></span>
                </div>
                <div class="combat-row">
                  <span class="combat-badge">Max HP <span id="combat-max-hp">--</span></span>
                  <span class="combat-badge">Max EN <span id="combat-max-en">--</span></span>
                  <span class="combat-badge">Max FO <span id="combat-max-fo">--</span></span>
                  <span class="combat-badge">Max SP <span id="combat-max-sp">--</span></span>
                </div>
                <div class="combat-row">
                  <span class="combat-badge">MO <span id="combat-der-mo">--</span></span>
                  <span class="combat-badge">Init <span id="combat-der-init">--</span></span>
                  <span class="combat-badge">ET <span id="combat-der-et">--</span></span>
                  <span class="combat-badge">TX <span id="combat-der-tx">--</span></span>
                  <span class="combat-badge">Enc <span id="combat-der-enc">--</span></span>
                </div>
                <div class="combat-row">
                  <button class="btn small" id="combat-take-dmg">Take Damage</button>
                  <button class="btn small" id="combat-take-true">Take True Damage</button>
                  <button class="btn small" id="combat-heal">Heal Damage</button>
                </div>
              </div>
            </details>
          </div>

          <div class="panel">
            <details open class="panel">
              <summary class="hdr">
                <strong>Initiative & Defense</strong>
                <span class="muted">(quick rolls)</span>
              </summary>
              <div class="panel-body">
                <div class="combat-row">
                  <button class="btn small" id="init-roll">Roll Initiative</button>
                </div>
                <div class="combat-row">
                  <button class="btn small" id="def-roll">Roll Defense</button>
                </div>
                <div class="combat-row">
                  <label class="muted">Strategy
                    <select id="tension-strategy">
                      <option>Offensive</option>
                      <option>Defensive</option>
                      <option>Supportive</option>
                      <option>Magical</option>
                      <option>Mobile</option>
                    </select>
                  </label>
                  <label class="muted">
                    <input type="checkbox" id="combat-exhausted"> Exhausted
                  </label>
                </div>
              </div>
            </details>
          </div>

          <div class="panel">
            <details open class="panel">
              <summary class="hdr">
                <strong>Death Saves & Critical Injuries</strong>
                <span class="muted">(tracking)</span>
              </summary>
              <div class="panel-body">
                <div class="combat-actions-row">
                  <button class="btn small" id="crit-add">Take Critical Injury</button>
                  <button class="btn small" id="death-save-roll">Roll Death Save</button>
                  <button class="btn small" id="death-save-success-add">+ Success</button>
                  <button class="btn small" id="death-save-fail-add">+ Failure</button>
                  <button class="btn small" id="death-save-stabilize">Stabilize</button>
                  <button class="btn small" id="death-save-reset">Reset Saves</button>
                  <button class="btn small" id="death-reset">Reset Death</button>
                </div>
                <div class="combat-row">
                  <span class="combat-badge">Successes <span id="death-save-success">0</span></span>
                  <span class="combat-badge">Failures <span id="death-save-fail">0</span></span>
                  <span class="combat-badge" id="death-status">Alive</span>
                </div>
                <div id="crit-list" class="combat-list" style="margin-top:8px;"></div>
              </div>
            </details>
          </div>

          <div class="panel">
            <details open class="panel">
              <summary class="hdr">
                <strong>Weapons</strong>
                <span class="muted">(equipped)</span>
              </summary>
              <div class="panel-body">
                <div id="combat-weapon-list" class="combat-list"></div>
              </div>
            </details>
          </div>

          <div class="panel">
            <details open class="panel">
              <summary class="hdr">
                <strong>Actions</strong>
                <span class="muted">(contextual menus)</span>
              </summary>
              <div class="panel-body">
                <div class="combat-actions-row">
                  <button class="btn small" id="combat-open-secondary">Use Secondary Action</button>
                  <button class="btn small" id="combat-open-context">Use Contextual Action</button>
                  <button class="btn small" id="combat-open-special">Use Special Action</button>
                  <button class="btn small" id="combat-open-ability">Use Ability</button>
                  <button class="btn small" id="combat-open-spell">Use Spells</button>
                  <span class="combat-badge">ET Used: <span id="combat-et-used">0</span></span>
                </div>
                <div class="muted" style="margin-top:8px;">Active abilities</div>
                <div id="combat-active-abilities" class="combat-pill-list" style="margin-top:6px;"></div>
              </div>
            </details>
          </div>

          <div class="panel">
            <details open class="panel">
              <summary class="hdr">
                <strong>Conditions</strong>
                <span class="muted">(active effects)</span>
              </summary>
              <div class="panel-body">
                <div class="combat-row">
                  <button class="btn small" id="conditions-add">Add Condition</button>
                </div>
                <div id="conditions-list" class="combat-list"></div>
              </div>
            </details>
          </div>

          <div class="panel">
            <details open class="panel">
              <summary class="hdr">
                <strong>Rest & Eat</strong>
                <span class="muted">(recovery)</span>
              </summary>
              <div class="panel-body">
                <button class="btn small" id="rest-open">Rest & Eat</button>
              </div>
            </details>
          </div>
        </div>
      </div>
      <div id="tab-per" class="tabpane" style="display:none;">
        <div class="panel">
          <details open class="panel">
            <summary class="hdr"><strong>Personal</strong><span class="muted">(freeform character info)</span></summary>
            <div class="panel-body">
              <div class="personal-grid">
                <label class="kv-field">
                  <span class="k">Nicknames</span>
                  <input id="p-nicknames" placeholder="Aliases or epithets">
                </label>
                <label class="kv-field">
                  <span class="k">Height</span>
                  <input id="p-height" placeholder="e.g. 1.80 m">
                </label>
                <label class="kv-field">
                  <span class="k">Weight</span>
                  <input id="p-weight" placeholder="e.g. 75 kg">
                </label>
                <label class="kv-field">
                  <span class="k">Elo</span>
                  <input id="p-elo" placeholder="Rating / score">
                </label>
                <label class="kv-field">
                  <span class="k">Rank</span>
                  <input id="p-rank" placeholder="Rank or title">
                </label>
              </div>

              <div class="personal-grid">
                <label class="kv-field">
                  <span class="k">Friends</span>
                  <div id="p-friends" class="richtext" contenteditable="true" data-placeholder="Allies, contacts"></div>
                </label>
                <label class="kv-field">
                  <span class="k">Enemies</span>
                  <div id="p-enemies" class="richtext" contenteditable="true" data-placeholder="Rivals, threats"></div>
                </label>
              </div>

              <label class="kv-field">
                <span class="k">Notes</span>
                <div id="p-notes" class="richtext" contenteditable="true" data-placeholder="Any additional notes"></div>
              </label>

              <label class="kv-field">
                <span class="k">Backstory</span>
                <div id="p-backstory" class="richtext" contenteditable="true" data-placeholder="Describe the character's history"></div>
              </label>
            </div>
          </details>
        </div>
      </div>
    </div>

    </div>
    <aside class="roll-chat" id="roll-chat">
      <div class="roll-chat-panel" id="roll-log-panel">
        <div class="roll-chat-header">
          <strong>Roll Log</strong>
          <span class="muted" id="roll-log-count"></span>
          <button class="btn small right" id="roll-log-clear">Clear</button>
        </div>
        <div class="roll-chat-body" id="roll-log">
          <div class="muted" id="roll-log-empty">No rolls yet.</div>
        </div>
      </div>
      <div class="roll-chat-panel" id="campaign-chat-panel" style="display:none;">
        <div class="roll-chat-header">
          <strong>Campaign Chat</strong>
          <span class="muted" id="campaign-chat-status"></span>
        </div>
        <div class="chat-log" id="campaign-chat-log"></div>
        <div class="chat-controls">
          <span class="muted">Speaker</span>
          <span class="pill" id="campaign-chat-speaker">--</span>
          <label class="muted">Visibility
            <select id="campaign-chat-visibility" data-readonly-allow="true">
              <option value="public">Public</option>
              <option value="whisper">Whisper</option>
              <option value="self">Self</option>
            </select>
          </label>
        </div>
        <textarea id="campaign-chat-input" data-readonly-allow="true" placeholder="Type a message, or /r 2d6+1 adv"></textarea>
        <div class="row">
          <button class="btn small" id="campaign-chat-send" data-readonly-allow="true">Send</button>
          <span class="muted">Commands: /r XdY +Z adv|dis, /w or /s for visibility.</span>
        </div>
      </div>
    </aside>
  </div></div>

<!-- Avatar modal -->
<div id="avatar-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="avatar-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="avatar-title">
  <div class="modal-card">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="avatar-title">Set Avatar</div>
      <button class="modal-close" id="avatar-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap;">
      <input type="file" id="avatar-file" accept="image/png,image/jpeg">
      <label class="muted">Zoom <input id="avatar-zoom" type="range" min="1" max="3" step="0.05" value="1"></label>
      <label class="muted">Offset X <input id="avatar-offset-x" type="range" min="-120" max="120" step="2" value="0"></label>
      <label class="muted">Offset Y <input id="avatar-offset-y" type="range" min="-120" max="120" step="2" value="0"></label>
    </div>
    <canvas id="avatar-canvas" width="256" height="256" class="avatar-crop" style="margin-top:10px;"></canvas>
    <div class="row" style="margin-top:12px; gap:10px;">
      <button class="btn" id="avatar-upload">Upload</button>
      <button class="btn btn-secondary" id="avatar-cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Funds modal -->
<div id="inv-fund-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="inv-fund-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="inv-fund-title">
  <div class="modal-card" style="max-width:540px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="inv-fund-title">Add / Remove funds</div>
      <button class="modal-close" id="inv-fund-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:8px; flex-wrap:wrap; margin-top:8px;">
      <label class="muted">Currency</label>
      <select id="inv-fund-cur"></select>
      <input id="inv-fund-amt" type="number" step="1" placeholder="Amount (use negative for removal)" style="width:160px;">
      <input id="inv-fund-note" placeholder="Note (optional)" style="flex:1; min-width:220px;">
    </div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button id="inv-fund-save" class="btn">Apply</button>
      <button id="inv-fund-cancel" class="btn btn-secondary">Cancel</button>
    </div>
    <div id="inv-fund-status" class="muted" style="margin-top:6px;"></div>
  </div>
</div>

<!-- Catalog modal -->
<div id="inv-catalog-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="inv-catalog-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="inv-catalog-title">
  <div class="modal-card" style="max-width:980px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="inv-catalog-title">Add from Catalog</div>
      <button class="modal-close" id="inv-catalog-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:6px;">
      <input id="inv-q" placeholder="Search name" style="flex:1">
      <input id="inv-tag" placeholder="Filter tag" style="min-width:180px;">
      <select id="inv-kind">
        <option value="object">Objects</option>
        <option value="weapon">Weapons</option>
        <option value="equipment">Equipment</option>
        <option value="tool">Tools</option>
      </select>
      <select id="inv-cat-select">
        <option value="__all">All</option>
      </select>
      <select id="inv-limit">
        <option>25</option>
        <option selected>50</option>
        <option>100</option>
      </select>
      <input id="inv-price-mod" type="number" step="0.05" min="0" value="1" style="width:120px;" title="Price modifier (e.g. 0.9 for 10% discount, 1.2 for 20% markup)">
      <button id="inv-search" class="btn small">Search</button>
      <button id="inv-clear" class="btn btn-secondary small">Clear</button>
    </div>
    <div class="row" style="gap:10px; margin-top:8px; flex-wrap:wrap;">
      <label class="muted">Container</label>
      <select id="inv-global-cont"></select>
      <label class="muted">Currency</label>
      <select id="inv-global-cur"></select>
      <label class="muted">Equipped?</label>
      <select id="inv-equpped-flag">
        <option value="0" selected>No</option>
        <option value="1">Yes</option>
      </select>
    </div>
    <div id="inv-results" class="list" style="margin-top:10px; max-height:420px; overflow:auto;"></div>
  </div>
</div>

<!-- Sublimation modal -->
<div id="sub-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="sub-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="sub-title">
  <div class="modal-card" style="max-width:520px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="sub-title">Add sublimation</div>
      <button class="modal-close" id="sub-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:8px; flex-wrap:wrap; margin-top:8px;">
      <label class="muted">Type
        <select id="sub-type">
          <option value="lethality">Lethality</option>
          <option value="blessing">Blessing</option>
          <option value="excellence">Excellence</option>
          <option value="defense">Defense</option>
          <option value="speed">Speed</option>
          <option value="devastation">Devastation</option>
          <option value="clarity">Clarity</option>
          <option value="endurance">Endurance</option>
        </select>
      </label>
      <label class="muted">Tier
        <select id="sub-tier">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
        </select>
      </label>
      <label class="muted" id="sub-skill-label" style="display:none;">Target skill
        <select id="sub-skill"></select>
      </label>
      <label class="muted" id="sub-nature-label" style="display:none;">Nature
        <select id="sub-nature"></select>
      </label>
    </div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn" id="sub-add-btn">Add</button>
      <button class="btn btn-secondary" id="sub-cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Combat damage modal -->
<div id="combat-dmg-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-dmg-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-dmg-title">
  <div class="modal-card" style="max-width:420px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-dmg-title">Take Damage</div>
      <button class="modal-close" id="combat-dmg-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:8px; flex-wrap:wrap; margin-top:8px;">
      <input id="combat-dmg-input" type="number" min="0" step="1" placeholder="Amount" class="combat-num">
    </div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn" id="combat-dmg-apply">Apply</button>
      <button class="btn btn-secondary" id="combat-dmg-cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Combat defense modal -->
<div id="combat-def-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-def-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-def-title">
  <div class="modal-card" style="max-width:720px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-def-title">Roll Defense</div>
      <button class="modal-close" id="combat-def-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:8px;">
      <label class="muted">Defense skill
        <select id="def-skill"></select>
      </label>
      <label class="muted">Mod
        <input id="def-mod" type="number" step="1" value="0" class="combat-num">
      </label>
    </div>
    <div class="combat-block" style="margin-top:10px;">
      <div class="combat-header">
        <strong>Defense list</strong>
        <span class="muted">Add/remove skills</span>
      </div>
      <div id="def-skill-list" class="combat-pill-list" style="margin:8px 0;"></div>
      <div class="combat-row">
        <select id="def-add-skill" style="min-width:220px;"></select>
        <input id="def-add-custom" placeholder="Custom skill name" style="min-width:180px;">
        <button class="btn small" id="def-add-btn">Add</button>
      </div>
    </div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn" id="def-roll-confirm">Roll Defense</button>
      <button class="btn btn-secondary" id="combat-def-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Combat attack modal -->
<div id="combat-attack-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-attack-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-attack-title">
  <div class="modal-card" style="max-width:720px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-attack-title">Weapon Attack</div>
      <button class="modal-close" id="combat-attack-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:8px;">
      <label class="muted">Attack type
        <select id="combat-attack-type">
          <option value="simple">Simple Attack</option>
          <option value="special">Special Attack</option>
        </select>
      </label>
      <label class="muted"><input type="checkbox" id="combat-attack-offhand"> Offhand</label>
    </div>
    <div id="combat-attack-specials" class="combat-list" style="margin-top:10px;"></div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn" id="combat-attack-roll">Roll Attack</button>
      <button class="btn btn-secondary" id="combat-attack-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Combat secondary actions modal -->
<div id="combat-secondary-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-secondary-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-secondary-title">
  <div class="modal-card" style="max-width:820px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-secondary-title">Secondary Actions</div>
      <button class="modal-close" id="combat-secondary-close" aria-label="Close">&times;</button>
    </header>
    <div id="combat-actions" class="combat-actions-grid" style="margin-top:8px;"></div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn btn-secondary" id="combat-secondary-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Combat contextual actions modal -->
<div id="combat-context-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-context-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-context-title">
  <div class="modal-card" style="max-width:820px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-context-title">Contextual Actions</div>
      <button class="modal-close" id="combat-context-close" aria-label="Close">&times;</button>
    </header>
    <div id="combat-context-actions" class="combat-actions-grid" style="margin-top:8px;"></div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn btn-secondary" id="combat-context-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Combat special actions modal -->
<div id="combat-special-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-special-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-special-title">
  <div class="modal-card" style="max-width:820px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-special-title">Special Actions</div>
      <button class="modal-close" id="combat-special-close" aria-label="Close">&times;</button>
    </header>
    <div id="combat-special-actions" class="combat-actions-grid" style="margin-top:8px;"></div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn btn-secondary" id="combat-special-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Combat ability modal -->
<div id="combat-ability-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-ability-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-ability-title">
  <div class="modal-card" style="max-width:900px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-ability-title">Use Ability</div>
      <button class="modal-close" id="combat-ability-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:6px;">
      <input id="combat-ability-search" placeholder="Filter abilities" style="flex:1; min-width:220px;">
    </div>
    <div id="combat-ability-list" class="combat-list" style="margin-top:8px;"></div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn btn-secondary" id="combat-ability-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Combat spell modal -->
<div id="combat-spell-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-spell-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-spell-title">
  <div class="modal-card" style="max-width:900px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-spell-title">Use Spells</div>
      <button class="modal-close" id="combat-spell-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:6px;">
      <input id="combat-spell-search" placeholder="Filter spells" style="flex:1; min-width:220px;">
    </div>
    <div id="combat-spell-list" class="combat-list" style="margin-top:8px;"></div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn btn-secondary" id="combat-spell-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Combat conditions modal -->
<div id="combat-conditions-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-conditions-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-conditions-title">
  <div class="modal-card" style="max-width:900px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-conditions-title">Add Conditions</div>
      <button class="modal-close" id="combat-conditions-close" aria-label="Close">&times;</button>
    </header>
    <div id="conditions-modal-list" class="combat-actions-grid" style="margin-top:8px;"></div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn btn-secondary" id="combat-conditions-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Combat rest modal -->
<div id="combat-rest-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="combat-rest-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="combat-rest-title">
  <div class="modal-card" style="max-width:720px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="combat-rest-title">Rest & Eat</div>
      <button class="modal-close" id="combat-rest-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:8px;">
      <label class="muted">Rest type
        <select id="rest-type">
          <option value="total">Total Rest (24h)</option>
          <option value="long">Long Rest (8h)</option>
          <option value="nap">Nap (1h)</option>
          <option value="light">Light Sleep (6h)</option>
          <option value="watch">Watch Shift (2h)</option>
        </select>
      </label>
      <label class="muted">Quality
        <select id="rest-quality">
          <option value="abysmal">Abysmal</option>
          <option value="rudimentary">Rudimentary</option>
          <option value="adequate" selected>Adequate</option>
          <option value="good">Good Quality</option>
          <option value="luxurious">Luxurious</option>
        </select>
      </label>
      <button class="btn small" id="rest-apply">Apply Rest</button>
    </div>
    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:8px;">
      <label class="muted">Food quality
        <select id="eat-quality">
          <option value="spoiled">Spoiled</option>
          <option value="mediocre">Mediocre</option>
          <option value="adequate" selected>Adequate</option>
          <option value="good">Good Quality</option>
          <option value="excellent">Excellent</option>
        </select>
      </label>
      <button class="btn small" id="eat-apply">Eat</button>
    </div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn btn-secondary" id="combat-rest-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Abilities modal -->
<div id="abi-add-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="abi-add-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="abi-add-title">
  <div class="modal-card" style="max-width:960px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="abi-add-title">Add Ability</div>
      <button class="modal-close" id="abi-add-close" aria-label="Close">&times;</button>
    </header>
    <div class="abi-add" style="margin:10px 0;">
      <input id="abi-search" placeholder="Search ability by name" />
      <select id="abi-filter-type">
        <option value="">Any type</option>
        <option value="active">Active</option>
        <option value="passive">Passive</option>
        <option value="mixed">Mixed</option>
      </select>
      <select id="abi-filter-source">
        <option value="">Any source</option>
        <option value="Specie">Specie</option>
        <option value="Boon">Boon</option>
        <option value="Talent">Talent</option>
        <option value="Archetype">Archetype</option>
        <option value="Expertise">Expertise</option>
        <option value="Divine Manifestation">Divine Manifestation</option>
        <option value="Awakening">Awakening</option>
        <option value="Apotheosis">Apotheosis</option>
        <option value="Other">Other</option>
      </select>
      <input id="abi-filter-tag" placeholder="Filter tag (comma-separated)" />
      <button id="abi-search-btn">Find</button>
    </div>
    <div id="abi-results" class="abi-list" style="margin-bottom:12px;"></div>
    <div class="row" style="gap:8px; justify-content:flex-end;">
      <button class="btn btn-secondary" id="abi-add-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Expertise / Divine Manifestation modal -->
<div id="source-add-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="source-add-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="source-add-title">
  <div class="modal-card" style="max-width:960px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="source-add-title">Add Expertise</div>
      <button class="modal-close" id="source-add-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; flex-wrap:wrap; margin-bottom:8px;">
      <input id="source-search" placeholder="Search..." style="flex:1; min-width:240px;">
      <button class="btn" id="source-search-btn">Search</button>
    </div>
    <div id="source-results" class="abi-list" style="margin-bottom:12px;"></div>
    <div class="row" style="gap:8px; justify-content:flex-end;">
      <button class="btn btn-secondary" id="source-add-cancel">Close</button>
    </div>
  </div>
</div>

<!-- Ability choice config modal -->
<div id="choice-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="choice-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="choice-title">
  <div class="modal-card" style="max-width:720px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="choice-title">Configure choices</div>
      <button class="modal-close" id="choice-close" aria-label="Close">&times;</button>
    </header>
    <div id="choice-body" class="list" style="margin-top:10px;"></div>
    <div class="row" style="justify-content:flex-end; gap:8px; margin-top:12px;">
      <button class="btn" id="choice-cancel">Cancel</button>
      <button class="btn" id="choice-save">Save</button>
    </div>
  </div>
</div>

<!-- Ability title color modal -->
<div id="title-color-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="title-color-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="title-color-title">
  <div class="modal-card color-picker-card">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="title-color-title">Title color</div>
      <button class="modal-close" id="title-color-close" aria-label="Close">x</button>
    </header>
    <div class="color-preview-row">
      <div class="color-preview-chip" id="title-color-preview"></div>
      <div>
        <div class="muted" style="font-size:.85rem;">Selected title</div>
        <div class="color-preview-title" id="title-color-preview-text">Title</div>
        <div class="muted" id="title-color-preview-value" style="font-size:.8rem;"></div>
      </div>
    </div>
    <label class="muted" for="title-color-hue">Gradient</label>
    <div class="color-gradient-track" style="margin-top:6px;">
      <input type="range" id="title-color-hue" min="0" max="360" step="1" value="0">
    </div>
    <div class="muted" style="margin-top:10px;">Palette</div>
    <div class="color-palette" id="title-color-palette">
      <button class="color-swatch" data-color="#e5484d" data-name="Red" style="--swatch:#e5484d" aria-label="Red"></button>
      <button class="color-swatch" data-color="#f59f00" data-name="Orange" style="--swatch:#f59f00" aria-label="Orange"></button>
      <button class="color-swatch" data-color="#f2c94c" data-name="Yellow" style="--swatch:#f2c94c" aria-label="Yellow"></button>
      <button class="color-swatch" data-color="#30c56b" data-name="Green" style="--swatch:#30c56b" aria-label="Green"></button>
      <button class="color-swatch" data-color="#2ac9c1" data-name="Teal" style="--swatch:#2ac9c1" aria-label="Teal"></button>
      <button class="color-swatch" data-color="#3b82f6" data-name="Blue" style="--swatch:#3b82f6" aria-label="Blue"></button>
      <button class="color-swatch" data-color="#6366f1" data-name="Indigo" style="--swatch:#6366f1" aria-label="Indigo"></button>
      <button class="color-swatch" data-color="#9b5de5" data-name="Purple" style="--swatch:#9b5de5" aria-label="Purple"></button>
      <button class="color-swatch" data-color="#ec4899" data-name="Pink" style="--swatch:#ec4899" aria-label="Pink"></button>
      <button class="color-swatch" data-color="#a0aec0" data-name="Gray" style="--swatch:#a0aec0" aria-label="Gray"></button>
    </div>
    <div class="row" style="justify-content:flex-end; gap:8px; margin-top:12px;">
      <button class="btn btn-secondary" id="title-color-clear">Clear</button>
      <button class="btn btn-secondary" id="title-color-cancel">Cancel</button>
      <button class="btn" id="title-color-apply">Apply</button>
    </div>
  </div>
</div>

<!-- Roll modal -->
<div id="roll-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="roll-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="roll-title">
  <div class="modal-card" style="max-width:640px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div>
        <div class="modal-title" id="roll-title">Roll</div>
        <div class="muted" id="roll-subtitle"></div>
      </div>
      <button class="modal-close" id="roll-close" aria-label="Close">&times;</button>
    </header>
    <div class="muted" id="roll-details" style="font-size:.85rem; margin-top:6px;"></div>
    <div class="muted" id="roll-desc" style="font-size:.85rem; margin-top:4px;"></div>
    <div class="roll-grid" id="roll-grid">
      <label>
        <span class="k" id="roll-base-label">Base value</span>
        <input id="roll-base" type="number" readonly>
      </label>
      <label>
        <span class="k">Modifier</span>
        <input id="roll-mod" type="number" step="1" value="0">
      </label>
      <label>
        <span class="k">Target (optional)</span>
        <input id="roll-target" type="number" step="1" placeholder="DC">
      </label>
      <label>
        <span class="k">Advantage</span>
        <select id="roll-adv">
          <option value="normal">Normal</option>
          <option value="adv">Advantage</option>
          <option value="dis">Disadvantage</option>
        </select>
      </label>
    </div>
    <div class="muted" id="roll-conditions-note" style="font-size:.82rem; margin-top:8px;">Jinxed/Motivated apply only when a target is provided.</div>
    <div class="roll-conditions" id="roll-conditions">
      <div class="muted" style="font-size:.85rem; margin-bottom:6px;">Conditions</div>
      <div class="roll-cond-grid">
        <label><input type="checkbox" id="cond-j1"> Slightly Jinxed (-1 on success)</label>
        <label><input type="checkbox" id="cond-j2"> Jinxed (-2 on success)</label>
        <label><input type="checkbox" id="cond-j3"> Severely Jinxed (-3 on success)</label>
        <label><input type="checkbox" id="cond-m1"> Slightly Motivated (+1 on fail)</label>
        <label><input type="checkbox" id="cond-m2"> Motivated (+2 on fail)</label>
        <label><input type="checkbox" id="cond-m3"> Severely Motivated (+3 on fail)</label>
        <label><input type="checkbox" id="cond-reckless"> Reckless (dice max 5)</label>
        <label><input type="checkbox" id="cond-meticulous"> Meticulous (dice min 5)</label>
      </div>
    </div>
    <div class="btn-row" style="justify-content:flex-end;">
      <button class="btn" id="roll-cancel">Cancel</button>
      <button class="btn" id="roll-run">Roll</button>
    </div>
    <div class="muted" id="roll-result" style="margin-top:8px;"></div>
  </div>
</div>

<!-- XP Ledger modal -->
<div id="xp-ledger-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="xp-ledger-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="xp-ledger-title">
  <div class="modal-card" style="max-width:640px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="xp-ledger-title">XP Ledger</div>
      <button class="modal-close" id="xp-ledger-close" aria-label="Close">&times;</button>
    </header>
    <div id="xp-ledger-body" class="list" style="margin-top:10px; display:grid; gap:8px; font-size:.92rem;"></div>
  </div>
</div>

<!-- Critical Injury modal -->
<div id="crit-backdrop" class="modal-backdrop" aria-hidden="true"></div>
<div id="crit-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="crit-title">
  <div class="modal-card" style="max-width:480px;">
    <header class="row" style="justify-content:space-between; align-items:center;">
      <div class="modal-title" id="crit-title">Take Critical Injury</div>
      <button class="modal-close" id="crit-close" aria-label="Close">&times;</button>
    </header>
    <div class="row" style="gap:10px; margin-top:8px; flex-wrap:wrap;">
      <label class="muted">Type
        <select id="crit-type">
          <option value="severe">Severe (DC 10)</option>
          <option value="very">Very Severe (DC 14)</option>
          <option value="mortal">Mortal Injury (DC 16)</option>
        </select>
      </label>
      <label class="muted"><input type="checkbox" id="crit-stable"> Stabilized</label>
    </div>
    <div class="muted" id="crit-note" style="margin-top:8px;"></div>
    <div class="row" style="margin-top:12px; gap:8px;">
      <button class="btn btn-secondary" id="crit-cancel">Cancel</button>
      <button class="btn" id="crit-confirm">Add Injury</button>
    </div>
  </div>
</div>

<script>
/* --- auth helper --- */
function getToken(){ return localStorage.getItem('auth_token') || ''; }
function setCookieToken(tok){ if(!tok) return; document.cookie = `token=${tok}; path=/; SameSite=Lax`; }
function authHeaders(){ const t=getToken(); if(t) setCookieToken(t); return t ? {'Authorization':'Bearer '+t, 'X-Auth-Token':t} : {}; }
async function api(path,opt={}){ const headers = Object.assign({}, opt.headers||{}, authHeaders()); const resp = await fetch(path, { credentials:'include', ...opt, headers }); const ct = resp.headers.get('content-type') || ''; const data = ct.includes('application/json') ? await resp.json() : { status:'error', message: await resp.text() }; if(!resp.ok || data.status==='error') throw new Error(data.message || ('HTTP '+resp.status)); return data; }

/* Constants */
const CHARACS = [
  { key:'reflex',    code:'REF', name:'Reflex',    skills:['Technicity','Dodge','Counter','Reactivity'] },
  { key:'dexterity', code:'DEX', name:'Dexterity', skills:['Accuracy','Evasion','Stealth','Acrobatics'] },
  { key:'body',      code:'BOD', name:'Body',      skills:['Brutality','Blocking','Resistance','Athletics'] },
  { key:'willpower', code:'WIL', name:'Willpower', skills:['Intimidation','Spirit','Instinct','Absorption'] },
  { key:'wisdom',    code:'WIS', name:'Wisdom',    skills:['Survival','Education','Perception','Psychology','Investigation'] },
  { key:'presence',  code:'PRE', name:'Presence',  skills:['Taming','Charm','Charisma','Deception','Persuasion'] },
  { key:'magic',     code:'MAG', name:'Magic',     skills:['Aura','Incantation','Enchantment','Restoration','Potential'] },
  { key:'tech',      code:'TECH',name:'Tech',      skills:['Crafting','Sleight of hand','Alchemy','Medicine','Engineering'] },
];

const NATURES = ['Fire','Lightning','Water','Earth','Wind','Sun','Moon','Ki'];
const INTENSITIES = ['Fire','Water','Earth','Wind','Lightning','Sun','Moon','Ki'];
const SUB_TIER_SLOTS = {1:1, 2:3, 3:5, 4:7};
const SUB_TYPES = [
  { key:'lethality', label:'Lethality' },
  { key:'blessing', label:'Blessing' },
  { key:'excellence', label:'Excellence' },
  { key:'defense', label:'Defense' },
  { key:'speed', label:'Speed' },
  { key:'devastation', label:'Devastation' },
  { key:'clarity', label:'Clarity' },
  { key:'endurance', label:'Endurance' },
];
const QUALITY_ORDER = ['Very Mediocre','Mediocre','Adequate','Good','Very Good','Excellent','Legendary','Mythical','Epic','Divine','Unreal'];
const CRAFT_CATEGORY_ORDER = ['Novice','Apprentice','Disciple','Adept','Mage','Magister','High Mage','Master','Grand Master','Archmage','Supreme Archmage','Avant-Garde'];
const CRAFTOMANCY_TABLE = {
  'Very Mediocre': { category:'Novice', skill:5, die:'d4', dc:3, price:200, hours:10 },
  'Mediocre': { category:'Apprentice', skill:6, die:'d4', dc:5, price:300, hours:15 },
  'Adequate': { category:'Disciple', skill:7, die:'d4', dc:7, price:400, hours:20 },
  'Good': { category:'Adept', skill:8, die:'d6', dc:8, price:500, hours:25 },
  'Very Good': { category:'Mage', skill:9, die:'d6', dc:10, price:750, hours:30 },
  'Excellent': { category:'Magister', skill:10, die:'d8', dc:13, price:875, hours:35 },
  'Legendary': { category:'High Mage', skill:11, die:'d8', dc:15, price:1600, hours:40 },
  'Mythical': { category:'Master', skill:12, die:'d10', dc:23, price:2500, hours:50 },
  'Epic': { category:'Grand Master', skill:13, die:'d10', dc:25, price:6000, hours:60 },
  'Divine': { category:'Archmage', skill:14, die:'d12', dc:30, price:14000, hours:70 },
  'Unreal': { category:'Supreme Archmage', skill:15, die:'d12', dc:25, price:32000, hours:80 },
};

function _archetypeRankForLevel(lvl){
  const thresholds = [[80,12],[70,11],[60,10],[50,9],[40,8],[30,7],[20,6],[10,5],[1,4]];
  const v = Math.max(1, Number(lvl)||1);
  for (const [lv,r] of thresholds){
    if (v >= lv) return r;
  }
  return 1;
}
const TARGET_GROUPS = [
  { label:'Characteristics', options:[
    { value:'char.reflex', label:'Reflex (modifier)' },
    { value:'char.dexterity', label:'Dexterity (modifier)' },
    { value:'char.body', label:'Body (modifier)' },
    { value:'char.wisdom', label:'Wisdom (modifier)' },
    { value:'char.presence', label:'Presence (modifier)' },
    { value:'char.magic', label:'Magic (modifier)' },
    { value:'char.willpower', label:'Willpower (modifier)' },
    { value:'char.tech', label:'Tech (modifier)' },
  ]},
  { label:'Skills', options:[
    { value:'skills.reflex.Technicity', label:'Technicity (Reflex)' },
    { value:'skills.reflex.Dodge', label:'Dodge (Reflex)' },
    { value:'skills.reflex.Counter', label:'Counter (Reflex)' },
    { value:'skills.reflex.Reactivity', label:'Reactivity (Reflex)' },
    { value:'skills.dexterity.Accuracy', label:'Accuracy (Dexterity)' },
    { value:'skills.dexterity.Evasion', label:'Evasion (Dexterity)' },
    { value:'skills.dexterity.Stealth', label:'Stealth (Dexterity)' },
    { value:'skills.dexterity.Acrobatics', label:'Acrobatics (Dexterity)' },
    { value:'skills.body.Brutality', label:'Brutality (Body)' },
    { value:'skills.body.Blocking', label:'Blocking (Body)' },
    { value:'skills.body.Resistance', label:'Resistance (Body)' },
    { value:'skills.body.Athletics', label:'Athletics (Body)' },
    { value:'skills.wisdom.Survival', label:'Survival (Wisdom)' },
    { value:'skills.wisdom.Education', label:'Education (Wisdom)' },
    { value:'skills.wisdom.Perception', label:'Perception (Wisdom)' },
    { value:'skills.wisdom.Psychology', label:'Psychology (Wisdom)' },
    { value:'skills.wisdom.Investigation', label:'Investigation (Wisdom)' },
    { value:'skills.presence.Taming', label:'Taming (Presence)' },
    { value:'skills.presence.Charm', label:'Charm (Presence)' },
    { value:'skills.presence.Charisma', label:'Charisma (Presence)' },
    { value:'skills.presence.Deception', label:'Deception (Presence)' },
    { value:'skills.presence.Persuasion', label:'Persuasion (Presence)' },
    { value:'skills.magic.Aura', label:'Aura (Magic)' },
    { value:'skills.magic.Incantation', label:'Incantation (Magic)' },
    { value:'skills.magic.Enchantment', label:'Enchantment (Magic)' },
    { value:'skills.magic.Restoration', label:'Restoration (Magic)' },
    { value:'skills.magic.Potential', label:'Potential (Magic)' },
    { value:'skills.willpower.Intimidation', label:'Intimidation (Willpower)' },
    { value:'skills.willpower.Spirit', label:'Spirit (Willpower)' },
    { value:'skills.willpower.Instinct', label:'Instinct (Willpower)' },
    { value:'skills.willpower.Absorption', label:'Absorption (Willpower)' },
    { value:'skills.tech.Crafting', label:'Crafting (Tech)' },
    { value:'skills.tech.Sleight of hand', label:'Sleight of hand (Tech)' },
    { value:'skills.tech.Alchemy', label:'Alchemy (Tech)' },
    { value:'skills.tech.Medicine', label:'Medicine (Tech)' },
    { value:'skills.tech.Engineering', label:'Engineering (Tech)' },
  ]},
  { label:'Intensities', options: INTENSITIES.map(n=>({ value:`intensities.${n}`, label:`${n} (Magic)` })) },
  { label:'Derived / Resources', options:[
    { value:'derived.hp', label:'HP' },
    { value:'derived.en', label:'EN' },
    { value:'derived.fo', label:'FO' },
    { value:'derived.mo', label:'MO' },
    { value:'derived.initiative', label:'Initiative' },
    { value:'derived.spcap', label:'SP cap' },
    { value:'derived.enc', label:'Encumbrance' },
    { value:'derived.et', label:'Eclipse Threshold (ET)' },
    { value:'derived.tx', label:'Max Toxicity (TX)' },
  { value:'derived.weapon_neutral', label:'Neutral weapon damage' },
    { value:'derived.talent_max', label:'Talent Max' },
    { value:'derived.skill_points', label:'Skill point pool' },
    { value:'derived.stat_points', label:'Characteristic point pool' },
    { value:'derived.craftomancy_max', label:'Max Craftomancies' },
    { value:'derived.sublimation_slots', label:'Sublimation slots' },
    { value:'derived.complex_schools', label:'Complex schools' },
  ]},
  { label:'Custom', options:[{ value:'__custom__', label:'Custom path...' }]}
];

const SPECIAL_ATTACKS = [
  { name:'Repelling Attack', prereq:'No projectile', effect:'Push the opponent in a straight line. Target is pushed 1 unit for every 2 damage that would have been inflicted.' },
  { name:'Debilitating Attack', prereq:'No projectile', effect:'For every 5 damage you would deal, reduce target EN by 1 (max 5 EN).' },
  { name:'Swiping Attack', prereq:'No projectile', effect:'Attack all individuals in a horizontal Line (3) in front of you. Walls and blocking opponents stop the motion.' },
  { name:'Tackle', prereq:'None', effect:'Force the opponent to fall Prone (True).' },
  { name:'Charge', prereq:'None', effect:'Run straight toward a target within MO. If successful, target suffers 1d4 Neutral damage per square crossed. If movement remains, push them back. If they avoid, you continue and may hit an obstacle, taking Push damage for total distance.' },
  { name:'Suppression Fire', prereq:'Shooting weapon', effect:'Fire a full magazine. If your attack exceeds opponent Spirit, they have Disadvantage on their next attack.' },
  { name:'Grabbing', prereq:'Free hand, Brutality, melee', effect:'Grab target. They are Paralyzed (True). Each turn, roll Brutality vs defense to maintain. MO halved while holding. One grab per free hand.' },
  { name:'Disarmament', prereq:'Free hand, Technicity, melee', effect:'Make an opponent drop their weapon if you succeed.' },
  { name:'Arm Lock', prereq:'Free hand, Accuracy, melee', effect:'Arm lock target, making them Hindered (True). Roll Accuracy vs defense each of their turns to maintain. MO halved while holding. One arm lock per free hand.' },
  { name:'Heavy Attack', prereq:'Two-handed melee', effect:'Use an extra Action to double damage. +1 to Condition DC on hit.' },
  { name:'Destructive Attack', prereq:'Two-handed melee', effect:'No damage unless critical injury. Reduce critical injury threshold by 4.' },
  { name:'Unsettling Attack', prereq:'None', effect:'Reduce target FO by 2. Each Active Effect or Duration-Based Spell has 50% chance to end.' },
  { name:'Kick', prereq:'Range 2 or less', effect:'Unarmed attack deals damage with Reach. If successful, push target 2 units and you become Disturbed (True) for one round.' },
  { name:'Channel Attacks', prereq:'None', effect:'Target becomes Aether-Drained (True) for one round.' },
  { name:'Acrobatic Attack', prereq:'Accuracy', effect:'Perform an Acrobatics to add inertia, deal weapon damage, move 2 squares, and avoid opportunity attacks if success.' },
  { name:'Throw', prereq:'Brutality, melee, free hand', effect:'Athletics vs Athletics. If success, throw target a number of squares equal to roll difference (min 1, max 10). Target must pass Acrobatics vs your Athletics or fall Prone (True). You may lift 25 kg per Athletics point.' },
  { name:'Ultra-Fast Attack', prereq:'Technicity', effect:'Spend an extra Action to perform a Simple Attack and a second attack with Reactivity.' },
  { name:'Weapon Throw', prereq:'Weapon without Ferm, no projectile', effect:'Throw weapon at range = half Athletics. On success, deal Simple Attack damage. Weapon stops at first obstacle.' }
];
const SIMPLE_ATTACK_DESC = "Simple Attack: roll your weapon skill vs defense with no penalty. On success, apply weapon damage. Each weapon can be used once per two actions.";

const SECONDARY_ACTIONS = [
  { name:'Intimidate', attack:'Intimidation', defense:'Spirit', effect:'Your target becomes Disturbed for one round. If the success is overwhelming, the target is Afraid of you instead for 1 round.' },
  { name:'Charm', attack:'Charm', defense:'Spirit', effect:'Your target becomes Disturbed for one round. If the success is overwhelming, the target is Charmed by you instead for 1 round.' },
  { name:'Insult', attack:'Persuasion', defense:'Spirit', effect:'Your target becomes Taunted by you for one round. If the success is overwhelming, the target is Obsessed with you instead for 1 round.' },
  { name:'Hide', attack:'Stealth', defense:'Perception', effect:'You can hide in the presence of a hiding place or in darkness. This will make you invisible to all those who fail their perception check. If the success is overwhelming, you are considered Slightly Motivated for your next attack.' },
  { name:'Feign', attack:'Deception', defense:'Psychology', effect:'You gain a bonus of 1 to your next attack. If the success is overwhelming, gain a bonus of 2 instead.' },
  { name:'Analyze', attack:'Investigation', defense:'Deception', effect:'You can analyze their movements and their way of acting. This allows you to gain the advantage on your next defensive act against them. If your success is overwhelming, gain the advantage on your next offensive act against them as well.' },
  { name:'Gauge', attack:'Potential', defense:'Potential', effect:'Determine the level of magic mastery of an opponent, their nature of eclipse, and an approximation of their remaining EN. If the success is overwhelming, gain the Advantage on the Defensive Act against their next spell.' },
  { name:'Command', attack:'Charisma', defense:'Intimidation', effect:'Give a concise command to your allies to perform a specific task. If you succeed on a charisma check against your opponents\' Intimidation, your allies will gain a bonus of 1 to the necessary acts to fulfill that order until your next round. If your success is overwhelming, they may take their turn immediately (but they will skip their next regular turn).' },
  { name:'Detect', attack:'Instinct or Potential', defense:'Stealth or Potential', effect:'You can roll a Potential or Instinct check with Disadvantage to try to sense the energy or Aura of a concealed opponent against their Stealth or Potential. If you succeed, you guess their exact position if they are within 20m of you. If the success is overwhelming, you have no penalty against them because they are camouflaged or invisible, and they cannot conceal themselves from you for the next 5 Rounds.' }
];

const CONTEXTUAL_ACTIONS = [
  { name:'Disengage', effect:'You are no longer threatened by anyone in this Round.' },
  { name:'Move aside', effect:'You can move a target to a free square within your Melee Range if you succeed on an Athletics roll against their Athletics. If the target consents, no need to pass the check.' },
  { name:'Turnaround', effect:'You cannot be Flanked on that round.' },
  { name:'Defensive Stance', effect:'You are considered Motivated for all your defenses until the next Round.' }
];

const SPECIAL_ACTIONS = [
  { tier:3, name:'Small Dash', effect:'You can move by half your mobility value in one direction (but upward). This movement may trigger one, and only one opportunity attack.' },
  { tier:3, name:'Small Purification', effect:'Cleanse yourself of a random one condition and reduce your Toxicity by 2.' },
  { tier:3, name:'Small Anti-Heal', effect:'Make a target within range suffer from Slowed Metabolism for 2 rounds.' },
  { tier:3, name:'Precise Strike', effect:'Your next attack will deal 12 True Damage.' },
  { tier:3, name:'Substitution', effect:'You can exchange your position with one of a substitution tool, like something marked by a Substitution Scroll, or Substitution Beads.' },
  { tier:6, name:'Dash', effect:'You can move by your mobility value in one direction (but upward). This movement may trigger one, and only one opportunity attack.' },
  { tier:6, name:'Purification', effect:'Cleanse yourself of a random negative or positive condition and reduce your Toxicity by 4.' },
  { tier:6, name:'Anti-Heal', effect:'Make a target within range suffer from Slowed Metabolism for 4 rounds.' },
  { tier:6, name:'Lethal Strike', effect:'Your next attack will deal 24 True Damage.' },
  { tier:6, name:'Higher Substitution', effect:'You can exchange your position with one of a substitution tool, like something or someone marked by a Substitution Scroll, or Substitution.' },
  { tier:9, name:'Small Interruption', effect:'Predict the precise type of action (if it is a spell, what school? If it is an attack, what type?) that your opponent will perform on their next Act. If you do so, you immediately stop their turn.' },
  { tier:9, name:'Rush', effect:'You can move by your mobility value in one direction (also upward). This movement does not trigger any opportunity attack.' },
  { tier:9, name:'Superior Anti-Heal', effect:'Make a target within range suffer from Deficient Metabolism for 4 rounds.' },
  { tier:9, name:'Surgical Strike', effect:'Your next attack will deal 36 True Damage.' },
  { tier:9, name:'Total Substitution', effect:'You can exchange your position with one of a substitution tool, like something or someone marked by a Substitution Scroll, or Substitution. You may also use an invocation as a target for substitution.' },
  { tier:9, name:'Higher Purification', effect:'Cleanse yourself of a chosen negative or positive condition and reduce your Toxicity by 6.' },
  { tier:9, name:'Propulsion', effect:'If the opponent fails an Athletics or Reactivity check against your Condition DC, grab an opponent in Melee Range and throw them as many squares as half your Athletics Base Value behind, in front of, or above you in a straight line.' },
  { tier:12, name:'Interruption', effect:'Predict the precise type of action (if it is a spell, what school? If it is an attack, what type) that your opponent will perform on their next Act. If you do so, you immediately stop their turn and take an attack action against them.' },
  { tier:12, name:'Super Rush', effect:'You can move by your mobility value in one direction (also upward). This movement does not trigger any opportunity attack. You may also choose to change the direction of your Rush midway, but only once.' },
  { tier:12, name:'Extra Action', effect:'Immediately use any of your actions as a Free Action.' },
  { tier:12, name:'Ultimate Block', effect:'Next time you receive damage and before your next turn, ignore that damage if it is neither True Damage nor superior to your max HP.' },
  { tier:12, name:'True Strike', effect:'During this Round, your attacks ignore all of the SP.' },
  { tier:12, name:'Light-speed Propulsion', effect:'If the opponent fails an Athletics or Reactivity check against your Condition DC, grab an opponent in Melee Range and throw them as many squares as half your Athletics Base Value behind, in front of, or above you in a straight line. Then, you rush into their Melee and gain an attack action against them.' },
  { tier:15, name:'Legendary Defense', effect:'If you were supposed to suffer a Critical Injury, don\'t.' },
  { tier:15, name:'Initiative Boost', effect:'Increase your initiative by 5. This will affect the ongoing initiative order.' },
  { tier:15, name:'Fighting Control', effect:'The other teams are unable to use a Special Action for one round.' },
  { tier:15, name:'Legendary Tempo', effect:'Reset all your cooldowns.' },
  { tier:15, name:'Disruption', effect:'Your next Offensive Act will force one target to succeed a Resistance or Potential check vs your Condition DC, or drop one of their Active Ability that you chose.' },
  { tier:18, name:'Tactical Advantage', effect:'Use any of the lower Tension level Special Actions without being Exhausted. You may not use this Special Action again before using any other one.' },
  { tier:18, name:'Second Wind', effect:'With the agreement of the whole team, you may reset the Tension level to 0 and revive a KOed (not dead) ally and bring them back to 25% of their max HP.' },
  { tier:18, name:'Perfect Purification', effect:'Reset your Toxicity Level to 0 and cleanse all your negative effects.' },
  { tier:18, name:'One-Time Opening', effect:'With the agreement of the whole team, you may reset the Tension level to 0 and immediately take another turn.' },
  { tier:18, name:'No mistakes', effect:'The first team that has a member who fails one of its acts suffers -2 on all acts for a full round.' },
  { tier:18, name:'Real Interruption', effect:'Predict the precise type of action (if it is a spell, what school? If it is an attack, what type?) that your opponent will perform on their next Act. If you do so, you immediately stop their turn and take an attack action against them. You may take two guesses instead of one.' }
];

const CONDITION_DEFS = [
  { id:'bleeding-1', name:'Slightly Bleeding', kind:'negative', effect:'Lose 2% max HP as True damage. End with Medicine DC 8.' },
  { id:'bleeding-2', name:'Bleeding', kind:'negative', effect:'Lose 5% max HP as True damage. End with Medicine DC 10.' },
  { id:'bleeding-3', name:'Severely Bleeding', kind:'negative', effect:'Lose 10% max HP as True damage. End with Medicine DC 14.' },
  { id:'burned-1', name:'Slightly Burned', kind:'negative', effect:'Take 5% max HP as Neutral damage. End with Medicine DC 8.' },
  { id:'burned-2', name:'Burned', kind:'negative', effect:'Take 10% max HP as Neutral damage. End with Medicine DC 10.' },
  { id:'burned-3', name:'Severely Burned', kind:'negative', effect:'Take 15% max HP as Neutral damage. End with Medicine DC 14.' },
  { id:'obstructed-1', name:'Slightly Magically Obstructed', kind:'negative', effect:'Whenever you lose EN, lose 1 more. End with Medicine DC 8.' },
  { id:'obstructed-2', name:'Magically Obstructed', kind:'negative', effect:'Whenever you lose EN, lose 2 more. End with Medicine DC 10.' },
  { id:'obstructed-3', name:'Severely Magically Obstructed', kind:'negative', effect:'Whenever you lose EN, lose 3 more. End with Medicine DC 14.' },
  { id:'poisoned-1', name:'Minorly Poisoned', kind:'negative', effect:'Take 2 TX. End with Medicine DC 8.' },
  { id:'poisoned-2', name:'Poisoned', kind:'negative', effect:'Take 4 TX. End with Medicine DC 10.' },
  { id:'poisoned-3', name:'Majorly Poisoned', kind:'negative', effect:'Take 6 TX. End with Medicine DC 14.' },
  { id:'contagious', name:'Contagious', kind:'negative', effect:'Suffer 10 True damage. Spreads to all in melee range. End with Medicine DC 10.' },
  { id:'airborne-contagious', name:'Airborne Contagious', kind:'negative', effect:'Suffer 10 True damage. Spreads in Circle (7). End with Medicine DC 14.' },
  { id:'stunned', name:'Stunned', kind:'negative', effect:'-2 to all defensive acts. End with an Action.' },
  { id:'disturbed', name:'Disturbed', kind:'negative', effect:'-2 to all offensive acts. End with an Action.' },
  { id:'hindered', name:'Hindered', kind:'negative', effect:'-2 to all offensive and defensive acts. End with an Action.' },
  { id:'prone', name:'Prone', kind:'negative', effect:'Disadvantage on offensive acts. Melee attacks against you have Advantage; ranged attacks against you have Disadvantage. End with a full movement action.' },
  { id:'panicked', name:'Panicked', kind:'negative', effect:'Lose 1 FO at start of turn; active effects have 50% chance to end. End with a full turn to calm.' },
  { id:'entangled', name:'Entangled', kind:'negative', effect:'Cannot glide or fly. Movement costs double MO.' },
  { id:'immobilized', name:'Immobilized', kind:'negative', effect:'Cannot move from your square by yourself.' },
  { id:'deafened', name:'Deafened', kind:'negative', effect:'Cannot hear. Automatically fail acts requiring hearing.' },
  { id:'muted', name:'Muted', kind:'negative', effect:'Cannot speak. Automatically fail acts requiring speaking.' },
  { id:'blinded', name:'Blinded', kind:'negative', effect:'Automatically fail acts requiring sight. Disadvantage on attack and defense rolls until sight returns.' },
  { id:'nauseous', name:'Nauseous', kind:'negative', effect:'Cannot consume objects that increase TX.' },
  { id:'charmed', name:'Charmed', kind:'negative', effect:'Cannot target the creature you are charmed by with damaging or negative acts.' },
  { id:'frightened', name:'Frightened', kind:'negative', effect:'Disadvantage on acts targeting the feared creature; cannot move closer to them.' },
  { id:'reckless', name:'Reckless', kind:'negative', effect:'On a dice roll for an act, you cannot roll higher than 5.' },
  { id:'confused', name:'Confused', kind:'negative', effect:'Once per round, if you fail an act targeting an enemy, you lose your next action.' },
  { id:'paralyzed', name:'Paralyzed', kind:'negative', effect:'Unable to defend. Physical defense is 3 + relevant base value.' },
  { id:'aether-drained', name:'Aether-Drained', kind:'negative', effect:'Cannot regenerate or restore EN by any means.' },
  { id:'slowed-metabolism', name:'Slowed Metabolism', kind:'negative', effect:'Every HP heal or shield you receive is halved.' },
  { id:'deficient-metabolism', name:'Deficient Metabolism', kind:'negative', effect:'Every HP heal or shield you receive is ignored.' },
  { id:'taunted', name:'Taunted', kind:'negative', effect:'You must prioritize the creature that taunted you as your target.' },
  { id:'obsessed', name:'Obsessed', kind:'negative', effect:'You must use movement to reach the creature and attack with a weapon.' },
  { id:'unbalanced', name:'Unbalanced', kind:'negative', effect:'-2 to all offensive and defensive acts. When hit or moving, Athletics or Acrobatics DC 11 or fall Prone.' },
  { id:'jinxed-1', name:'Slightly Jinxed', kind:'negative', effect:'If an act would succeed, reduce score by 1.' },
  { id:'jinxed-2', name:'Jinxed', kind:'negative', effect:'If an act would succeed, reduce score by 2.' },
  { id:'jinxed-3', name:'Severely Jinxed', kind:'negative', effect:'If an act would succeed, reduce score by 3.' },
  { id:'incapacitated', name:'Incapacitated', kind:'system', effect:'You cannot take any action or movement.' },
  { id:'unconscious', name:'Unconscious', kind:'system', effect:'Incapacitated, Prone, Muted, Immobilized, and cannot defend.' },
  { id:'exhausted', name:'Exhausted', kind:'system', effect:'Cannot use Special Actions or benefit from Tension. End by spending a full turn to catch your breath.' },
  { id:'locked-down', name:'Locked Down', kind:'magic', effect:'Unable to defend against the next attack; paralyzed until you suffer an attack.' },
  { id:'suppressed', name:'Suppressed', kind:'magic', effect:'All non-True positive conditions you receive are dismissed.' },
  { id:'toughened', name:'Toughened', kind:'positive', effect:'Increase max SP threshold by 15% of max HP.' },
  { id:'accelerated', name:'Accelerated', kind:'positive', effect:'Increase MO by 2.' },
  { id:'improved-metabolism', name:'Improved Metabolism', kind:'positive', effect:'If healing 4 HP or more, heal another 4 HP.' },
  { id:'optimized-metabolism', name:'Optimized Metabolism', kind:'positive', effect:'If healing 4 HP or more, heal another 8 HP.' },
  { id:'inspired', name:'Inspired', kind:'positive', effect:'Your team Tension counts as 2 levels higher.' },
  { id:'relaxed', name:'Relaxed', kind:'positive', effect:'Half FO damage and consumption.' },
  { id:'deeply-relaxed', name:'Deeply Relaxed', kind:'positive', effect:'Ignore FO damage and consumption.' },
  { id:'optimized-magic-1', name:'Slightly Magically Optimized', kind:'positive', effect:'At end of turn, reduce EN consumption by 1.' },
  { id:'optimized-magic-2', name:'Magically Optimized', kind:'positive', effect:'At end of turn, reduce EN consumption by 3.' },
  { id:'optimized-magic-3', name:'Extremely Magically Optimized', kind:'positive', effect:'At end of turn, reduce EN consumption by 5.' },
  { id:'camouflaged', name:'Camouflaged', kind:'positive', effect:'Advantage on Stealth rolls and +1 to all defensive acts.' },
  { id:'meticulous', name:'Meticulous', kind:'positive', effect:'On a dice roll for an act, you cannot roll lower than 5.' },
  { id:'nimble', name:'Nimble', kind:'positive', effect:'Ignore penalties from difficult terrain.' },
  { id:'anchored', name:'Anchored', kind:'positive', effect:'Cannot be forcibly moved by spells or effects.' },
  { id:'sharpened-hearing', name:'Sharpened Hearing', kind:'positive', effect:'You can sense without sight as long as you are not deafened.' },
  { id:'immune', name:'Immune', kind:'magic', effect:'All non-True negative conditions you receive while suppressed are dismissed.' },
  { id:'invisible', name:'Invisible', kind:'magic', effect:'Cannot be seen with normal or dark vision. You may hide as if heavily obscured. Advantage on attack; attacks against you have Disadvantage.' },
  { id:'hasted', name:'Hasted', kind:'magic', effect:'Once per round, if you succeed on an act targeting an enemy, it does not consume your action.' },
  { id:'parachuted', name:'Parachuted', kind:'magic', effect:'Jump value doubled and you do not suffer fall damage.' },
  { id:'cooled-down', name:'Cooled Down', kind:'magic', effect:'All abilities and spells you cast have cooldown reduced by 1.' },
  { id:'blessed', name:'Blessed', kind:'magic', effect:'Deal 6 more damage to all undead creatures and summons.' },
  { id:'infused-1', name:'Slightly Infused', kind:'magic', effect:'Add 2 damage to offensive acts (once per action).' },
  { id:'infused-2', name:'Infused', kind:'magic', effect:'Add 4 damage to offensive acts (once per action).' },
  { id:'infused-3', name:'Extremely Infused', kind:'magic', effect:'Add 6 damage to offensive acts (once per action).' },
  { id:'magical-weapon', name:'Magical Weapon', kind:'magic', effect:'No EN penalty from holding a Technicity, Brutality, or Accuracy weapon.' },
  { id:'motivated-1', name:'Slightly Motivated', kind:'positive', effect:'If an act would fail, add 1 to the score.' },
  { id:'motivated-2', name:'Motivated', kind:'positive', effect:'If an act would fail, add 2 to the score.' },
  { id:'motivated-3', name:'Severely Motivated', kind:'positive', effect:'If an act would fail, add 3 to the score.' }
];
function totalFromInvest(v){ return (parseInt(v||0,10) || 0) + 4; }
function modFromTotal(total){ return Math.floor((Number(total)-10)/2); }
function numOr(v, fb=0){
  const n = Number(v);
  return Number.isFinite(n) ? n : fb;
}
function investVal(v, fb=0){
  if (v && typeof v === 'object') return numOr(v.invest, fb);
  return numOr(v, fb);
}
const lc = (s)=> String(s||'').toLowerCase();
const QUALITY_SLOTS = { "Adequate":1,"Good":2,"Very Good":3,"Excellent":4,"Legendary":5,"Mythical":6,"Epic":7,"Divine":8,"Unreal":9 };
function slotsForQuality(q){ return QUALITY_SLOTS[q] || 0; }
function qualityStepDelta(q){
  const baseIdx = QUALITY_ORDER.findIndex(x=> lc(x) === 'adequate');
  const idx = QUALITY_ORDER.findIndex(x=> lc(x) === lc(q));
  if (idx === -1 || baseIdx === -1) return 0;
  return Math.max(0, (idx - baseIdx) + 1);
}
function debounce(fn, ms=300){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }
function qualityStepFromNote(note){
  if (!note) return 0;
  const m = String(note).match(/([+-]?\d+(?:\.\d+)?)\s*(?:per\s+quality|\/\s*quality)/i);
  return m ? Number(m[1]) || 0 : 0;
}
function craftRowForQuality(q){
  const key = String(q || '').trim();
  return { ...(CRAFTOMANCY_TABLE[key] || CRAFTOMANCY_TABLE['Adequate']) };
}
function craftCategoryIndex(cat){
  const idx = CRAFT_CATEGORY_ORDER.indexOf(String(cat || '').trim());
  return idx < 0 ? -1 : idx;
}
function craftNextCategory(cat){
  const idx = craftCategoryIndex(cat);
  if (idx < 0 || idx + 1 >= CRAFT_CATEGORY_ORDER.length) return null;
  return CRAFT_CATEGORY_ORDER[idx + 1];
}
function craftSpellIsComplex(sp){
  if (!sp || !Array.isArray(sp.schools) || !SCHOOLS.length) return false;
  return sp.schools.some(s=>{
    const hit = (SCHOOLS || []).find(sc=> String(sc.id) === String(s.id));
    const st = (hit?.school_type || hit?.type || '').toLowerCase();
    return st === 'complex';
  });
}
const MAX_LEVEL = 100;
function xpForLevel(level){
  const lvl = Math.max(1, Math.min(MAX_LEVEL, Math.floor(level||1)));
  return 100 * ((lvl-1) * lvl / 2);
}
function levelFromXp(xp){
  const val = Math.max(0, Math.floor(xp||0));
  let lvl = 1;
  for (let i=1;i<MAX_LEVEL;i++){
    const next = xpForLevel(i+1);
    if (val < next) break;
    lvl = i+1;
  }
  return lvl;
}

/* State */
const params = new URLSearchParams(location.search);
const CID = params.get('id');
const CAMPAIGN_ID = params.get('cid') || '';
const VIEW_ONLY = params.get('view') === '1' || params.get('mode') === 'viewer';
let ROLE = 'user';
let CURRENT_USER = null;
let CAMPAIGN_INFO = null;
let CAMPAIGN_CHAT_MESSAGES = [];
let CAMPAIGN_CHAT_MESSAGE_IDS = new Set();
let CAMPAIGN_CHAT_API_OK = true;
let CAMPAIGN_CHAT_READY = false;
let CAMPAIGN_CHAT_POLL = null;
let CAMPAIGN_CHAT_REFRESH_TIMER = null;
let CAMPAIGN_CHAT_WS = null;
let CAMPAIGN_CHAT_WS_RETRY = null;
const CAMPAIGN_CHAT_STORAGE_KEY = CAMPAIGN_ID ? `campaign_chat_local:${CAMPAIGN_ID}` : '';
let READ_ONLY = false;
let CAN_EDIT = false;
let SAVE_TIMER = null;
let CHAR = null;
let ASSIGNED = []; // full documents of assigned abilities (resolved by id)
let ARC_ASSIGNED = []; // full documents of archetype abilities (resolved by id)
let EXP_ASSIGNED = []; // full documents of expertise abilities (resolved by id)
let DIMA_ASSIGNED = []; // full documents of divine manifestation abilities (resolved by id)
let ABI_SORT_PASSIVE = 'manual';
let ABI_SORT_ACTIVE = 'manual';
let ABI_SORT_SPELLS = 'manual';
let COMPUTED_EXP_ABILITIES = [];
let COMPUTED_DIMA_ABILITIES = [];
let ABILITY_CHOICES = {}; // per-ability user selections for configurable modifiers (choices or groups)
let ITEM_CHOICES = {}; // per-item (inventory) user selections for choice-based modifiers
let TITLE_COLOR_MAP = {};
let INVENTORIES = [];
let LINKED_INV = null;
let SELECTED_INV_ID = '';
let WEAPON_CATALOG_BY_ID = {};
let WEAPON_CATALOG_BY_NAME = {};
let WEAPON_CATALOG_PROMISE = null;
let WEAPON_CATALOG_READY = false;
function getInventorySourceId(){
  return SELECTED_INV_ID || LINKED_INV?.id || '';
}
let CRAFT_TARGET_ITEM = null;
let CRAFT_SEARCH_RESULTS = [];
let INV_LAST_RESULTS = [];
let INV_FILTERED = [];
let SPELL_LISTS = [];
let LINKED_SPELL_LIST = null;
let SELECTED_SPELL_LIST_ID = '';
let SPELLLIST_SPELLS = [];
let SPELLLIST_META = {};
let ADDED_SCHOOLS = new Set();
const setAddedSchools = (arr=[])=>{
  ADDED_SCHOOLS = new Set((arr || []).map(String));
  if (CHAR && CHAR.stats) CHAR.stats.selected_schools = Array.from(ADDED_SCHOOLS);
  renderSchoolSpellCounters();
  if (slSchOrderEl) slSchOrderEl.value = 'manual';
  setSchoolOrderStatus('');
};
let XP = 0;
let XP_LEDGER = [];
let SCHOOLS = [];
let SUBLIMATIONS = [];
let SUB_HIDDEN = {};
let PERSONAL = {};
let CURRENT = { hp:null, en:null, fo:null, sp:null };
let OVERRIDE_ENABLED = false;
let OVERRIDE_VALUES = { hp:null, en:null, fo:null, mo:null, initiative:null, spcap:null, enc:null, et:null, tx:null, talent_max:null, skill_points:null, stat_points:null, sublimation_slots:null, complex_schools:null };
let ARCHETYPES = [];
let EXPERTISES = [];
let DIVINE_MANIFESTATIONS = [];
let SPECIES_ABILITIES = [];
let BOON_ABILITIES = [];
let COMPUTED_ARC_ABILITIES = [];
let UPGRADE_META = {};
let TALENT_MAX = 1;
let INITIAL_LOAD = true;

let REFRESH_NOTICE_QUEUE = [];
let REFRESH_NOTICE_TIMER = null;
const ABI_ORDER_STORAGE_PREFIX = 'abi_order:';
function queueRefreshNotice(msg){
  if (!msg) return;
  REFRESH_NOTICE_QUEUE.push(msg);
  if (REFRESH_NOTICE_TIMER) return;
  REFRESH_NOTICE_TIMER = setTimeout(()=>{
    const uniq = Array.from(new Set(REFRESH_NOTICE_QUEUE));
    REFRESH_NOTICE_QUEUE = [];
    REFRESH_NOTICE_TIMER = null;
    if (!uniq.length) return;
    alert("Updates found:\n" + uniq.map(m=>`- ${m}`).join("\n"));
  }, 250);
}
function refreshCacheKey(){
  return `refresh-cache:${CID || "unknown"}`;
}
function loadRefreshCache(){
  try{
    const raw = localStorage.getItem(refreshCacheKey());
    return raw ? JSON.parse(raw) : {};
  }catch{
    return {};
  }
}
function saveRefreshCache(cache){
  try{
    localStorage.setItem(refreshCacheKey(), JSON.stringify(cache || {}));
  }catch{}
}
function trackUpdatedAt(kind, items, label){
  if (!INITIAL_LOAD) return;
  const cache = loadRefreshCache();
  const prev = cache[kind] || {};
  const next = {};
  const changed = [];
  (items || []).forEach(it=>{
    const id = String(it?.id || "").trim();
    if (!id) return;
    const ts = String(it?.updated_at || it?.updatedAt || it?.updated || "").trim();
    next[id] = ts;
    if (prev[id] && prev[id] !== ts) changed.push(id);
  });
  cache[kind] = next;
  saveRefreshCache(cache);
  if (changed.length){
    queueRefreshNotice(`${label} updated (${changed.length})`);
  }
}

/* Passive bonus aggregations (recomputed whenever ASSIGNED changes) */
let PASSIVE = {
  char: {},     // key -> { set:[], mul:[], add:[], notes:[] }  (applied to characteristic MOD)
  skill: {},    // "key|skill" -> { set:[], mul:[], add:[], notes:[] } (applied to skill TOTAL)
  school: {},   // schoolId -> { set:[], mul:[], add:[], notes:[] } (applied to MS for that school)
  spell_slots: {}, // simple|complex -> { set:[], mul:[], add:[], notes:[] }
};

/* DOM refs */
const loginChip = document.getElementById('login-chip');
const adminLink = document.getElementById('admin-link');
const titleEl   = document.getElementById('title');
const statusEl  = document.getElementById('status');
const nameEl    = document.getElementById('name');
const publicToggle = document.getElementById('public-toggle');
const readonlyPill = document.getElementById('readonly-pill');
const deleteBtn = document.getElementById('delete-char');
const backLinkEl = document.getElementById('back-link');
const unlinkCampaignBtn = document.getElementById('unlink-campaign');
const gridEl    = document.getElementById('stats-grid');

/* derived refs */
const levelEl = document.getElementById('level');
const hpEl = document.getElementById('hp-val');
const enEl = document.getElementById('en-val');
const foEl = document.getElementById('fo-val');
  const moEl = document.getElementById('mo-val');
  const initEl = document.getElementById('init-val');
const spcapEl = document.getElementById('spcap-val');
const encEl = document.getElementById('enc-val');
const etEl = document.getElementById('et-val');
const txEl = document.getElementById('tx-val');
const weaponNeutralEl = document.getElementById('weapon-neutral-val');
const skillCounterEl = document.getElementById('skill-counter');
const statCounterEl = document.getElementById('stat-counter');
const skillCapEl = document.getElementById('skill-cap');
const statCapEl = document.getElementById('stat-cap');
const overrideToggle = document.getElementById('override-derived');
const overrideInputsWrap = document.getElementById('override-inputs');
const ovHpEl = document.getElementById('ov-hp');
const ovEnEl = document.getElementById('ov-en');
const ovFoEl = document.getElementById('ov-fo');
const ovMoEl = document.getElementById('ov-mo');
const ovSpEl = document.getElementById('ov-spcap');
const ovInitEl = document.getElementById('ov-init');
const ovEncEl = document.getElementById('ov-enc');
const ovEtEl = document.getElementById('ov-et');
const ovTxEl = document.getElementById('ov-tx');
const ovTalentMaxEl = document.getElementById('ov-talent-max');
const ovSkillPointsEl = document.getElementById('ov-skill-points');
const ovStatPointsEl = document.getElementById('ov-stat-points');
const ovSubSlotsEl = document.getElementById('ov-sub-slots');
const ovComplexSchoolsEl = document.getElementById('ov-complex-schools');
const curHpEl = document.getElementById('cur-hp');
const curEnEl = document.getElementById('cur-en');
const curFoEl = document.getElementById('cur-fo');
const curSpEl = document.getElementById('cur-sp');
const maxHpDmgEl = document.getElementById('max-hp-dmg');
const combatMaxHpEl = document.getElementById('combat-max-hp');
const combatMaxEnEl = document.getElementById('combat-max-en');
const combatMaxFoEl = document.getElementById('combat-max-fo');
const combatMaxSpEl = document.getElementById('combat-max-sp');
const combatDerMoEl = document.getElementById('combat-der-mo');
const combatDerInitEl = document.getElementById('combat-der-init');
const combatDerEtEl = document.getElementById('combat-der-et');
const combatDerTxEl = document.getElementById('combat-der-tx');
const combatDerEncEl = document.getElementById('combat-der-enc');
const combatTakeDmgBtn = document.getElementById('combat-take-dmg');
const combatTakeTrueBtn = document.getElementById('combat-take-true');
const combatHealBtn = document.getElementById('combat-heal');
const combatDmgModal = document.getElementById('combat-dmg-modal');
const combatDmgBackdrop = document.getElementById('combat-dmg-backdrop');
const combatDmgTitleEl = document.getElementById('combat-dmg-title');
const combatDmgInputEl = document.getElementById('combat-dmg-input');
const combatDmgApplyBtn = document.getElementById('combat-dmg-apply');
const combatDmgClose = document.getElementById('combat-dmg-close');
const combatDmgCancel = document.getElementById('combat-dmg-cancel');
const defSkillSelectEl = document.getElementById('def-skill');
const defModEl = document.getElementById('def-mod');
const defRollBtn = document.getElementById('def-roll');
const defRollConfirmBtn = document.getElementById('def-roll-confirm');
const defSkillListEl = document.getElementById('def-skill-list');
const defAddSkillEl = document.getElementById('def-add-skill');
const defAddCustomEl = document.getElementById('def-add-custom');
const defAddBtn = document.getElementById('def-add-btn');
const combatDefModal = document.getElementById('combat-def-modal');
const combatDefBackdrop = document.getElementById('combat-def-backdrop');
const combatDefClose = document.getElementById('combat-def-close');
const combatDefCancel = document.getElementById('combat-def-cancel');
const initBaseEl = document.getElementById('init-base');
const initRollBtn = document.getElementById('init-roll');
const initLastEl = document.getElementById('init-last');
const combatWeaponsEl = document.getElementById('combat-weapon-list');
const combatAbilityListEl = document.getElementById('combat-ability-list');
const combatAbilitySearchEl = document.getElementById('combat-ability-search');
const combatSpellListEl = document.getElementById('combat-spell-list');
const combatSpellSearchEl = document.getElementById('combat-spell-search');
const combatEtUsedEl = document.getElementById('combat-et-used');
const combatSecondaryOpenBtn = document.getElementById('combat-open-secondary');
const combatContextOpenBtn = document.getElementById('combat-open-context');
const combatSpecialOpenBtn = document.getElementById('combat-open-special');
const combatAbilityOpenBtn = document.getElementById('combat-open-ability');
const combatSpellOpenBtn = document.getElementById('combat-open-spell');
const tensionValueEl = document.getElementById('tension-value');
const tensionCapEl = document.getElementById('tension-cap');
const tensionStrategyEl = document.getElementById('tension-strategy');
const exhaustedToggleEl = document.getElementById('combat-exhausted');
const combatActionsEl = document.getElementById('combat-actions');
const combatContextActionsEl = document.getElementById('combat-context-actions');
const combatSpecialActionsEl = document.getElementById('combat-special-actions');
const combatActiveAbilitiesEl = document.getElementById('combat-active-abilities');
const combatSpecialAttacksEl = document.getElementById('combat-special-attacks');
const combatSecondaryModal = document.getElementById('combat-secondary-modal');
const combatSecondaryBackdrop = document.getElementById('combat-secondary-backdrop');
const combatSecondaryClose = document.getElementById('combat-secondary-close');
const combatSecondaryCancel = document.getElementById('combat-secondary-cancel');
const combatContextModal = document.getElementById('combat-context-modal');
const combatContextBackdrop = document.getElementById('combat-context-backdrop');
const combatContextClose = document.getElementById('combat-context-close');
const combatContextCancel = document.getElementById('combat-context-cancel');
const combatSpecialModal = document.getElementById('combat-special-modal');
const combatSpecialBackdrop = document.getElementById('combat-special-backdrop');
const combatSpecialClose = document.getElementById('combat-special-close');
const combatSpecialCancel = document.getElementById('combat-special-cancel');
const combatAbilityModal = document.getElementById('combat-ability-modal');
const combatAbilityBackdrop = document.getElementById('combat-ability-backdrop');
const combatAbilityClose = document.getElementById('combat-ability-close');
const combatAbilityCancel = document.getElementById('combat-ability-cancel');
const combatSpellModal = document.getElementById('combat-spell-modal');
const combatSpellBackdrop = document.getElementById('combat-spell-backdrop');
const combatSpellClose = document.getElementById('combat-spell-close');
const combatSpellCancel = document.getElementById('combat-spell-cancel');
const combatConditionsModal = document.getElementById('combat-conditions-modal');
const combatConditionsBackdrop = document.getElementById('combat-conditions-backdrop');
const combatConditionsClose = document.getElementById('combat-conditions-close');
const combatConditionsCancel = document.getElementById('combat-conditions-cancel');
const conditionsModalListEl = document.getElementById('conditions-modal-list');
const conditionsAddBtn = document.getElementById('conditions-add');
const restOpenBtn = document.getElementById('rest-open');
const combatRestModal = document.getElementById('combat-rest-modal');
const combatRestBackdrop = document.getElementById('combat-rest-backdrop');
const combatRestClose = document.getElementById('combat-rest-close');
const combatRestCancel = document.getElementById('combat-rest-cancel');
const combatAttackModal = document.getElementById('combat-attack-modal');
const combatAttackBackdrop = document.getElementById('combat-attack-backdrop');
const combatAttackTitleEl = document.getElementById('combat-attack-title');
const combatAttackTypeEl = document.getElementById('combat-attack-type');
const combatAttackOffhandEl = document.getElementById('combat-attack-offhand');
const combatAttackSpecialsEl = document.getElementById('combat-attack-specials');
const combatAttackRollBtn = document.getElementById('combat-attack-roll');
const combatAttackClose = document.getElementById('combat-attack-close');
const combatAttackCancel = document.getElementById('combat-attack-cancel');
const critListEl = document.getElementById('crit-list');
const critAddBtn = document.getElementById('crit-add');
const deathSaveRollBtn = document.getElementById('death-save-roll');
const deathSaveSuccessEl = document.getElementById('death-save-success');
const deathSaveFailEl = document.getElementById('death-save-fail');
const deathSaveSuccessAddBtn = document.getElementById('death-save-success-add');
const deathSaveFailAddBtn = document.getElementById('death-save-fail-add');
const deathSaveResetBtn = document.getElementById('death-save-reset');
const deathResetBtn = document.getElementById('death-reset');
const deathSaveStabilizeBtn = document.getElementById('death-save-stabilize');
const deathStatusEl = document.getElementById('death-status');
const restTypeEl = document.getElementById('rest-type');
const restQualityEl = document.getElementById('rest-quality');
const restApplyBtn = document.getElementById('rest-apply');
const eatQualityEl = document.getElementById('eat-quality');
const eatApplyBtn = document.getElementById('eat-apply');
const conditionsListEl = document.getElementById('conditions-list');
const critModal = document.getElementById('crit-modal');
const critBackdrop = document.getElementById('crit-backdrop');
const critClose = document.getElementById('crit-close');
const critCancel = document.getElementById('crit-cancel');
const critTypeEl = document.getElementById('crit-type');
const critStableEl = document.getElementById('crit-stable');
const critConfirm = document.getElementById('crit-confirm');
const critNoteEl = document.getElementById('crit-note');
let DERIVED_CACHE = {};

/* Abilities tab refs */
const abiOpenAddBtn = document.getElementById('abi-open-add');
const abiAddModal = document.getElementById('abi-add-modal');
const abiAddBackdrop = document.getElementById('abi-add-backdrop');
const abiAddClose = document.getElementById('abi-add-close');
const abiAddCancel = document.getElementById('abi-add-cancel');
const abiSearchEl = document.getElementById('abi-search');
const abiFilterTypeEl = document.getElementById('abi-filter-type');
const abiFilterSrcEl  = document.getElementById('abi-filter-source');
const abiFilterTagEl  = document.getElementById('abi-filter-tag');
const abiSearchBtn = document.getElementById('abi-search-btn');
const abiResultsEl = document.getElementById('abi-results');
const expOpenAddBtn = document.getElementById('exp-open-add');
const dimaOpenAddBtn = document.getElementById('dima-open-add');
const sourceAddModal = document.getElementById('source-add-modal');
const sourceAddBackdrop = document.getElementById('source-add-backdrop');
const sourceAddClose = document.getElementById('source-add-close');
const sourceAddCancel = document.getElementById('source-add-cancel');
const sourceAddTitle = document.getElementById('source-add-title');
const sourceSearchEl = document.getElementById('source-search');
const sourceSearchBtn = document.getElementById('source-search-btn');
const sourceResultsEl = document.getElementById('source-results');
const listPassiveEl   = document.getElementById('abi-list-passive');
const listActiveEl    = document.getElementById('abi-list-active');
const listSpellEl     = document.getElementById('abi-list-spells');
const abiPassiveOrderEl = document.getElementById('abi-passive-order');
const abiActiveOrderEl  = document.getElementById('abi-active-order');
const abiPassiveSortBtn = document.getElementById('abi-passive-sort');
const abiActiveSortBtn  = document.getElementById('abi-active-sort');
const abiSpellOrderEl = document.getElementById('abi-spell-order');
const abiSpellSortBtn = document.getElementById('abi-spell-sort');
const talentCounterEl = document.getElementById('talent-counter');
const choiceModal = document.getElementById('choice-modal');
const choiceBackdrop = document.getElementById('choice-backdrop');
const choiceClose = document.getElementById('choice-close');
const choiceCancel = document.getElementById('choice-cancel');
const choiceSave = document.getElementById('choice-save');
const choiceBody = document.getElementById('choice-body');
const titleColorModal = document.getElementById('title-color-modal');
const titleColorBackdrop = document.getElementById('title-color-backdrop');
const titleColorClose = document.getElementById('title-color-close');
const titleColorCancel = document.getElementById('title-color-cancel');
const titleColorApply = document.getElementById('title-color-apply');
const titleColorClear = document.getElementById('title-color-clear');
const titleColorHue = document.getElementById('title-color-hue');
const titleColorPreview = document.getElementById('title-color-preview');
const titleColorPreviewText = document.getElementById('title-color-preview-text');
const titleColorPreviewValue = document.getElementById('title-color-preview-value');
const titleColorPalette = document.getElementById('title-color-palette');
const rollModal = document.getElementById('roll-modal');
const rollBackdrop = document.getElementById('roll-backdrop');
const rollClose = document.getElementById('roll-close');
const rollCancel = document.getElementById('roll-cancel');
const rollRun = document.getElementById('roll-run');
const rollTitleEl = document.getElementById('roll-title');
const rollSubtitleEl = document.getElementById('roll-subtitle');
const rollDetailsEl = document.getElementById('roll-details');
const rollDescEl = document.getElementById('roll-desc');
const rollGridEl = document.getElementById('roll-grid');
const rollConditionsEl = document.getElementById('roll-conditions');
const rollConditionsNoteEl = document.getElementById('roll-conditions-note');
const rollBaseLabelEl = document.getElementById('roll-base-label');
const rollBaseEl = document.getElementById('roll-base');
const rollModEl = document.getElementById('roll-mod');
const rollTargetEl = document.getElementById('roll-target');
const rollAdvEl = document.getElementById('roll-adv');
const rollResultEl = document.getElementById('roll-result');
const rollLogEl = document.getElementById('roll-log');
const rollLogEmptyEl = document.getElementById('roll-log-empty');
const rollLogCountEl = document.getElementById('roll-log-count');
const rollLogClear = document.getElementById('roll-log-clear');
const rollLogPanel = document.getElementById('roll-log-panel');
const campaignChatPanel = document.getElementById('campaign-chat-panel');
const campaignChatLog = document.getElementById('campaign-chat-log');
const campaignChatStatus = document.getElementById('campaign-chat-status');
const campaignChatSpeaker = document.getElementById('campaign-chat-speaker');
const campaignChatVisibilityEl = document.getElementById('campaign-chat-visibility');
const campaignChatInput = document.getElementById('campaign-chat-input');
const campaignChatSend = document.getElementById('campaign-chat-send');
const condJ1El = document.getElementById('cond-j1');
const condJ2El = document.getElementById('cond-j2');
const condJ3El = document.getElementById('cond-j3');
const condM1El = document.getElementById('cond-m1');
const condM2El = document.getElementById('cond-m2');
const condM3El = document.getElementById('cond-m3');
const condRecklessEl = document.getElementById('cond-reckless');
const condMeticulousEl = document.getElementById('cond-meticulous');
const choiceTitle = document.getElementById('choice-title');
const speciesSelectEl = document.getElementById('species-select');
const speciesStatusEl = document.getElementById('species-status');
const speciesDescEl = document.getElementById('species-desc');
const boonSelectEl = document.getElementById('boon-select');
const boonStatusEl = document.getElementById('boon-status');
const boonDescEl = document.getElementById('boon-desc');
const arcSelectEl     = document.getElementById('arc-select');
const arcApplyBtn     = document.getElementById('arc-apply');
const arcStatusEl     = document.getElementById('arc-status');
const arcSummaryEl    = document.getElementById('arc-summary');
const arcDescEl       = document.getElementById('arc-description');
const arcAbilitiesEl  = document.getElementById('arc-abilities');
const expSummaryEl    = document.getElementById('exp-summary');
const expAbilitiesEl  = document.getElementById('exp-abilities');
const dimaSummaryEl   = document.getElementById('dima-summary');
const dimaAbilitiesEl = document.getElementById('dima-abilities');
const expPanelEl = document.getElementById('exp-panel');
const dimaPanelEl = document.getElementById('dima-panel');
const expertiseCounterEl = document.getElementById('expertise-counter');
const dimaCounterEl = document.getElementById('dima-counter');
/* Inventory tab refs */
const invSelectEl = document.getElementById('inv-select');
const invLoadBtn = document.getElementById('inv-load-btn');
const invDupLinkBtn = document.getElementById('inv-dup-link');
const invOpenManagerBtn = document.getElementById('inv-open-manager');
const invStatusEl = document.getElementById('inv-status');
const invManagerEl = document.getElementById('inv-manager');
const invTitleEl = document.getElementById('inv-title');
const invMoneyEl = document.getElementById('inv-money');
const invEncTotalEl = document.getElementById('inv-enc-total');
const invFundCurEl = document.getElementById('inv-fund-cur');
const invFundAmtEl = document.getElementById('inv-fund-amt');
const invFundNoteEl = document.getElementById('inv-fund-note');
const invContainersEl = document.getElementById('inv-containers');
const invNewContNameEl = document.getElementById('inv-new-cont-name');
const invAddContBtn = document.getElementById('inv-add-cont');
const invTxEl = document.getElementById('inv-tx');
const invQEl = document.getElementById('inv-q');
const invTagEl = document.getElementById('inv-tag');
const invKindEl = document.getElementById('inv-kind');
const invCatEl = document.getElementById('inv-cat-select');
const invLimitEl = document.getElementById('inv-limit');
const invSearchBtn = document.getElementById('inv-search');
const invClearBtn = document.getElementById('inv-clear');
const invPriceModEl = document.getElementById('inv-price-mod');
const invGlobalContEl = document.getElementById('inv-global-cont');
const invGlobalCurEl = document.getElementById('inv-global-cur');
const invEquippedFlagEl = document.getElementById('inv-equpped-flag');
const invResultsEl = document.getElementById('inv-results');
const invItemModal = document.getElementById('inv-item-modal');
const invItemBackdrop = document.getElementById('inv-item-backdrop');
const invItemTitle = document.getElementById('inv-item-title');
const invItemBody = document.getElementById('inv-item-body');
const invItemActions = document.getElementById('inv-item-actions');
const craftAddModal = document.getElementById('craft-add-modal');
const craftAddBackdrop = document.getElementById('craft-add-backdrop');
const craftAddTitle = document.getElementById('craft-add-title');
const craftAddInfo = document.getElementById('craft-add-info');
const craftAddClose = document.getElementById('craft-add-close');
const craftAddCancel = document.getElementById('craft-add-cancel');
const craftSearchQ = document.getElementById('craft-search-q');
const craftSearchBtn = document.getElementById('craft-search-btn');
const craftSearchBody = document.getElementById('craft-search-body');
const craftAddStatus = document.getElementById('craft-add-status');
const craftSupremeEl = document.getElementById('craft-supreme');
const invFundOpenBtn = document.getElementById('inv-fund-open');
const invFundModal = document.getElementById('inv-fund-modal');
const invFundBackdrop = document.getElementById('inv-fund-backdrop');
const invFundClose = document.getElementById('inv-fund-close');
const invFundSave = document.getElementById('inv-fund-save');
const invFundCancel = document.getElementById('inv-fund-cancel');
const invFundStatus = document.getElementById('inv-fund-status');
const invCatalogOpenBtn = document.getElementById('inv-catalog-open');
const invCreateBtn = document.getElementById('inv-create-btn');
const invCatalogModal = document.getElementById('inv-catalog-modal');
const invCatalogBackdrop = document.getElementById('inv-catalog-backdrop');
const invCatalogClose = document.getElementById('inv-catalog-close');
const SELF_CONTAINER_ID = 'self';
/* Spell list refs */
const avatarPreview = document.getElementById('avatar-preview');
const avatarOpenBtn = document.getElementById('avatar-open');
const avatarFileEl = document.getElementById('avatar-file');
const avatarZoomEl = document.getElementById('avatar-zoom');
const avatarOffsetXEl = document.getElementById('avatar-offset-x');
const avatarOffsetYEl = document.getElementById('avatar-offset-y');
const avatarUploadBtn = document.getElementById('avatar-upload');
const avatarModal = document.getElementById('avatar-modal');
const avatarBackdrop = document.getElementById('avatar-backdrop');
const avatarClose = document.getElementById('avatar-close');
const avatarCancel = document.getElementById('avatar-cancel');
const avatarStatusEl = document.getElementById('avatar-status');
const avatarCanvas = document.getElementById('avatar-canvas');

function sanitizePastedHtml(html, text){
  if (html){
    const doc = new DOMParser().parseFromString(html, 'text/html');
    doc.querySelectorAll('*').forEach(el=>{
      el.removeAttribute('color');
      el.style.color = '';
      if (el.getAttribute('style') === '') el.removeAttribute('style');
    });
    return doc.body.innerHTML;
  }
  if (text != null){
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML.replace(/\n/g, '<br>');
  }
  return '';
}

function wireRichTextPaste(){
  document.querySelectorAll('.richtext').forEach(el=>{
    el.addEventListener('paste', (e)=>{
      const html = e.clipboardData?.getData('text/html');
      const text = e.clipboardData?.getData('text/plain');
      if (html || text){
        e.preventDefault();
        const cleaned = sanitizePastedHtml(html, text);
        if (cleaned) document.execCommand('insertHTML', false, cleaned);
      }
    });
  });
}
let AVATAR_IMG = null;
if (avatarPreview){
  avatarPreview.onerror = ()=>{ avatarPreview.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9WUZPi8AAAAASUVORK5CYII='; };
}
const slSelectEl = document.getElementById('sl-select');
const slLoadBtn = document.getElementById('sl-load-btn');
const slCreateBtn = document.getElementById('sl-create-btn');
const slDupBtn = document.getElementById('sl-dup-btn');
const slStatusEl = document.getElementById('sl-status');
const slSummaryEl = document.getElementById('sl-summary');
const cntSchSimpleEl = document.getElementById('cnt-sch-simple');
const cntSchComplexEl = document.getElementById('cnt-sch-complex');
const cntSpSimpleEl = document.getElementById('cnt-sp-simple');
const cntSpComplexEl = document.getElementById('cnt-sp-complex');
const slSchoolsEl = document.getElementById('sl-schools');
const slSchOrderEl = document.getElementById('sl-sch-order');
const slSchSortBtn = document.getElementById('sl-sch-sort');
const slSchOrderStatusEl = document.getElementById('sl-sch-order-status');
const xpBarFillEl = document.getElementById('xp-bar-fill');
const xpBarTextEl = document.getElementById('xp-bar-text');
const xpProgressEl = document.getElementById('xp-progress');
const xpAddBtn = document.getElementById('xp-add-btn');
const levelSetBtn = document.getElementById('level-set-btn');
const xpLedgerBtn = document.getElementById('xp-ledger-btn');
const xpLedgerModal = document.getElementById('xp-ledger-modal');
const xpLedgerBackdrop = document.getElementById('xp-ledger-backdrop');
const xpLedgerClose = document.getElementById('xp-ledger-close');
const xpLedgerBody = document.getElementById('xp-ledger-body');
const slSchoolsStatusEl = document.getElementById('sl-schools-status');
const slAddMenuBtn = document.getElementById('sl-add-menu-btn');
const slAddMenu = document.getElementById('sl-add-menu');
const slQuickAddBtn = document.getElementById('sl-quick-add');
const slManualAddBtn = document.getElementById('sl-manual-add');
const slSchModal = document.getElementById('sl-sch-modal');
const slSchBackdrop = document.getElementById('sl-sch-modal-backdrop');
const slSchClose = document.getElementById('sl-sch-close');
const slSchCancel = document.getElementById('sl-sch-cancel');
const slSchApply = document.getElementById('sl-sch-apply');
const slSchBody = document.getElementById('sl-sch-body');
const slSchStatus = document.getElementById('sl-sch-status');
const slSpellsBody = document.getElementById('sl-spells-body');
const slOpenAddBtn = document.getElementById('sl-open-add');
const slAddModal = document.getElementById('sl-add-modal');
const slAddBackdrop = document.getElementById('sl-add-backdrop');
const slAddClose = document.getElementById('sl-add-close');
const slAddCancel = document.getElementById('sl-add-cancel');
const slSearchQ = document.getElementById('sl-search-q');
const slSearchBtn = document.getElementById('sl-search-btn');
const slSearchBody = document.getElementById('sl-search-body');
const slAddStatus = document.getElementById('sl-add-status');
const abiSpellsOnlyLearnedEl = document.getElementById('abi-spells-only-learned');
const ABI_SPELLS_FILTER_KEY = 'abi_spells_only_learned';
let EFFECTS_BY_ID = {};
let EFFECTS_PROMISE = null;

function initAbiSpellsFilter(){
  if (!abiSpellsOnlyLearnedEl) return;
  try{
    const stored = localStorage.getItem(ABI_SPELLS_FILTER_KEY);
    abiSpellsOnlyLearnedEl.checked = stored ? stored === '1' : true;
  }catch{}
  abiSpellsOnlyLearnedEl.addEventListener('change', ()=>{
    try{ localStorage.setItem(ABI_SPELLS_FILTER_KEY, abiSpellsOnlyLearnedEl.checked ? '1' : '0'); }catch{}
    renderAbilitySpellsBucket();
  });
}

const TITLE_COLOR_STORAGE_PREFIX = 'title_colors:';
let TITLE_COLOR_ACTIVE_KEY = '';
let TITLE_COLOR_ACTIVE_LABEL = '';
let TITLE_COLOR_SELECTED = '';
function titleColorStorageKey(){
  return `${TITLE_COLOR_STORAGE_PREFIX}${CID || 'unknown'}`;
}
function loadTitleColors(){
  try{
    const raw = localStorage.getItem(titleColorStorageKey());
    TITLE_COLOR_MAP = raw ? JSON.parse(raw) : {};
  }catch{
    TITLE_COLOR_MAP = {};
  }
}
function saveTitleColors(){
  try{ localStorage.setItem(titleColorStorageKey(), JSON.stringify(TITLE_COLOR_MAP || {})); }catch{}
}
function setTitleColor(key, color){
  if (!key) return;
  if (!color){
    delete TITLE_COLOR_MAP[key];
  }else{
    TITLE_COLOR_MAP[key] = color;
  }
  saveTitleColors();
}
function getTitleColor(key){
  return key ? (TITLE_COLOR_MAP[key] || '') : '';
}
function cssEscape(val){
  if (window.CSS && CSS.escape) return CSS.escape(val);
  return String(val || '').replace(/["\\]/g, '\\$&');
}
function applyTitleColor(el, key){
  if (!el || !key) return;
  const color = getTitleColor(key);
  el.style.color = color || '';
}
function applyTitleColorByKey(key){
  if (!key) return;
  const selector = `[data-color-key="${cssEscape(key)}"]`;
  document.querySelectorAll(selector).forEach(el=> applyTitleColor(el, key));
}
function abilityColorKey(a){
  const id = String(a?.id || '').trim();
  return id ? `ability:${id}` : '';
}
function spellColorKey(sp){
  const id = String(sp?.id || '').trim();
  return id ? `spell:${id}` : '';
}
function entryColorKey(kind, entry){
  const id = String(entry?.id || '').trim();
  return id ? `${kind}:${id}` : '';
}
function registerTitleColorTarget(el, key, label){
  if (!el || !key) return;
  el.classList.add('title-color-target');
  el.dataset.colorKey = key;
  if (label) el.dataset.colorLabel = label;
  if (!el.title) el.title = 'Double-click to set title color';
  applyTitleColor(el, key);
  el.addEventListener('dblclick', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    openTitleColorModal(key, label || el.textContent || 'Title');
  });
}
function rgbToHue(r, g, b){
  const rr = r / 255;
  const gg = g / 255;
  const bb = b / 255;
  const max = Math.max(rr, gg, bb);
  const min = Math.min(rr, gg, bb);
  if (max === min) return 0;
  let h = 0;
  if (max === rr){
    h = (60 * ((gg - bb) / (max - min)) + 360) % 360;
  }else if (max === gg){
    h = (60 * ((bb - rr) / (max - min)) + 120) % 360;
  }else{
    h = (60 * ((rr - gg) / (max - min)) + 240) % 360;
  }
  return Math.round(h);
}
function colorToHue(color){
  if (!color) return 0;
  const hslMatch = String(color).match(/hsl\(\s*([0-9.]+)/i);
  if (hslMatch) return Math.round(parseFloat(hslMatch[1]) || 0);
  const rgbMatch = String(color).match(/rgb\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)/i);
  if (rgbMatch) return rgbToHue(parseInt(rgbMatch[1],10), parseInt(rgbMatch[2],10), parseInt(rgbMatch[3],10));
  const hexMatch = String(color).match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
  if (hexMatch){
    let hex = hexMatch[1];
    if (hex.length === 3){
      hex = hex.split('').map(ch=> ch + ch).join('');
    }
    const r = parseInt(hex.slice(0,2), 16);
    const g = parseInt(hex.slice(2,4), 16);
    const b = parseInt(hex.slice(4,6), 16);
    return rgbToHue(r, g, b);
  }
  return 0;
}
function hueToColor(hue){
  const h = Math.max(0, Math.min(360, Number(hue)||0));
  return `hsl(${h}, 80%, 60%)`;
}
function updateTitleColorPreview(){
  if (titleColorPreview) titleColorPreview.style.background = TITLE_COLOR_SELECTED || '#15151d';
  if (titleColorPreviewText) titleColorPreviewText.style.color = TITLE_COLOR_SELECTED || '';
  if (titleColorPreviewValue) titleColorPreviewValue.textContent = TITLE_COLOR_SELECTED || 'Default';
}
function setTitleColorSelection(color, { syncSlider = false } = {}){
  TITLE_COLOR_SELECTED = color || '';
  if (syncSlider && titleColorHue){
    titleColorHue.value = String(colorToHue(TITLE_COLOR_SELECTED));
  }
  updateTitleColorPreview();
}
function openTitleColorModal(key, label){
  if (!titleColorModal || !titleColorBackdrop) return;
  TITLE_COLOR_ACTIVE_KEY = key || '';
  TITLE_COLOR_ACTIVE_LABEL = label || 'Title';
  if (titleColorPreviewText) titleColorPreviewText.textContent = TITLE_COLOR_ACTIVE_LABEL;
  setTitleColorSelection(getTitleColor(TITLE_COLOR_ACTIVE_KEY), { syncSlider: true });
  titleColorModal.classList.remove('hidden');
  titleColorModal.classList.add('open');
  titleColorBackdrop.classList.add('open');
}
function closeTitleColorModal(){
  if (!titleColorModal || !titleColorBackdrop) return;
  titleColorModal.classList.add('hidden');
  titleColorModal.classList.remove('open');
  titleColorBackdrop.classList.remove('open');
  TITLE_COLOR_ACTIVE_KEY = '';
  TITLE_COLOR_ACTIVE_LABEL = '';
}
function wireTitleColorPicker(){
  if (titleColorClose) titleColorClose.addEventListener('click', closeTitleColorModal);
  if (titleColorCancel) titleColorCancel.addEventListener('click', closeTitleColorModal);
  if (titleColorBackdrop){
    titleColorBackdrop.addEventListener('click', (e)=>{ if (e.target === titleColorBackdrop) closeTitleColorModal(); });
  }
  if (titleColorHue){
    titleColorHue.addEventListener('input', ()=>{
      setTitleColorSelection(hueToColor(titleColorHue.value));
    });
  }
  if (titleColorPalette){
    titleColorPalette.querySelectorAll('.color-swatch').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const color = btn.getAttribute('data-color') || '';
        setTitleColorSelection(color, { syncSlider: true });
      });
    });
  }
  if (titleColorClear){
    titleColorClear.addEventListener('click', ()=>{
      setTitleColorSelection('', { syncSlider: false });
    });
  }
  if (titleColorApply){
    titleColorApply.addEventListener('click', ()=>{
      if (!TITLE_COLOR_ACTIVE_KEY) return;
      setTitleColor(TITLE_COLOR_ACTIVE_KEY, TITLE_COLOR_SELECTED);
      applyTitleColorByKey(TITLE_COLOR_ACTIVE_KEY);
      closeTitleColorModal();
    });
  }
}

async function ensureEffectsLoaded(){
  if (Object.keys(EFFECTS_BY_ID).length) return EFFECTS_BY_ID;
  if (EFFECTS_PROMISE) return EFFECTS_PROMISE;
  EFFECTS_PROMISE = api('/effects').then(res=>{
    const list = res.effects || [];
    EFFECTS_BY_ID = {};
    list.forEach(e=>{ EFFECTS_BY_ID[String(e.id||e._id||'').toLowerCase()] = e; });
    return EFFECTS_BY_ID;
  }).catch(()=>({})).finally(()=>{ EFFECTS_PROMISE = null; });
  return EFFECTS_PROMISE;
}
/* Sublimations refs */
const subTypeEl = document.getElementById('sub-type');
const subTierEl = document.getElementById('sub-tier');
const subSkillEl = document.getElementById('sub-skill');
const subSkillLabel = document.getElementById('sub-skill-label');
const subNatureEl = document.getElementById('sub-nature');
const subNatureLabel = document.getElementById('sub-nature-label');
const subAddBtn = document.getElementById('sub-add-btn');
const subListEl = document.getElementById('sub-list');
const subSlotPill = document.getElementById('sub-slot-pill');
const subWarningEl = document.getElementById('sub-warning');
const subHiddenEl = document.getElementById('sub-hidden');
const subOpenBtn = document.getElementById('sub-open-btn');
const subModal = document.getElementById('sub-modal');
const subBackdrop = document.getElementById('sub-backdrop');
const subClose = document.getElementById('sub-close');
const subCancel = document.getElementById('sub-cancel');
initAbiSpellsFilter();
loadTitleColors();
wireTitleColorPicker();
wireRollModal();
/* Personal refs */
const pNickEl = document.getElementById('p-nicknames');
const pHeightEl = document.getElementById('p-height');
const pWeightEl = document.getElementById('p-weight');
const pEloEl = document.getElementById('p-elo');
const pRankEl = document.getElementById('p-rank');
const pFriendsEl = document.getElementById('p-friends');
const pEnemiesEl = document.getElementById('p-enemies');
const pNotesEl = document.getElementById('p-notes');
const pBackstoryEl = document.getElementById('p-backstory');

// Sublimations form wiring
(() => {
  const skillOpts = buildSkillOptions();
  subSkillEl.innerHTML = '';
  skillOpts.forEach(opt=>{
    const o = document.createElement('option');
    o.value = opt.value; o.textContent = opt.label;
    subSkillEl.appendChild(o);
  });
  subNatureEl.innerHTML = '<option value=\"\">-- choose --</option>';
  NATURES.forEach(n=>{
    const o = document.createElement('option');
    o.value = n; o.textContent = n;
    subNatureEl.appendChild(o);
  });
  subTypeEl.addEventListener('change', updateSubSpecialFields);
  subAddBtn.addEventListener('click', addSublimationFromForm);
  updateSubSpecialFields();
})();
subOpenBtn?.addEventListener('click', ()=>{
  subModal?.classList.remove('hidden');
  subBackdrop?.classList.remove('hidden');
  subModal?.classList.add('open');
  subBackdrop?.classList.add('open');
});
const closeSubModal = ()=>{
  subModal?.classList.remove('open');
  subBackdrop?.classList.remove('open');
  subModal?.classList.add('hidden');
  subBackdrop?.classList.add('hidden');
};
subClose?.addEventListener('click', closeSubModal);
subCancel?.addEventListener('click', closeSubModal);
subBackdrop?.addEventListener('click', (e)=>{ if (e.target === subBackdrop) closeSubModal(); });

// Overrides & current handlers
  [curHpEl, curEnEl, curFoEl, curSpEl].forEach(el=>{
    el?.addEventListener('input', ()=>{
      CURRENT = {
        hp: Number(curHpEl?.value||0),
        en: Number(curEnEl?.value||0),
        fo: Number(curFoEl?.value||0),
        sp: Number(curSpEl?.value||0),
      };
      updateDerived(); queueSave();
    });
  });

  function bindOverrideInput(el, key){
    if (!el) return;
    el.addEventListener('input', ()=>{
      const raw = String(el.value || '').trim();
      OVERRIDE_VALUES[key] = raw === '' ? null : Number(raw);
      updateDerived();
      queueSave();
    });
  }
  [
    [ovHpEl, 'hp'], [ovEnEl, 'en'], [ovFoEl, 'fo'], [ovMoEl, 'mo'], [ovInitEl, 'initiative'],
    [ovSpEl, 'spcap'], [ovEncEl, 'enc'], [ovEtEl, 'et'], [ovTxEl, 'tx'],
    [ovTalentMaxEl, 'talent_max'], [ovSkillPointsEl, 'skill_points'], [ovStatPointsEl, 'stat_points'],
    [ovSubSlotsEl, 'sublimation_slots'], [ovComplexSchoolsEl, 'complex_schools']
  ].forEach(([el, key])=> bindOverrideInput(el, key));
  overrideToggle?.addEventListener('change', ()=>{
    OVERRIDE_ENABLED = !!overrideToggle.checked;
    updateDerived();
    queueSave();
  });

  maxHpDmgEl?.addEventListener('input', ()=>{
    const st = combatState();
    st.max_hp_damage = Math.max(0, Number(maxHpDmgEl.value || 0));
    updateDerived();
    queueSave();
  });
  combatTakeDmgBtn?.addEventListener('click', ()=> openCombatDamageModal('damage'));
  combatTakeTrueBtn?.addEventListener('click', ()=> openCombatDamageModal('true'));
  combatHealBtn?.addEventListener('click', ()=> openCombatDamageModal('heal'));
  combatDmgApplyBtn?.addEventListener('click', ()=>{
    const amount = Number(combatDmgInputEl?.value || 0);
    if (!amount) return;
    if (COMBAT_DAMAGE_MODE === 'heal'){
      applyHealAmount(amount);
    }else{
      applyDamageAmount(amount, COMBAT_DAMAGE_MODE === 'true');
    }
    closeCombatDamageModal();
  });
  combatDmgClose?.addEventListener('click', closeCombatDamageModal);
  combatDmgCancel?.addEventListener('click', closeCombatDamageModal);
  combatDmgBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatDmgBackdrop) closeCombatDamageModal(); });
  defAddBtn?.addEventListener('click', ()=>{
    const st = combatState();
    const picked = String(defAddSkillEl?.value || '').trim();
    const custom = String(defAddCustomEl?.value || '').trim();
    const val = custom || picked;
    if (!val) return;
    const existing = new Set((st.defense_skills || []).map(s=> String(s)));
    existing.add(val);
    st.defense_skills = Array.from(existing);
    if (defAddCustomEl) defAddCustomEl.value = '';
    if (defAddSkillEl) defAddSkillEl.value = '';
    renderCombatDefenseSkills();
    queueSave();
  });
  defRollBtn?.addEventListener('click', ()=>{
    renderCombatDefenseSkills();
    invToggleModal(combatDefModal, combatDefBackdrop, true);
  });
  defRollConfirmBtn?.addEventListener('click', ()=>{
    rollDefense();
    invToggleModal(combatDefModal, combatDefBackdrop, false);
  });
  combatDefClose?.addEventListener('click', ()=> invToggleModal(combatDefModal, combatDefBackdrop, false));
  combatDefCancel?.addEventListener('click', ()=> invToggleModal(combatDefModal, combatDefBackdrop, false));
  combatDefBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatDefBackdrop) invToggleModal(combatDefModal, combatDefBackdrop, false); });
  initRollBtn?.addEventListener('click', rollInitiativeSpecial);
  combatAbilitySearchEl?.addEventListener('input', renderCombatAbilityList);
  combatSpellSearchEl?.addEventListener('input', renderCombatSpellList);
  combatSecondaryOpenBtn?.addEventListener('click', ()=>{
    renderCombatActions();
    invToggleModal(combatSecondaryModal, combatSecondaryBackdrop, true);
  });
  combatSecondaryClose?.addEventListener('click', ()=> invToggleModal(combatSecondaryModal, combatSecondaryBackdrop, false));
  combatSecondaryCancel?.addEventListener('click', ()=> invToggleModal(combatSecondaryModal, combatSecondaryBackdrop, false));
  combatSecondaryBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatSecondaryBackdrop) invToggleModal(combatSecondaryModal, combatSecondaryBackdrop, false); });
  combatContextOpenBtn?.addEventListener('click', ()=>{
    renderCombatActions();
    invToggleModal(combatContextModal, combatContextBackdrop, true);
  });
  combatContextClose?.addEventListener('click', ()=> invToggleModal(combatContextModal, combatContextBackdrop, false));
  combatContextCancel?.addEventListener('click', ()=> invToggleModal(combatContextModal, combatContextBackdrop, false));
  combatContextBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatContextBackdrop) invToggleModal(combatContextModal, combatContextBackdrop, false); });
  combatSpecialOpenBtn?.addEventListener('click', ()=>{
    renderCombatActions();
    invToggleModal(combatSpecialModal, combatSpecialBackdrop, true);
  });
  combatSpecialClose?.addEventListener('click', ()=> invToggleModal(combatSpecialModal, combatSpecialBackdrop, false));
  combatSpecialCancel?.addEventListener('click', ()=> invToggleModal(combatSpecialModal, combatSpecialBackdrop, false));
  combatSpecialBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatSpecialBackdrop) invToggleModal(combatSpecialModal, combatSpecialBackdrop, false); });
  combatAbilityOpenBtn?.addEventListener('click', ()=>{
    renderCombatAbilityList();
    invToggleModal(combatAbilityModal, combatAbilityBackdrop, true);
  });
  combatAbilityClose?.addEventListener('click', ()=> invToggleModal(combatAbilityModal, combatAbilityBackdrop, false));
  combatAbilityCancel?.addEventListener('click', ()=> invToggleModal(combatAbilityModal, combatAbilityBackdrop, false));
  combatAbilityBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatAbilityBackdrop) invToggleModal(combatAbilityModal, combatAbilityBackdrop, false); });
  combatSpellOpenBtn?.addEventListener('click', ()=>{
    renderCombatSpellList();
    invToggleModal(combatSpellModal, combatSpellBackdrop, true);
  });
  combatSpellClose?.addEventListener('click', ()=> invToggleModal(combatSpellModal, combatSpellBackdrop, false));
  combatSpellCancel?.addEventListener('click', ()=> invToggleModal(combatSpellModal, combatSpellBackdrop, false));
  combatSpellBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatSpellBackdrop) invToggleModal(combatSpellModal, combatSpellBackdrop, false); });
  conditionsAddBtn?.addEventListener('click', ()=>{
    renderCombatConditionModal();
    invToggleModal(combatConditionsModal, combatConditionsBackdrop, true);
  });
  combatConditionsClose?.addEventListener('click', ()=> invToggleModal(combatConditionsModal, combatConditionsBackdrop, false));
  combatConditionsCancel?.addEventListener('click', ()=> invToggleModal(combatConditionsModal, combatConditionsBackdrop, false));
  combatConditionsBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatConditionsBackdrop) invToggleModal(combatConditionsModal, combatConditionsBackdrop, false); });
  restOpenBtn?.addEventListener('click', ()=> invToggleModal(combatRestModal, combatRestBackdrop, true));
  tensionValueEl?.addEventListener('input', ()=>{
    const st = combatState();
    st.tension = Math.max(0, Number(tensionValueEl.value || 0));
    queueSave();
  });
  tensionStrategyEl?.addEventListener('change', ()=>{
    const st = combatState();
    st.tension_strategy = tensionStrategyEl.value || 'Offensive';
    queueSave();
  });
  exhaustedToggleEl?.addEventListener('change', ()=>{
    const st = combatState();
    st.exhausted = !!exhaustedToggleEl.checked;
    const active = new Set((st.conditions || []).map(String));
    if (st.exhausted) active.add('exhausted');
    else active.delete('exhausted');
    st.conditions = Array.from(active);
    renderCombatConditions();
    renderCombatActions();
    queueSave();
  });
  critAddBtn?.addEventListener('click', ()=> toggleCritModal(true));
  deathSaveRollBtn?.addEventListener('click', rollDeathSave);
  deathSaveSuccessAddBtn?.addEventListener('click', addDeathSaveSuccess);
  deathSaveFailAddBtn?.addEventListener('click', addDeathSaveFailure);
  deathSaveResetBtn?.addEventListener('click', resetDeathSaves);
  deathResetBtn?.addEventListener('click', resetDeathStatus);
  deathSaveStabilizeBtn?.addEventListener('click', stabilizeDeathSaves);
  restApplyBtn?.addEventListener('click', ()=>{
    applyRest();
    invToggleModal(combatRestModal, combatRestBackdrop, false);
  });
  eatApplyBtn?.addEventListener('click', ()=>{
    applyEat();
    invToggleModal(combatRestModal, combatRestBackdrop, false);
  });
  combatRestClose?.addEventListener('click', ()=> invToggleModal(combatRestModal, combatRestBackdrop, false));
  combatRestCancel?.addEventListener('click', ()=> invToggleModal(combatRestModal, combatRestBackdrop, false));
  combatRestBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatRestBackdrop) invToggleModal(combatRestModal, combatRestBackdrop, false); });
  combatAttackTypeEl?.addEventListener('change', toggleAttackSpecialVisibility);
  combatAttackRollBtn?.addEventListener('click', rollCombatAttack);
  combatAttackClose?.addEventListener('click', closeCombatAttackModal);
  combatAttackCancel?.addEventListener('click', closeCombatAttackModal);
  combatAttackBackdrop?.addEventListener('click', (e)=>{ if (e.target === combatAttackBackdrop) closeCombatAttackModal(); });
  critClose?.addEventListener('click', ()=> toggleCritModal(false));
  critCancel?.addEventListener('click', ()=> toggleCritModal(false));
  critBackdrop?.addEventListener('click', (e)=>{ if (e.target === critBackdrop) toggleCritModal(false); });
  critTypeEl?.addEventListener('change', updateCritNote);
  critConfirm?.addEventListener('click', ()=>{
    addCriticalInjury(critTypeEl?.value || 'severe', !!critStableEl?.checked);
    toggleCritModal(false);
  });

/* tabs switching */
document.querySelectorAll('.tab').forEach(tab=>{
  tab.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tabpane').forEach(p=>p.style.display='none');
    tab.classList.add('active');
    const id = tab.getAttribute('data-tab');
    document.getElementById(id).style.display='';
  });
});

/* auth */
async function checkMe() {
  loginChip.textContent = 'Checking login...';
  try{
    const me = await api('/auth/me');
    loginChip.textContent = `${me.username} (${me.role})`;
    if ((me.role||'').toLowerCase()==='admin') adminLink.style.display='';
    ROLE = me.role||'user';
    CURRENT_USER = me;
    return me;
  } catch(e){
    loginChip.textContent = 'Not logged in';
    adminLink.style.display='none';
    ROLE = 'guest';
    CURRENT_USER = null;
    return null;
  }
}

function applyReadOnlyState(){
  if (readonlyPill) readonlyPill.style.display = READ_ONLY ? '' : 'none';
  if (READ_ONLY && statusEl) statusEl.textContent = 'Read-only (public link)';
  const fields = document.querySelectorAll('input, select, textarea, button');
  fields.forEach(el=>{
    if (el.dataset.readonlyAllow === 'true') return;
    if (READ_ONLY){
      if (el.dataset.prevDisabled === undefined) el.dataset.prevDisabled = el.disabled ? '1' : '0';
      el.disabled = true;
    }else if (el.dataset.prevDisabled !== undefined){
      el.disabled = el.dataset.prevDisabled === '1';
      delete el.dataset.prevDisabled;
    }
  });
  document.querySelectorAll('[contenteditable]').forEach(el=>{
    if (READ_ONLY){
      if (el.dataset.prevEditable === undefined) el.dataset.prevEditable = el.contentEditable || '';
      el.contentEditable = 'false';
    }else if (el.dataset.prevEditable !== undefined){
      el.contentEditable = el.dataset.prevEditable;
      delete el.dataset.prevEditable;
    }
  });
}

/* defaults */
function makeDefaultStats(){
  const stats = {};
  for (const c of CHARACS){
    const sk = {};
    for (const s of c.skills) sk[s] = 0;
    stats[c.key] = { invest: 0, skills: sk };
  }
  const ints = {};
  for (const n of INTENSITIES){ ints[n] = 0; }
  stats.intensities = ints;
  stats.personal = {
    nicknames: "",
    height: "",
    weight: "",
    elo: "",
    rank: "",
    friends: "",
    enemies: "",
    notes: "",
    backstory: "",
  };
  stats.combat = {
    max_hp_damage: 0,
    defense_skills: ["Dodge", "Evasion", "Blocking", "Absorption"],
    tension: 3,
    tension_strategy: "Offensive",
    exhausted: false,
    conditions: [],
    critical_injuries: [],
    death_saves: { ko: false, successes: 0, failures: 0, dead: false },
    active_abilities: [],
    active_spells: [],
    weapon_states: {}
  };
  stats.species_ability_id = "";
  stats.boon_ability_id = "";
  return stats;
}

function normalizeStats(stats){
  const base = makeDefaultStats();
  const out = Object.assign({}, base, stats || {});
  for (const c of CHARACS){
    if (!out[c.key]) out[c.key] = { invest:0, skills:{} };
    if (!out[c.key].skills) out[c.key].skills = {};
    for (const s of (c.skills||[])){
      if (out[c.key].skills[s] === undefined) out[c.key].skills[s] = 0;
    }
  }
  out.intensities = Object.assign({}, base.intensities, out.intensities || {});
  out.personal = Object.assign({}, base.personal, out.personal || {});
  out.combat = Object.assign({}, base.combat, out.combat || {});
  if (!Array.isArray(out.combat.defense_skills)) out.combat.defense_skills = base.combat.defense_skills.slice();
  if (!Array.isArray(out.combat.conditions)) out.combat.conditions = [];
  if (!Array.isArray(out.combat.critical_injuries)) out.combat.critical_injuries = [];
  if (!Array.isArray(out.combat.active_abilities)) out.combat.active_abilities = [];
  if (!Array.isArray(out.combat.active_spells)) out.combat.active_spells = [];
  if (!out.combat.death_saves || typeof out.combat.death_saves !== 'object'){
    out.combat.death_saves = { ko: false, successes: 0, failures: 0, dead: false };
  }else if (out.combat.death_saves.dead == null){
    out.combat.death_saves.dead = false;
  }
  if (!out.combat.weapon_states || typeof out.combat.weapon_states !== 'object'){
    out.combat.weapon_states = {};
  }
  return out;
}

function combatState(){
  if (!CHAR?.stats) CHAR.stats = normalizeStats(CHAR?.stats || {});
  if (!CHAR.stats.combat) CHAR.stats.combat = normalizeStats({}).combat;
  if (!Number.isFinite(Number(CHAR.stats.combat.max_hp_damage))) CHAR.stats.combat.max_hp_damage = 0;
  return CHAR.stats.combat;
}

function skillMaxForLevel(lvl){
  if (lvl <= 1) return 4;
  if (lvl <= 10) return 5;
  if (lvl <= 20) return 6;
  if (lvl <= 30) return 7;
  if (lvl <= 40) return 8;
  if (lvl <= 50) return 9;
  return 10;
}
function skillPointPool(lvl){
  // 80 at level 1, +2 per level-up
  return 80 + Math.max(0, (Math.max(1, lvl) - 1) * 2);
}
function statPointPool(lvl){
  // 24 at level 1, +3 every 9 levels (per KP rule)
  return 24 + Math.floor((Math.max(1, lvl) - 1) / 9) * 3;
}
function effectiveSkillPointPool(lvl){
  return numOr(DERIVED_CACHE?.skill_points, skillPointPool(lvl));
}
function effectiveStatPointPool(lvl){
  return numOr(DERIVED_CACHE?.stat_points, statPointPool(lvl));
}
function statInvestCap(lvl){
  const lv = Math.max(1, Math.floor(Number(lvl) || 1));
  // Base total cap 10, +2 every 15 levels, max 20
  const maxTotal = Math.min(20, 10 + (Math.floor((lv - 1) / 15) * 2));
  return Math.max(0, maxTotal - 4); // convert back to invest (base is 4)
}
function statTotalCap(lvl){
  return totalFromInvest(statInvestCap(lvl));
}
function totalSkillInvest(){
  let t = 0;
  for (const c of CHARACS){
    const rec = (CHAR.stats && CHAR.stats[c.key]) || {};
    for (const s of (c.skills||[])){
      t += investVal(rec.skills?.[s], 0);
    }
  }
  if (CHAR.stats?.intensities){
    for (const n of INTENSITIES){
      t += investVal(CHAR.stats.intensities[n], 0);
    }
  }
  return t;
}
function totalStatInvest(){
  let t = 0;
  for (const c of CHARACS){
    t += investVal(CHAR.stats?.[c.key]?.invest, 0);
  }
  return t;
}
function updatePointCounters(){
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const usedSkill = totalSkillInvest();
  const usedStat = totalStatInvest();
  if (OVERRIDE_ENABLED){
    if (skillCounterEl) skillCounterEl.textContent = `Skills: ${usedSkill} / 8`;
    if (statCounterEl) statCounterEl.textContent = `Characteristics: ${usedStat} / 8`;
    if (skillCapEl){
      skillCapEl.textContent = 'Max per skill (invest): 8';
      skillCapEl.title = 'Override enabled: caps are hints only.';
    }
    if (statCapEl){
      statCapEl.textContent = 'Max per characteristic (invest): 8';
      statCapEl.title = 'Override enabled: caps are hints only.';
    }
    return;
  }
  const poolSkill = effectiveSkillPointPool(lvl);
  const poolStat = effectiveStatPointPool(lvl);
  const capSkillInvest = skillMaxForLevel(lvl);
  const capStatInvest = statInvestCap(lvl);
  const capStatTotal = statTotalCap(lvl);
  if (skillCounterEl) skillCounterEl.textContent = `Skills: ${usedSkill} / ${poolSkill}`;
  if (statCounterEl) statCounterEl.textContent = `Characteristics: ${usedStat} / ${poolStat}`;
  if (skillCapEl){
    skillCapEl.textContent = `Max per skill (invest): ${capSkillInvest}`;
    skillCapEl.title = 'Cap applies to invested points; bonuses can raise totals beyond this.';
  }
  if (statCapEl){
    statCapEl.textContent = `Max per characteristic (invest): ${capStatInvest}`;
    statCapEl.title = `Invest cap excludes the starting 4; base total cap is ${capStatTotal}. Modifiers can exceed caps.`;
  }
}

/* ---------- Sublimations helpers ---------- */
function normalizeSublimations(arr){
  const out = [];
  (arr || []).forEach(s=>{
    if (!s || !s.type) return;
    const tier = Math.min(4, Math.max(1, Number(s.tier)||1));
    out.push({
      id: s.id || `sub_${Date.now()}_${Math.random().toString(16).slice(2)}`,
      type: String(s.type||'').toLowerCase(),
      tier,
      skill: s.skill || '',
      nature: s.nature || ''
    });
  });
  return out;
}
function slotsForLevel(lvl){
  const base = 2; // unlocked immediately, +2 every 10 levels
  return base + (Math.floor(Math.max(1, lvl) / 10) * 2);
}
function effectiveSublimationSlots(lvl){
  return numOr(DERIVED_CACHE?.sublimation_slots, slotsForLevel(lvl));
}
function slotsUsed(subs){
  return (subs||[]).reduce((acc,s)=> acc + (SUB_TIER_SLOTS[s.tier] || 0), 0);
}
function buildSkillOptions(){
  const opts = [];
  for (const c of CHARACS){
    for (const s of c.skills){
      opts.push({ value:`${c.key}|${s}`, label:`${s} (${c.name})` });
    }
  }
  // Allow intensities as targetable “skills” for Excellence
  INTENSITIES.forEach(n=>{
    opts.push({ value:`magic|${n}`, label:`${n} (Intensity)` });
  });
  return opts;
}

function updateSubSpecialFields(){
  const t = (subTypeEl.value || '').toLowerCase();
  const isEx = t === 'excellence';
  const isBless = t === 'blessing';
  subSkillEl.style.display = subSkillLabel.style.display = isEx ? '' : 'none';
  subNatureEl.style.display = subNatureLabel.style.display = isBless ? '' : 'none';
}

function sublimationDescription(sub){
  const t = (sub.type || '').toLowerCase();
  const tier = Math.min(4, Math.max(1, Number(sub.tier) || 1));
  if (t === 'lethality') return `+${2 * tier} neutral weapon dmg (not animarmas)`;
  if (t === 'blessing') return `+${2 * tier} ${(sub.nature || 'magic').toLowerCase()} dmg to space actions`;
  if (t === 'excellence'){
    const name = (sub.skill || '').split('|')[1] || 'skill';
    return `+${tier} to ${name}`;
  }
  if (t === 'defense') return `+${12 * tier} HP`;
  if (t === 'speed') return `+${tier} MO`;
  if (t === 'devastation') return `+${tier} Condition DC`;
  if (t === 'clarity') return `+${2 * tier} EN`;
  if (t === 'endurance') return `+${2 * tier} FO`;
  return '';
}

function renderSublimations(){
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const cap = effectiveSublimationSlots(lvl);
  const used = slotsUsed(SUBLIMATIONS);
  subSlotPill.textContent = `Slots: ${used} / ${cap}`;
  subWarningEl.textContent = used > cap ? 'Over capacity' : '';

  subListEl.innerHTML = '';
  if (!SUBLIMATIONS.length){
    subListEl.innerHTML = '<div class="muted">No sublimations set.</div>';
  }else{
    SUBLIMATIONS.forEach(sub=>{
      const row = document.createElement('div');
      row.className = 'abi-item';
      const desc = sublimationDescription(sub);
      row.innerHTML = `
        <div class="grow">
          <div class="row" style="align-items:center; gap:8px;">
            <strong>${sub.type}</strong>
            <span class="pill">Tier ${sub.tier}</span>
            ${desc ? `<span class="pill muted" style="opacity:.9;">${desc}</span>` : ''}
          </div>
        </div>
      `;

      const rem = document.createElement('button');
      rem.className = 'btn btn-secondary small';
      rem.textContent = 'Remove';
      rem.addEventListener('click', ()=>{
        SUBLIMATIONS = SUBLIMATIONS.filter(s=>s.id !== sub.id);
        onSublimationChanged();
      });
      row.appendChild(rem);

      subListEl.appendChild(row);
    });
  }

  const { hidden } = getSublimationEffects();
  const parts = [];
  if (hidden.weaponNeutral) parts.push(`+${hidden.weaponNeutral} neutral weapon dmg (not animarmas)`);
  if (hidden.magicBonus) parts.push(`+${hidden.magicBonus} ${hidden.magicNature || 'magic'} dmg (benediction, spells/animarmas)`);
  if (hidden.conditionDC) parts.push(`+${hidden.conditionDC} Condition DC`);
  subHiddenEl.textContent = parts.length ? `Hidden effects: ${parts.join(' | ')}` : '';
}

function onSublimationChanged(){
  recomputePassiveAgg();
  renderStatistics();
  updateDerived();
  renderSublimations();
  queueSave();
}

function addSublimationFromForm(){
  const type = (subTypeEl.value || '').toLowerCase();
  const tier = Math.min(4, Math.max(1, Number(subTierEl.value)||1));
  const skill = subSkillEl.value || '';
  const nature = subNatureEl.value || '';
  if (!type){ subWarningEl.textContent = 'Pick a type'; return; }
  if (type === 'excellence' && !skill){ subWarningEl.textContent = 'Choose a skill for Excellence'; return; }
  if (type === 'blessing' && !nature){ subWarningEl.textContent = 'Choose a nature for Blessing'; return; }
  if (type !== 'excellence' && SUBLIMATIONS.some(s=>s.type===type)){
    subWarningEl.textContent = 'This sublimation type is already slotted';
    return;
  }
  if (type === 'excellence' && SUBLIMATIONS.some(s=>s.type==='excellence' && s.skill === skill)){
    subWarningEl.textContent = 'That skill already has an Excellence';
    return;
  }
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const cap = effectiveSublimationSlots(lvl);
  const newUsed = slotsUsed(SUBLIMATIONS) + (SUB_TIER_SLOTS[tier] || 0);
  if (newUsed > cap){
    subWarningEl.textContent = 'Not enough slots';
    return;
  }
  subWarningEl.textContent = '';
  SUBLIMATIONS = SUBLIMATIONS.concat([{ id:`sub_${Date.now()}_${Math.random().toString(16).slice(2)}`, type, tier, skill, nature }]);
  onSublimationChanged();
  if (typeof closeSubModal === 'function') closeSubModal();
}

/* ---------- PASSIVE AGGREGATION (char & skills) ---------- */
function resetPassiveAgg(){
  PASSIVE = { char:{}, skill:{}, school:{}, spell_slots:{}, magic_damage:{ spell:{}, weapon:{} } };
}
function ensureAgg(obj, key){
  if (!obj[key]) obj[key] = { set:[], mul:[], add:[], notes:[] };
  return obj[key];
}
function modEffectiveValue(mod){
  const base = Number(mod?.value || 0);
  const step = Math.max(0, Number(mod?.level_step || 0));
  const inc = Number(mod?.level_increment || 1);
    if (step > 0){
      const lvl = Math.max(1, Math.floor(Number(CHAR?.level || levelEl?.value || 1)));
      const extra = Math.floor(lvl / step) * inc;
      return base + extra;
    }
  return base;
}
function normalizeChoiceEntry(val){
  if (!val) return { base:'', picks:[] };
  if (Array.isArray(val)) return { base:'', picks: val.filter(Boolean) };
  const picks = Array.isArray(val.picks) ? val.picks.slice()
    : Array.isArray(val.selected) ? val.selected.slice()
    : [];
  const base = val.base || val.source || '';
  return { base, picks: picks.filter(Boolean) };
}
function normalizeRestrict(choice){
  // Accept either the whole modifier or the nested choice object.
  if (!choice) return [];
  const src = choice.choice || choice;
  if (Array.isArray(src.restrict)) return src.restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(src.choice_restrict)) return src.choice_restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(src.restrict_list)) return src.restrict_list.map(s=> String(s).trim()).filter(Boolean);
  // Some older records stored restrict fields at the modifier level instead of inside choice
  if (Array.isArray(choice.restrict)) return choice.restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(choice.choice_restrict)) return choice.choice_restrict.map(s=> String(s).trim()).filter(Boolean);
  if (Array.isArray(choice.restrict_list)) return choice.restrict_list.map(s=> String(s).trim()).filter(Boolean);
  const txt = src.restrict_text || src.choice_restrict || src.restrict_list || src.restrict || src.restrict_string ||
    choice.restrict_text || choice.choice_restrict || choice.restrict_list || choice.restrict || choice.restrict_string || '';
  if (typeof txt === 'string'){
    return String(txt).split(',').map(s=>s.trim()).filter(Boolean);
  }
  return [];
}
function normalizeChoiceAllowed(choice){
  if (!choice) return [];
  const src = choice.choice || choice;
  if (Array.isArray(src.choices)) return src.choices.map(s=> String(s).trim()).filter(Boolean);
  const txt = src.choices_text || '';
  if (typeof txt === 'string' && txt.trim()){
    return txt.split(',').map(s=> s.trim()).filter(Boolean);
  }
  return [];
}
function abilityChoiceSelections(ab, kind){
  const byAb = ABILITY_CHOICES[ab.id] || {};
  return normalizeChoiceEntry(byAb[kind]).picks;
}
function abilityChoiceState(ab, kind){
  const byAb = ABILITY_CHOICES[ab.id] || {};
  return normalizeChoiceEntry(byAb[kind]);
}
function itemChoiceState(itemId, kind){
  const byItem = ITEM_CHOICES[itemId] || {};
  return normalizeChoiceEntry(byItem[kind]);
}
function abilityGroupSelections(ab){
  const byAb = ABILITY_CHOICES[ab.id] || {};
  return byAb._groups || {};
}
function setAbilityGroupSelections(abId, data){
  if (!ABILITY_CHOICES[abId]) ABILITY_CHOICES[abId] = {};
  ABILITY_CHOICES[abId]._groups = data || {};
}

function collapseAbilityReplacements(assigned){
  // Drop older abilities that are explicitly replaced by a newer one present on the character.
  const present = new Set((assigned || []).map(a=> String(a.id||'').trim()).filter(Boolean));
  const toRemove = new Set();
  (assigned || []).forEach(ab=>{
    const oldId = String(ab?.archetype_replaces || '').trim();
    if (oldId && present.has(oldId)){
      toRemove.add(oldId);
    }
  });
  if (!toRemove.size) return assigned;
  // prune character ability ids and stale choices
  CHAR.abilities = (CHAR.abilities || []).map(id=> String(id||'').trim()).filter(id=> id && !toRemove.has(id));
  toRemove.forEach(id=>{ if (ABILITY_CHOICES[id]) delete ABILITY_CHOICES[id]; });
  queueSave();
  return (assigned || []).filter(ab=> !toRemove.has(String(ab.id||'').trim()));
}
function abilityGroups(ab){
  const mods = (ab?.passive?.modifiers || []);
  const map = new Map();
  mods.forEach((m, idx)=>{
    const name = (m.group || '').trim();
    if (!name) return;
    const max = 1; // groups are mutually exclusive
    const entry = map.get(name) || { name, max, options: [] };
    entry.options.push({ idx, mod: m });
    map.set(name, entry);
  });
  return Array.from(map.values());
}
function resolveGroupSelections(ab){
  const groups = abilityGroups(ab);
  const stored = abilityGroupSelections(ab);
  const active = new Set();
  const selections = {};
  groups.forEach(g=>{
    const allowed = g.options.map(o=> o.idx);
    const limit = g.max > 0 ? g.max : allowed.length;
    const saved = Array.isArray(stored[g.name]) ? stored[g.name] : [];
    let picks = saved.map(x=> Number(x)).filter(i=> allowed.includes(i));
    if (!picks.length){
      picks = allowed.slice(0, limit);
    }else if (limit > 0 && picks.length > limit){
      picks = picks.slice(0, limit);
    }
    selections[g.name] = picks;
    picks.forEach(i=> active.add(i));
  });
  if (ab?.id && JSON.stringify(stored) !== JSON.stringify(selections)){
    setAbilityGroupSelections(ab.id, selections);
  }
  return { active, selections, groups };
}
function prettyTargetLabel(target){
  const t = String(target||'').trim();
  if (!t) return '(unknown target)';
  if (t.startsWith('choice:')){
    const inner = t.replace(/^choice:/,'');
    const base = prettyTargetLabel(inner);
    return base.startsWith('[Choice]') ? base : `[Choice] ${base}`;
  }
  const cm = t.match(/^char\.(.+)$/i);
  if (cm){
    const key = cm[1].toLowerCase();
    const hit = CHARACS.find(c=> c.key === key);
    return hit ? `${hit.name} (Characteristic)` : t;
  }
  const sm = t.match(/^skills\.([^.]+)\.(.+)$/i);
  if (sm){
    const ckey = sm[1].toLowerCase();
    const sk = sm[2];
    const hit = CHARACS.find(c=> c.key === ckey);
    return hit ? `${sk} (${hit.name})` : `Skill: ${sk}`;
  }
  const im = t.match(/^intensities\.(.+)$/i);
  if (im) return `Intensity: ${im[1]}`;
  const sch = t.match(/^schools\.(.+)$/i);
  if (sch){
    const raw = sch[1];
    const found = (SCHOOLS||[]).find(s=> String(s.id||'').toLowerCase() === String(raw).toLowerCase());
    return found ? `${found.name} (School)` : `School: ${raw}`;
  }
  const md = t.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
  if (md) return `${md[2]} magic damage (${md[1]})`;
  const sg = t.match(/^skills\.by_char\.(.+)$/i);
  if (sg) return `Skills linked to ${sg[1]}`;
  const sn = t.match(/^schools\.by_nature\.(.+)$/i);
  if (sn) return `Schools linked to ${sn[1]}`;
  const ss = t.match(/^schools\.by_skill\.(.+)$/i);
  if (ss) return `Schools using ${ss[1]}`;
    if (t === 'skill_ms') return 'Magic School (by skill)';
    if (t === 'nature_ms') return 'Magic School (by nature)';
    if (t === 'char_skill') return 'Skill linked to characteristic';
    if (t === 'school_any' || t === 'school_ms') return 'Magic School';
    if (t === 'intensity_any') return 'Intensity';
    if (t === 'derived.skill_points') return 'Skill point pool';
    if (t === 'derived.weapon_neutral') return 'Neutral weapon damage';
    if (t === 'derived.stat_points') return 'Characteristic point pool';
    if (t === 'derived.craftomancy_max') return 'Max Craftomancies';
    if (t === 'derived.sublimation_slots') return 'Sublimation slots';
    if (t === 'derived.complex_schools') return 'Complex schools';
    if (t === 'derived.initiative') return 'Initiative';
    return t;
  }
function expandedTargets(mod){
  const baseTarget = String(mod.target || mod.key || '').trim();
  if (!baseTarget) return [];
  const out = [];
  const push = (t)=> out.push({ ...mod, target: t });
  const sg = baseTarget.match(/^skills\.by_char\.(.+)$/i);
  if (sg){
    const key = sg[1].toLowerCase();
    const hit = CHARACS.find(c=> c.key === key);
    if (hit){
      (hit.skills || []).forEach(sk=> push(`skills.${key}.${sk}`));
      return out;
    }
  }
  const schN = baseTarget.match(/^schools\.by_nature\.(.+)$/i);
  if (schN){
    const nature = schN[1];
    const matches = (SCHOOLS || []).filter(s=> (s.linked_intensities || []).some(n=> String(n).toLowerCase() === String(nature).toLowerCase()));
    if (matches.length){
      matches.forEach(s=> push(`schools.${s.id}`));
      return out;
    }
  }
  const schS = baseTarget.match(/^schools\.by_skill\.(.+)$/i);
  if (schS){
    const skill = schS[1];
    const matches = (SCHOOLS || []).filter(s=> String(s.linked_skill || '').toLowerCase() === String(skill).toLowerCase());
    if (matches.length){
      matches.forEach(s=> push(`schools.${s.id}`));
      return out;
    }
  }
  const md = baseTarget.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
  if (md){
    push(`magic_damage.${md[1].toLowerCase()}.${md[2]}`);
    return out;
  }
  push(baseTarget);
  return out;
}
function resolvedPassiveMods(ab){
  const mods = (ab.passive && ab.passive.modifiers) || [];
  const out = [];
  const { active: activeGroups } = resolveGroupSelections(ab);
  mods.forEach((m, idx)=>{
    const grouped = (m.group || '').trim();
    if (grouped && !activeGroups.has(idx)) return;
    const expanded = expandedTargets(m);
    for (const em of expanded){
      const t = (em.target || em.key || '').trim();
      if (!t) continue;
      if (t.startsWith('choice:')){
        const kind = t.replace('choice:','');
        const picks = Array.from(new Set(abilityChoiceSelections(ab, kind)));
        if (!picks.length) continue;
        picks.forEach(sel=> out.push({ ...em, target: sel }));
        continue;
      }
      out.push(em);
    }
  });
  return out;
}
function recomputePassiveAgg(){
  resetPassiveAgg();
    const assignedIds = new Set((ASSIGNED||[]).map(a=> String(a?.id || '')));
    const combined = (ASSIGNED||[])
      .concat((ARC_ASSIGNED||[]).filter(a=> !assignedIds.has(String(a?.id || ''))))
      .concat((EXP_ASSIGNED||[]).filter(a=> !assignedIds.has(String(a?.id || ''))))
      .concat((DIMA_ASSIGNED||[]).filter(a=> !assignedIds.has(String(a?.id || ''))));
    const passiveAbilities = combined.filter(a=>{
      const t = (a.type||'').toLowerCase();
      return t==='passive' || t==='mixed';
    });
  for (const ab of passiveAbilities){
    const mods = resolvedPassiveMods(ab);
    for (const m of mods){
      const t = (m.target || m.key || '').trim();
      const mode = ((m.mode||'add')+'').toLowerCase();
      const val = modEffectiveValue(m);
      const note = m.note ? ` (${m.note})` : '';
      const origin = `${ab.name}${note}`;
      if (!t) continue;

      const cm = t.match(/^char\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)$/i);
      if (cm){
        const key = cm[1].toLowerCase();
        const agg = ensureAgg(PASSIVE.char, key);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }

      const sm = t.match(/^skills\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)\.(.+)$/i);
      if (sm){
        const ckey = sm[1].toLowerCase();
        const skName = sm[2];
        const k = `${ckey}|${skName}`;
        const agg = ensureAgg(PASSIVE.skill, k);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }

      const im = t.match(/^intensities\.(.+)$/i);
      if (im){
        const skName = im[1];
        const k = `magic|${skName}`;
        const agg = ensureAgg(PASSIVE.skill, k);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }

      const sch = t.match(/^schools\.(.+)$/i);
      if (sch){
        const key = sch[1].toLowerCase();
        const agg = ensureAgg(PASSIVE.school, key);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }
      const schNat = t.match(/^schools\.by_nature\.(.+)$/i);
      if (schNat){
        const nature = schNat[1];
        const matches = (SCHOOLS || []).filter(s=> (s.linked_intensities || []).some(n=> String(n).toLowerCase() === String(nature).toLowerCase()));
        matches.forEach(s=>{
          const key = String(s.id || '').toLowerCase();
          const agg = ensureAgg(PASSIVE.school, key);
          (agg[mode]||agg.add).push({v:val, origin});
          agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        });
        continue;
      }
      const schSkill = t.match(/^schools\.by_skill\.(.+)$/i);
      if (schSkill){
        const skillName = schSkill[1];
        const matches = (SCHOOLS || []).filter(s=> String(s.linked_skill || '').toLowerCase() === String(skillName).toLowerCase());
        matches.forEach(s=>{
          const key = String(s.id || '').toLowerCase();
          const agg = ensureAgg(PASSIVE.school, key);
          (agg[mode]||agg.add).push({v:val, origin});
          agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        });
        continue;
      }

      const ss = t.match(/^spell_slots\.(simple|complex)$/i);
      if (ss){
        const key = ss[1].toLowerCase();
        const agg = ensureAgg(PASSIVE.spell_slots, key);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }

      const md = t.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
      if (md){
        const kind = md[1].toLowerCase();
        const nature = md[2].toLowerCase();
        const bucket = PASSIVE.magic_damage[kind] || {};
        PASSIVE.magic_damage[kind] = bucket;
        const agg = ensureAgg(bucket, nature);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }
    }
  }
  for (const m of getEquippedInventoryModifiers()){
    const t = (m.target||'').trim();
    const mode = (m.mode||'add').toLowerCase();
    const val = modEffectiveValue(m);
    const origin = m.origin || 'Inventory';
    if (!t) continue;
    const cm = t.match(/^char\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)$/i);
    if (cm){
      const key = cm[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.char, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sm = t.match(/^skills\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)\.(.+)$/i);
    if (sm){
      const ckey = sm[1].toLowerCase();
      const skName = sm[2];
      const k = `${ckey}|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const im = t.match(/^intensities\.(.+)$/i);
    if (im){
      const skName = im[1];
      const k = `magic|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sch = t.match(/^schools\.(.+)$/i);
    if (sch){
      const key = sch[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.school, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }

    const ss = t.match(/^spell_slots\.(simple|complex)$/i);
    if (ss){
      const key = ss[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.spell_slots, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
  }
  const { mods: subMods } = getSublimationEffects();
  for (const m of subMods){
    const t = (m.target||'').trim();
    const mode = (m.mode||'add').toLowerCase();
    const val = modEffectiveValue(m);
    const origin = m.origin || 'Sublimation';
    if (!t) continue;
    const cm = t.match(/^char\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)$/i);
    if (cm){
      const key = cm[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.char, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sm = t.match(/^skills\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)\.(.+)$/i);
    if (sm){
      const ckey = sm[1].toLowerCase();
      const skName = sm[2];
      const k = `${ckey}|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const im = t.match(/^intensities\.(.+)$/i);
    if (im){
      const skName = im[1];
      const k = `magic|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sch = t.match(/^schools\.(.+)$/i);
    if (sch){
      const key = sch[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.school, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const schNat = t.match(/^schools\.by_nature\.(.+)$/i);
    if (schNat){
      const nature = schNat[1];
      const matches = (SCHOOLS || []).filter(s=> (s.linked_intensities || []).some(n=> String(n).toLowerCase() === String(nature).toLowerCase()));
      matches.forEach(s=>{
        const key = String(s.id || '').toLowerCase();
        const agg = ensureAgg(PASSIVE.school, key);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      });
      continue;
    }
    const schSkill = t.match(/^schools\.by_skill\.(.+)$/i);
    if (schSkill){
      const skillName = schSkill[1];
      const matches = (SCHOOLS || []).filter(s=> String(s.linked_skill || '').toLowerCase() === String(skillName).toLowerCase());
      matches.forEach(s=>{
        const key = String(s.id || '').toLowerCase();
        const agg = ensureAgg(PASSIVE.school, key);
        (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      });
      continue;
    }
    const md = t.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
    if (md){
      const kind = md[1].toLowerCase();
      const nature = md[2].toLowerCase();
      const bucket = PASSIVE.magic_damage[kind] || {};
      PASSIVE.magic_damage[kind] = bucket;
      const agg = ensureAgg(bucket, nature);
      (agg[mode]||agg.add).push({v:val, origin});
        agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
        continue;
      }
    }
  }
  for (const m of getSpellEffectModifiers()){
    const t = (m.target||'').trim();
    const mode = (m.mode||'add').toLowerCase();
    const val = modEffectiveValue(m);
    const origin = m.origin || 'Spell';
    if (!t) continue;
    const cm = t.match(/^char\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)$/i);
    if (cm){
      const key = cm[1].toLowerCase();
      const agg = ensureAgg(PASSIVE.char, key);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sm = t.match(/^skills\.(body|willpower|magic|presence|reflex|dexterity|tech|wisdom)\.(.+)$/i);
    if (sm){
      const ckey = sm[1].toLowerCase();
      const skName = sm[2];
      const k = `${ckey}|${skName}`;
      const agg = ensureAgg(PASSIVE.skill, k);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const im = t.match(/^intensities\.(.+)$/i);
    if (im){
      const skName = im[1];
      const agg = ensureAgg(PASSIVE.intensity, skName);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const sch = t.match(/^schools\.(.+)$/i);
    if (sch){
      const skName = sch[1];
      const agg = ensureAgg(PASSIVE.school, skName);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
    const md = t.match(/^magic_damage\.(spell|weapon)\.(.+)$/i);
    if (md){
      const kind = md[1].toLowerCase();
      const nature = md[2].toLowerCase();
      const bucket = PASSIVE.magic_damage[kind] || {};
      PASSIVE.magic_damage[kind] = bucket;
      const agg = ensureAgg(bucket, nature);
      (agg[mode]||agg.add).push({v:val, origin});
      agg.notes.push(`${mode} ${val>=0?'+':''}${val} -> ${origin}`);
      continue;
    }
  }
function applyOps(base, agg){
  if (!agg) return { value: base, notes: [`Base = ${base}`] };
  const notes = [`Base = ${base}`];
  let v = base;
  // set -> mul -> add
  for (const x of (agg.set||[])){ v = x.v; notes.push(`Set to ${x.v} -> ${x.origin}`); }
  for (const x of (agg.mul||[])){ const before = v; v = Math.round(v * x.v); notes.push(`*${x.v} (from ${before}) -> ${x.origin}`); }
  for (const x of (agg.add||[])){ v = v + x.v; notes.push(`${x.v>=0?'+':''}${x.v} -> ${x.origin}`); }
  return { value: v, notes };
}

/* ---------- Rendering: Statistics & Skills ---------- */
function skillId(key, skill, suffix){
  const slug = (skill || '').toLowerCase().replace(/[^a-z0-9]+/g, '_');
  return `${key}__${slug}__${suffix}`;
}

function setNotesList(id, notes){
  let el = document.getElementById(id);
  if (!el){
    el = document.createElement('ul');
    el.className = 'mod-list';
    el.id = id;
    el.style.display = 'none';
  }else{
    el.innerHTML = '';
  }
  (notes || []).forEach(n=>{
    const li = document.createElement('li');
    li.textContent = n;
    el.appendChild(li);
  });
  return el;
}

function toggleModList(id){
  const el = document.getElementById(id);
  if (!el) return;
  el.style.display = (el.style.display === 'none' || !el.style.display) ? '' : 'none';
}

document.addEventListener('click', (e)=>{
  const t = e.target.closest('.mod-toggle');
  if (!t) return;
  const id = t.getAttribute('data-target');
  if (id) toggleModList(id);
});

function getEquippedInventoryModifiers(){
  if (!LINKED_INV) return [];
  const items = LINKED_INV.items || [];
  const mods = [];
  for (const it of items){
    if (it.equipped === false) continue;
    const itemKey = itemChoiceKey(it);
    const allMods = [
      ...(it.modifiers || []).map(m=>({ ...m, __origin:'Item' })),
    ];
    (it.upgrades || []).forEach((u, idx)=>{
      const upgId = u?.id || u?.key || u;
      const meta = (window.UPGRADE_META || {})[upgId] || {};
      const pool = resolveUpgradeModifiers(u, meta);
      const name = meta?.name || u?.name || upgId || 'Upgrade';
      const choiceKey = upgradeChoiceKey(it, u, idx);
      (pool || []).forEach(m=>{
        allMods.push({ ...m, __origin:`Upgrade: ${name}`, __choice_key: choiceKey });
      });
    });
    for (const m of allMods){
      const originPrefix = m.__origin || 'Item';
      const note = m.note ? ` (${m.note})` : '';
      const origin = `[${originPrefix}] ${it.name || 'Item'}${note}`;
      const expanded = expandedTargets(m);
      expanded.forEach(em=>{
        const target = (em.target || em.key || '').trim();
        if (!target) return;
        const mode = (em.mode || m.mode || 'add').toLowerCase();
        const baseValue = numOr(em.value ?? m.value, 0);
        const quality_step = numOr(em.quality_step ?? m.quality_step ?? qualityStepFromNote(em.note || m.note), 0);
        const qualityDelta = quality_step ? qualityStepDelta(it.quality) : 0;
        const value = baseValue + (quality_step * qualityDelta);
        const level_step = Number(em.level_step ?? m.level_step ?? 0);
        const level_increment = Number(em.level_increment ?? m.level_increment ?? 1);
        if (target.startsWith('choice:')){
          const kind = target.replace('choice:','');
          const choiceKey = m.__choice_key || itemKey;
          const picks = normalizeChoiceEntry(itemChoiceState(choiceKey, kind)).picks;
          if (!picks.length) return;
          picks.forEach(sel=> mods.push({ target: sel, mode, value, level_step, level_increment, origin }));
          return;
        }
        mods.push({ target, mode, value, level_step, level_increment, origin });
      });
    }
  }
  return mods;
}

function getSpellEffectModifiers(){
  const mods = [];
  const meta = SPELLLIST_META.spell_meta || {};
  const allowedStatus = new Set(["known","learnt",""]);
  if (!Object.keys(EFFECTS_BY_ID).length && !EFFECTS_PROMISE){
    ensureEffectsLoaded().catch(()=>{});
  }
  for (const sp of SPELLLIST_SPELLS){
    const status = (meta[sp.id]?.status || "known");
    if (!allowedStatus.has(status)) continue;
    const effects = sp.effects || [];
    effects.forEach(eid=>{
      const key = String(eid||'').toLowerCase();
      const eff = EFFECTS_BY_ID[key] || {};
      const mlist = Array.isArray(eff.modifiers) ? eff.modifiers : [];
      mlist.forEach(m=>{
        const origin = `Spell: ${sp.name || sp.id}${eff.name ? ` / ${eff.name}` : ""}`;
        expandedTargets(m).forEach(em=>{
          const target = (em.target || em.key || '').trim();
          if (!target) return;
          const merged = { ...m, ...em };
          const mode = (merged.mode || 'add').toLowerCase();
          const value = modEffectiveValue(merged);
          const level_step = Number(merged.level_step || 0);
          const level_increment = Number(merged.level_increment ?? 1);
          mods.push({ target, mode, value, level_step, level_increment, origin });
        });
      });
    });
  }
  return mods;
}

function getSublimationEffects(){
  const mods = [];
  const hidden = { weaponNeutral:0, magicBonus:0, magicNature:'', conditionDC:0 };
  for (const s of SUBLIMATIONS || []){
    const t = (s.type||'').toLowerCase();
    const tier = Math.min(4, Math.max(1, Number(s.tier)||1));
    const origin = `Sublimation - ${t.charAt(0).toUpperCase()+t.slice(1)}`;
    if (t === 'lethality'){
      hidden.weaponNeutral += 2 * tier;
      continue;
    }
    if (t === 'blessing' || t === 'benediction'){
      hidden.magicBonus += 2 * tier;
      hidden.magicNature = s.nature || hidden.magicNature || '';
      continue;
    }
    if (t === 'excellence'){
      if (!s.skill) continue;
      const [ckey, sk] = s.skill.split('|');
      if (!ckey || !sk) continue;
      mods.push({ target:`skills.${ckey}.${sk}`, mode:'add', value:tier, origin:`${origin} (${sk})` });
      continue;
    }
    if (t === 'defense'){
      mods.push({ target:'derived.hp', mode:'add', value:12 * tier, origin });
      continue;
    }
    if (t === 'speed'){
      mods.push({ target:'derived.mo', mode:'add', value: tier, origin });
      continue;
    }
    if (t === 'devastation'){
      hidden.conditionDC += tier;
      continue;
    }
    if (t === 'clarity'){
      mods.push({ target:'derived.en', mode:'add', value: 2 * tier, origin });
      continue;
    }
    if (t === 'endurance'){
      mods.push({ target:'derived.fo', mode:'add', value: 2 * tier, origin });
      continue;
    }
  }
  SUB_HIDDEN = hidden;
  return { mods, hidden };
}

async function loadInventoriesList(){
  invStatusEl.textContent = 'Loading inventories...';
  try{
    const res = await api('/inventories');
    INVENTORIES = res.inventories || [];
    invSelectEl.innerHTML = '<option value="">-- Select inventory --</option>';
    INVENTORIES.forEach(inv=>{
      const opt = document.createElement('option');
      opt.value = inv.id;
      opt.textContent = inv.name || inv.id;
      if (inv.id === SELECTED_INV_ID) opt.selected = true;
      invSelectEl.appendChild(opt);
    });
    invStatusEl.textContent = '';
  }catch(e){
    invStatusEl.textContent = 'Load failed: ' + e.message;
  }
}

async function createInventoryAndLink(){
  const charName = nameEl.value?.trim() || 'Character';
  const invName = `${charName} Inventory`;
  try{
    invStatusEl.textContent = 'Creating inventory...';
    const res = await api('/inventories', {
      method:'POST',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ name: invName })
    });
    const inv = res.inventory || res;
    SELECTED_INV_ID = inv.id;
    CHAR.inventory_id = SELECTED_INV_ID;
    await loadInventoriesList();
    await loadInventoryById(SELECTED_INV_ID);
    invStatusEl.textContent = 'Created and linked.';
  }catch(e){
    invStatusEl.textContent = 'Create failed: ' + e.message;
    alert(e.message);
  }
}

async function duplicateAndLinkInventory(){
  const sourceId = SELECTED_INV_ID || LINKED_INV?.id || '';
  if (!sourceId){ invStatusEl.textContent = 'Load an inventory first to duplicate.'; return; }
  const charName = nameEl.value?.trim() || 'Character';
  const invName = `${charName} Inventory`;
  try{
    invStatusEl.textContent = 'Duplicating inventory...';
    const res = await api(`/inventories/${encodeURIComponent(sourceId)}/duplicate`, {
      method:'POST',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ name: invName })
    });
    const inv = res.inventory || res;
    SELECTED_INV_ID = inv.id;
    CHAR.inventory_id = SELECTED_INV_ID;
    await loadInventoriesList();
    await loadInventoryById(SELECTED_INV_ID);
    invStatusEl.textContent = 'Duplicated and linked.';
  }catch(e){
    invStatusEl.textContent = 'Duplicate failed: ' + e.message;
    alert(e.message);
  }
}

function renderInventoryUI(){
  if (!LINKED_INV){
    invManagerEl.style.display = 'none';
    if (invOpenManagerBtn) invOpenManagerBtn.style.display = 'none';
    invFundOpenBtn?.setAttribute('disabled','disabled');
    invCatalogOpenBtn?.setAttribute('disabled','disabled');
    return;
  }
  if (migrateUpgradeChoiceKeys(LINKED_INV.items || [])) queueSave();
  pruneItemChoices();
  invManagerEl.style.display = '';
  if (invOpenManagerBtn){
    invOpenManagerBtn.style.display = '';
    invOpenManagerBtn.href = `inventory_view.html?inv=${encodeURIComponent(LINKED_INV.id||'')}`;
  }
  invFundOpenBtn?.removeAttribute('disabled');
  invCatalogOpenBtn?.removeAttribute('disabled');
  invTitleEl.textContent = LINKED_INV.name || 'Inventory';
  // Money + currency selects
  const cur = LINKED_INV.currencies || {};
  invMoneyEl.innerHTML = Object.keys(cur).length
    ? Object.entries(cur).map(([k,v])=>`<span class="pill">${k}: ${v}</span>`).join(' ')
    : '<span class="muted">No funds</span>';
  invFundCurEl.innerHTML = '';
  invGlobalCurEl.innerHTML = '';
  Object.keys(cur).concat(["Jelly"]).filter((v,i,arr)=>arr.indexOf(v)===i).forEach(k=>{
    const o1=document.createElement('option'); o1.value=k; o1.textContent=k; invFundCurEl.appendChild(o1);
    const o2=document.createElement('option'); o2.value=k; o2.textContent=k; invGlobalCurEl.appendChild(o2);
  });
  invEncTotalEl.textContent = Number(LINKED_INV.enc_total||0).toFixed(1);

  // Containers & items
  const containers = LINKED_INV.containers || [];
  const items = LINKED_INV.items || [];
  invContainersEl.innerHTML = '';
  if (!containers.length){
    invContainersEl.innerHTML = '<div class="muted">No containers yet.</div>';
  }else{
    containers.forEach(c=>{
      const div = document.createElement('div');
      div.className = 'container-card';
      div.innerHTML = `
        <div class="container-head">
          <strong>${c.name || 'Container'}</strong>
          <span class="muted">Enc: ${Number(c.enc_total||0).toFixed(1)} ${c.include===false? '(excluded)':''}</span>
          <label class="row muted" style="gap:6px; align-items:center;">
            <input type="checkbox" data-cont="${c.id}" ${c.include===false?'':'checked'}> Include
          </label>
          ${c.built_in ? '' : `<button class="btn small" data-del="${c.id}">Delete</button>`}
        </div>
        <div class="items"></div>
      `;
      const list = div.querySelector('.items');
      const its = items.filter(it=> ((it.equipped!==false) ? SELF_CONTAINER_ID : (it.container_id||'')) === c.id);
      if (!its.length){
        list.innerHTML = '<div class="muted">No items.</div>';
      }else{
        its.forEach(it=>{
          const row = document.createElement('div');
          row.className = 'item-row';
          row.title = buildModifierSummary(it) || "";
          const hasChoice = itemHasChoice(it);
          row.innerHTML = `
            <div class="grow">
              <div><strong>${invEscapeHtml(it.alt_name || it.name || 'Item')}</strong> <span class="muted">x${it.quantity||1}</span></div>
              <div class="muted">${it.kind||''}${it.variant?` - ${invEscapeHtml(it.variant)}`:''}</div>
            </div>
            <div class="item-actions">
              <div class="pill">${Number(it.enc||0).toFixed(1)} enc</div>
              <button class="btn small toggle">${it.consumable ? 'Use' : (it.equipped!==false?'Unequip':'Equip')}</button>
              ${hasChoice ? '<button class="btn small choices">Choices</button>' : ''}
              <button class="btn small open">Open</button>
            </div>
          `;
          row.querySelector('.toggle').addEventListener('click', ()=> it.consumable ? useItemInline(it) : toggleEquipInline(it));
          const descTip = (it.description || it.desc || it.description_html || '').toString().trim();
          if (descTip){
            row.querySelector('strong')?.setAttribute('title', descTip);
          }
          if (hasChoice) row.querySelector('.choices')?.addEventListener('click', ()=> openItemChoiceModal(it));
          row.querySelector('.open').addEventListener('click', ()=> openInvItemModal(it));
          list.appendChild(row);
        });
      }
      invContainersEl.appendChild(div);
    });
  }
  // Wire include toggles
  invContainersEl.querySelectorAll('input[data-cont]').forEach(cb=>{
    cb.addEventListener('change', ()=> toggleContainerInclude(cb.getAttribute('data-cont'), cb.checked));
  });
  invContainersEl.querySelectorAll('button[data-del]').forEach(btn=>{
    btn.addEventListener('click', ()=> deleteContainer(btn.getAttribute('data-del')));
  });

  // Global container select for purchases/moves
  invGlobalContEl.innerHTML = '';
  containers.forEach(c=>{
    const o=document.createElement('option'); o.value=c.id; o.textContent=c.name||c.id; invGlobalContEl.appendChild(o);
  });
  const firstNonSelf = Array.from(invGlobalContEl.options).map(o=>o.value).find(v=>v !== SELF_CONTAINER_ID);
  if (firstNonSelf) invGlobalContEl.value = firstNonSelf;

  // Transactions
  const txs = (LINKED_INV.transactions || []).slice(-12).reverse();
  invTxEl.innerHTML = txs.length ? txs.map(t=>`<div class="row"><span class="pill">${t.currency||''} ${t.amount||0}</span><span class="muted">${invEscapeHtml(t.note||'')}</span><span class="muted">${t.ts||''}</span></div>`).join('') : '<div class="muted">No transactions.</div>';
  renderCombatWeapons();
}

async function loadInventoryById(id){
  if (!id){ LINKED_INV=null; SELECTED_INV_ID=''; CHAR.inventory_id=''; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave(); return; }
  invStatusEl.textContent = 'Loading inventory...';
  try{
    const res = await api('/inventories/' + encodeURIComponent(id));
    if (res.inventory){
      LINKED_INV = res.inventory;
      SELECTED_INV_ID = LINKED_INV.id || id;
      CHAR.inventory_id = SELECTED_INV_ID;
      const report = res.refresh_report;
      if (INITIAL_LOAD && report && report.count){
        const names = (report.changed_items || []).map(r=>r.name).filter(Boolean);
        const preview = names.slice(0, 5).join(", ");
        const suffix = names.length > 5 ? "..." : "";
        queueRefreshNotice(`Inventory updated (${report.count} item${report.count===1?"":"s"}): ${preview}${suffix}`);
      }
      renderInventoryUI();
      recomputePassiveAgg();
      renderStatistics();
      updateDerived();
      invStatusEl.textContent = 'Inventory loaded';
      queueSave();
    }else{
      throw new Error('Not found');
    }
  }catch(e){
    invStatusEl.textContent = 'Load failed: ' + e.message;
  }
}

function invEscapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}
function escapeHtml(s){ return invEscapeHtml(s); }
function buildModifierSummary(it){
  const out = [];
  const mods = Array.isArray(it?.modifiers) ? it.modifiers : [];
  mods.forEach(m=>{
    const mode = m.mode || "add";
    const val = m.value ?? "";
    const tgt = m.target || "";
    out.push(`${mode} ${val}${tgt ? " -> " + tgt : ""}`);
  });
  const ups = Array.isArray(it?.upgrades) ? it.upgrades : [];
  ups.forEach(u=>{
    const pool = Array.isArray(u.holder_modifiers) && u.holder_modifiers.length
      ? u.holder_modifiers
      : (Array.isArray(u.modifiers) ? u.modifiers : []);
    pool.forEach(m=>{
      const mode = m.mode || "add";
      const val = m.value ?? "";
      const tgt = m.target || "";
      out.push(`${mode} ${val}${tgt ? " -> " + tgt : ""}`);
    });
  });
  return out.join(", ");
}
function invToggleModal(modal, backdrop, open){
  if (!modal || !backdrop) return;
  if (open){
    modal.classList.remove('hidden');
    modal.classList.add('open');
    backdrop.classList.remove('hidden');
    backdrop.classList.add('open');
  }else{
    modal.classList.add('hidden');
    modal.classList.remove('open');
    backdrop.classList.remove('open');
    backdrop.classList.add('hidden');
  }
}

/* ---------- Rolling ---------- */
let ROLL_CONTEXT = null;
let ROLL_LOG_COUNT = 0;
let ROLL_CLICK_TIMER = null;
const DAZZLING_SPARK_IMAGE = '/assets/dazzling_spark/dazzling_spark.png';
const DAZZLING_SPARK_SOUND = '/assets/dazzling_spark/dazzling_spark.mp3';

function resetRollConditions(){
  if (condJ1El) condJ1El.checked = false;
  if (condJ2El) condJ2El.checked = false;
  if (condJ3El) condJ3El.checked = false;
  if (condM1El) condM1El.checked = false;
  if (condM2El) condM2El.checked = false;
  if (condM3El) condM3El.checked = false;
  if (condRecklessEl) condRecklessEl.checked = false;
  if (condMeticulousEl) condMeticulousEl.checked = false;
}

function applyRollConditionDefaults(conds){
  if (!conds) return;
  if (conds.jinxed >= 1 && condJ1El) condJ1El.checked = true;
  if (conds.jinxed >= 2 && condJ2El) condJ2El.checked = true;
  if (conds.jinxed >= 3 && condJ3El) condJ3El.checked = true;
  if (conds.motivated >= 1 && condM1El) condM1El.checked = true;
  if (conds.motivated >= 2 && condM2El) condM2El.checked = true;
  if (conds.motivated >= 3 && condM3El) condM3El.checked = true;
  if (conds.reckless && condRecklessEl) condRecklessEl.checked = true;
  if (conds.meticulous && condMeticulousEl) condMeticulousEl.checked = true;
}

function openRollModal(ctx){
  if (!rollModal || !rollBackdrop) return;
  ROLL_CONTEXT = ctx || {};
  if (rollTitleEl) rollTitleEl.textContent = ctx?.title || 'Roll';
  if (rollSubtitleEl) rollSubtitleEl.textContent = ctx?.subtitle || '';
  if (rollDetailsEl){
    const text = ctx?.detailsText || '';
    rollDetailsEl.textContent = text;
    rollDetailsEl.style.display = text ? '' : 'none';
  }
  if (rollDescEl){
    const html = ctx?.descHtml || '';
    const text = ctx?.descText || '';
    if (html){
      rollDescEl.innerHTML = html;
      rollDescEl.style.display = '';
    }else{
      rollDescEl.textContent = text;
      rollDescEl.style.display = text ? '' : 'none';
    }
  }
  if (rollBaseLabelEl) rollBaseLabelEl.textContent = ctx?.baseLabel || 'Base value';
  if (rollBaseEl) rollBaseEl.value = Number(ctx?.base || 0);
  if (rollModEl) rollModEl.value = Number(ctx?.mod || 0);
  if (rollTargetEl) rollTargetEl.value = ctx?.target != null ? ctx.target : '';
  if (rollAdvEl) rollAdvEl.value = ctx?.adv || 'normal';
  const infoOnly = !!ctx?.infoOnly;
  if (rollGridEl) rollGridEl.style.display = infoOnly ? 'none' : '';
  if (rollConditionsEl) rollConditionsEl.style.display = infoOnly ? 'none' : '';
  if (rollConditionsNoteEl) rollConditionsNoteEl.style.display = infoOnly ? 'none' : '';
  if (rollRun) rollRun.style.display = infoOnly ? 'none' : '';
  if (rollResultEl){
    rollResultEl.textContent = infoOnly ? 'Info only (no dice roll).' : '';
    rollResultEl.style.display = infoOnly ? '' : 'none';
  }
  resetRollConditions();
  applyRollConditionDefaults(ctx?.autoConds || {});
  invToggleModal(rollModal, rollBackdrop, true);
  if (infoOnly && ctx?.autoLog !== false){
    appendInfoLog(ctx);
  }
}

function closeRollModal(){
  if (!rollModal || !rollBackdrop) return;
  invToggleModal(rollModal, rollBackdrop, false);
}

function collectRollConditions(){
  const jinxed = (condJ1El?.checked ? 1 : 0) + (condJ2El?.checked ? 2 : 0) + (condJ3El?.checked ? 3 : 0);
  const motivated = (condM1El?.checked ? 1 : 0) + (condM2El?.checked ? 2 : 0) + (condM3El?.checked ? 3 : 0);
  return {
    jinxed,
    motivated,
    reckless: !!condRecklessEl?.checked,
    meticulous: !!condMeticulousEl?.checked
  };
}

function rollD10(){
  return Math.floor(Math.random() * 10) + 1;
}

function rollExplodingD10(){
  const rolls = [];
  let total = 0;
  let cur = rollD10();
  rolls.push(cur);
  total += cur;
  while (cur === 10 || cur === 1){
    cur = rollD10();
    rolls.push(cur);
    total += cur;
  }
  return { rolls, total };
}

function applyRollClamp(total, conds){
  let out = total;
  if (conds.reckless) out = Math.min(out, 5);
  if (conds.meticulous) out = Math.max(out, 5);
  return out;
}

function rollOnce(base, mod, conds, opts){
  const kind = opts?.kind || '';
  const first = rollD10();
  const rolls = [first];
  const rawTotal = first;
  let crit = null;
  let critDelta = 0;
  if (kind === 'skill' && (first === 1 || first === 10)){
    const critRoll = rollD10();
    const critSign = first === 10 ? 1 : -1;
    critDelta = critSign * critRoll;
    crit = { roll: critRoll, sign: critSign };
  }
  const rawWithCrit = rawTotal + critDelta;
  const clamped = applyRollClamp(rawWithCrit, conds);
  const total = clamped + base + mod;
  return { rolls, rawTotal, rawWithCrit, diceTotal: clamped, total, crit, critDelta };
}

function rollSummaryText(r){
  const rollsText = r.rolls.join(' + ');
  let text = `d10: ${rollsText} = ${r.rawTotal}`;
  if (r.crit && r.crit.roll){
    const sign = r.crit.sign > 0 ? '+' : '-';
    const rawWithCrit = r.rawTotal + (r.crit.sign * r.crit.roll);
    text += `, crit ${sign}${r.crit.roll}`;
    if (rawWithCrit !== r.rawTotal){
      text += ` => ${rawWithCrit}`;
    }
  }
  const rawForClamp = r.rawWithCrit != null ? r.rawWithCrit : r.rawTotal;
  if (r.diceTotal !== rawForClamp){
    text += ` -> ${r.diceTotal}`;
  }
  return text;
}

function formatConditionsSummary(conds){
  const parts = [];
  if (conds.jinxed) parts.push(`Jinxed -${conds.jinxed}`);
  if (conds.motivated) parts.push(`Motivated +${conds.motivated}`);
  if (conds.reckless) parts.push('Reckless (cap 5)');
  if (conds.meticulous) parts.push('Meticulous (floor 5)');
  return parts.join(' | ');
}

function playDazzlingSparkSound(){
  try{
    const audio = new Audio(DAZZLING_SPARK_SOUND);
    audio.volume = 0.8;
    audio.play().catch(()=>{});
  }catch{}
}

function attachRollImage(entry, imageSrc, caption){
  if (!entry || !imageSrc) return;
  entry.dataset.image = imageSrc;
  if (caption) entry.dataset.imageCaption = caption;
  const img = document.createElement('img');
  img.src = imageSrc;
  img.alt = caption || 'Roll image';
  entry.appendChild(img);
}

function appendRollImage(titleText, imageSrc){
  if (!rollLogEl) return;
  const entry = document.createElement('div');
  entry.className = 'roll-entry';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = titleText || 'Image';
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = new Date().toLocaleTimeString();
  const img = document.createElement('img');
  img.src = imageSrc;
  img.alt = titleText || 'Image';
  entry.appendChild(title);
  entry.appendChild(meta);
  entry.appendChild(img);
  appendRollLog(entry);
}

function sendCampaignChatImage(titleText, imageSrc){
  if (!CAMPAIGN_ID) return;
  const charId = CHAR?.id || CID || '';
  const displayName = (nameEl?.value || CHAR?.name || charId || 'Character');
  const payload = {
    type: 'image',
    text: titleText || 'Image',
    image: imageSrc,
    visibility: campaignChatVisibility(),
    ts: Date.now(),
    user: CURRENT_USER?.username || CHAR?.owner || 'Unknown',
    character_id: charId,
    character_name: displayName,
    character_avatar: charId ? `/characters/${encodeURIComponent(charId)}/avatar` : ''
  };
  postCampaignChatMessage(payload).then((ok)=>{
    if (ok) scheduleCampaignChatRefresh();
  });
}

function emitDazzlingSparkEffect(entry){
  playDazzlingSparkSound();
  attachRollImage(entry, DAZZLING_SPARK_IMAGE, 'Dazzling Spark');
}

function campaignChatVisibility(){
  if (!CAMPAIGN_ID) return 'public';
  return localStorage.getItem(`campaign_chat_visibility:${CAMPAIGN_ID}`) || 'public';
}

function setCampaignChatVisibilityPref(val){
  if (!CAMPAIGN_ID) return;
  localStorage.setItem(`campaign_chat_visibility:${CAMPAIGN_ID}`, val);
}

function toggleCampaignChatPanel(){
  if (!rollLogPanel || !campaignChatPanel) return;
  const showCampaign = !!CAMPAIGN_ID;
  rollLogPanel.style.display = showCampaign ? 'none' : 'flex';
  campaignChatPanel.style.display = showCampaign ? 'flex' : 'none';
}

async function loadCampaignInfo(){
  if (!CAMPAIGN_ID) return null;
  try{
    const res = await api(`/campaigns/${encodeURIComponent(CAMPAIGN_ID)}`);
    CAMPAIGN_INFO = res.campaign || res;
    return CAMPAIGN_INFO;
  }catch(e){
    console.warn('Campaign load failed', e);
    return null;
  }
}

function isCampaignGm(){
  const role = (CURRENT_USER?.role || '').toLowerCase();
  if (role === 'admin') return true;
  if (CAMPAIGN_INFO?.is_owner) return true;
  const owner = CAMPAIGN_INFO?.owner || '';
  return !!(owner && CURRENT_USER?.username && CURRENT_USER.username === owner);
}

function normalizeCampaignChatMessage(raw){
  const ts = raw.ts || raw.timestamp || raw.created_at || raw.time;
  const stamp = typeof ts === 'number' ? ts : (ts ? new Date(ts).getTime() : Date.now());
  return {
    id: raw.id || `${stamp}_${Math.random().toString(16).slice(2)}`,
    ts: stamp,
    visibility: (raw.visibility || raw.scope || 'public').toLowerCase(),
    type: raw.type || raw.kind || 'message',
    user: raw.user || raw.username || raw.sender || 'Unknown',
    character_id: raw.character_id || raw.characterId || raw.character?.id || '',
    character_name: raw.character_name || raw.characterName || raw.character?.name || raw.character_id || 'Character',
    character_avatar: raw.character_avatar || raw.avatar_url || raw.character?.avatar_url || '',
    text: raw.text || raw.message || raw.content || '',
    lines: raw.lines || raw.detail_lines || raw.details || [],
    image: raw.image || raw.image_url || raw.imageUrl || raw.media || ''
  };
}

function setCampaignChatMessages(list){
  CAMPAIGN_CHAT_MESSAGES = list || [];
  CAMPAIGN_CHAT_MESSAGE_IDS = new Set(CAMPAIGN_CHAT_MESSAGES.map(m=> m.id));
}

function addCampaignChatMessage(raw){
  const msg = normalizeCampaignChatMessage(raw);
  if (CAMPAIGN_CHAT_MESSAGE_IDS.has(msg.id)) return false;
  CAMPAIGN_CHAT_MESSAGE_IDS.add(msg.id);
  CAMPAIGN_CHAT_MESSAGES.push(msg);
  return true;
}

function campaignMessageVisible(msg){
  if (!msg) return false;
  if (msg.visibility === 'public') return true;
  const username = CURRENT_USER?.username || '';
  if (msg.visibility === 'self') return msg.user === username;
  if (msg.visibility === 'whisper') return isCampaignGm();
  return true;
}

function cleanChatLines(lines){
  return (lines || [])
    .map(l=> String(l || '').trim())
    .filter(Boolean)
    .filter(l=> !/^Image:/i.test(l) && !/^Image Caption:/i.test(l));
}

function imageFromChat(msg){
  if (!msg) return '';
  if (msg.image) return String(msg.image);
  const line = (msg.lines || []).find(l=> /^Image:/i.test(l));
  if (line) return line.replace(/^Image:\s*/i, '').trim();
  return '';
}

function isTimeLine(line){
  return /^\d{1,2}:\d{2}/.test(line || '');
}

function detailMapFromLine(line){
  const map = {};
  if (!line) return map;
  line.split('|').forEach(part=>{
    const clean = part.trim();
    const idx = clean.indexOf(':');
    if (idx === -1) return;
    const key = clean.slice(0, idx).trim().toLowerCase();
    const val = clean.slice(idx + 1).trim();
    if (key) map[key] = val;
  });
  return map;
}

function parseAbilityCard(msg){
  const lines = cleanChatLines(msg.lines);
  const typeLine = lines.find(l=> /^Type:/i.test(l));
  if (!typeLine) return null;
  const typeMatch = typeLine.match(/Type:\s*([^|]+)/i);
  const kind = typeMatch ? typeMatch[1].trim().toLowerCase() : '';
  if (kind !== 'active' && kind !== 'passive') return null;
  const details = detailMapFromLine(typeLine);
  const filtered = lines.filter(l=> l !== typeLine && !/^Source:/i.test(l) && !/^Info only/i.test(l) && !isTimeLine(l));
  let desc = '';
  const effectLine = filtered.find(l=> /^Effect:/i.test(l));
  if (effectLine) desc = effectLine.replace(/^Effect:\s*/i, '').trim();
  if (!desc){
    const descLine = filtered.find(l=> !/^Cost:/i.test(l) && !/^Range:/i.test(l) && !/^AoE:/i.test(l) && !/^Activation:/i.test(l));
    if (descLine) desc = descLine;
  }
  return { kind, details, desc };
}

function parseSkillCard(msg){
  const lines = cleanChatLines(msg.lines);
  const skillLine = lines.find(l=> /^Skill:/i.test(l));
  if (!skillLine) return null;
  const resultLine = lines.find(l=> /^Result:/i.test(l));
  const totalMatch = resultLine ? resultLine.match(/Result:\s*([+-]?\d+)/i) : null;
  const total = totalMatch ? totalMatch[1] : '';
  const modeLine = lines.find(l=> /^Roll type:/i.test(l));
  const condLine = lines.find(l=> /^Conditions:/i.test(l));
  const critLine = lines.find(l=> /^Critical/i.test(l));
  const effectLine = lines.find(l=> /^Effect:/i.test(l));
  const breakdownLine = lines.find(l=> /\bBase\b/i.test(l) && /\bMod\b/i.test(l));
  const baseMatch = breakdownLine ? breakdownLine.match(/\bBase\s+(-?\d+)/i) : null;
  const modMatch = breakdownLine ? breakdownLine.match(/\bMod\s+(-?\d+)/i) : null;
  const base = baseMatch ? baseMatch[1] : null;
  const mod = modMatch ? modMatch[1] : null;
  const summaryPart = breakdownLine ? breakdownLine.split('| Base')[0].trim() : '';
  const parts = [];
  if (summaryPart) parts.push(summaryPart);
  if (base != null) parts.push(`Skill ${base}`);
  if (mod != null) parts.push(`Mod ${mod}`);
  if (critLine) parts.push(critLine.replace(/^Critical:\s*/i, '').trim());
  const formula = parts.length ? `[ ${parts.join(' + ')} ]` : '';
  const rollType = modeLine ? modeLine.replace(/^Roll type:\s*/i, '').trim() : 'Simple';
  const condText = condLine ? condLine.replace(/^Conditions:\s*/i, '').trim().replace(/\s*\|\s*/g, ', ') : '';
  const sub = condText ? `Rolled with ${rollType} + ${condText}` : `Rolled with ${rollType}`;
  let critClass = '';
  if (critLine){
    const critText = critLine.replace(/^Critical:\s*/i, '').trim().toLowerCase();
    if (critText.includes('maximum')) critClass = 'crit-max';
    if (!critClass && (/success/i.test(critLine) || /\+\s*\d+/.test(critLine))) critClass = 'crit-success';
    if (!critClass && (/fail/i.test(critLine) || /-\s*\d+/.test(critLine))) critClass = 'crit-fail';
  }
  const effect = effectLine ? effectLine.replace(/^Effect:\s*/i, '').trim() : '';
  return { total, sub, formula, critClass, effect };
}

function parseDamageCard(msg){
  const title = msg.text || '';
  if (!/damage/i.test(title)) return null;
  const lines = cleanChatLines(msg.lines);
  const rollLine = lines.find(l=> /^(Result|Roll):/i.test(l));
  if (!rollLine) return null;
  const content = rollLine.replace(/^(Result|Roll):\s*/i, '');
  let types = [];
  const formulas = {};
  const segments = content.split('|').map(s=> s.trim()).filter(Boolean);
  segments.forEach(seg=>{
    const m = seg.match(/^([A-Za-z ]+?)\s+([+-]?\d+)(?:\s*\((.+)\))?$/);
    if (m){
      const label = m[1].trim();
      types.push({ name: label, total: m[2] });
      if (m[3]) formulas[label] = m[3].trim();
    }
  });
  if (!types.length){
    const inParen = content.match(/\((.+)\)/);
    if (!inParen) return null;
    const typeParts = inParen[1].split('+').map(p=> p.trim()).filter(Boolean);
    types = [];
    typeParts.forEach(part=>{
      const m = part.match(/^([A-Za-z ]+?)\s+([+-]?\d+)/);
      if (m) types.push({ name: m[1].trim(), total: m[2] });
    });
  }
  if (!types.length) return null;
  lines.forEach(line=>{
    const m = line.match(/^([A-Za-z ]+):\s*(.+)$/);
    if (m){
      const key = m[1].trim();
      if (!formulas[key]) formulas[key] = m[2].trim();
    }
  });
  if (!Object.keys(formulas).length){
    const breakdownLine = lines.find(l=> l !== rollLine && (/\|/.test(l) || /Neutral|Magic/i.test(l))) || '';
    const fallbackSegs = breakdownLine ? breakdownLine.split('|').map(s=> s.trim()).filter(Boolean) : [];
    fallbackSegs.forEach(seg=>{
      const m = seg.match(/([A-Za-z ]+?)\s+([+-]?\d+)/);
      if (m) formulas[m[1].trim()] = seg;
    });
  }
  return { types, formulas };
}

function appendRollCardImage(card, msg){
  if (!card || !msg) return;
  const imageSrc = msg.image || '';
  if (!imageSrc) return;
  const img = document.createElement('img');
  img.className = 'roll-image';
  img.src = imageSrc;
  img.alt = msg.imageCaption || msg.text || 'Roll image';
  card.appendChild(img);
}

function buildRollCard(msg){
  const skillMeta = parseSkillCard(msg);
  if (skillMeta){
    const card = document.createElement('div');
    card.className = `roll-card roll-skill ${skillMeta.critClass}`.trim();
    const title = document.createElement('div');
    title.className = 'roll-title';
    title.textContent = msg.text || 'Skill';
    const divider = document.createElement('div');
    divider.className = 'roll-divider';
    const sub = document.createElement('div');
    sub.className = 'roll-sub';
    sub.textContent = skillMeta.sub;
    const total = document.createElement('div');
    total.className = 'roll-total';
    total.textContent = skillMeta.total || '--';
    card.appendChild(title);
    card.appendChild(divider);
    card.appendChild(sub);
    card.appendChild(total);
    if (skillMeta.formula){
      const formula = document.createElement('div');
      formula.className = 'roll-formula';
      formula.textContent = skillMeta.formula;
      card.appendChild(formula);
    }
    if (skillMeta.effect){
      const desc = document.createElement('div');
      desc.className = 'roll-desc';
      desc.textContent = skillMeta.effect;
      card.appendChild(desc);
    }
    appendRollCardImage(card, msg);
    return card;
  }
  const abilityMeta = parseAbilityCard(msg);
  if (abilityMeta){
    const card = document.createElement('div');
    card.className = `roll-card roll-ability ${abilityMeta.kind === 'active' ? 'is-active' : 'is-passive'}`.trim();
    const title = document.createElement('div');
    title.className = 'roll-title';
    title.textContent = msg.text || 'Ability';
    const divider = document.createElement('div');
    divider.className = 'roll-divider';
    card.appendChild(title);
    card.appendChild(divider);
    if (abilityMeta.kind === 'active'){
      const metaLine = document.createElement('div');
      metaLine.className = 'roll-meta-line';
      const parts = [];
      if (abilityMeta.details.cost) parts.push(`Cost: ${abilityMeta.details.cost}`);
      if (abilityMeta.details.aoe) parts.push(`AoE: ${abilityMeta.details.aoe}`);
      if (abilityMeta.details.range) parts.push(`Range: ${abilityMeta.details.range}`);
      metaLine.textContent = parts.join(' || ');
      if (metaLine.textContent) card.appendChild(metaLine);
      if (abilityMeta.details.activation){
        const activationLine = document.createElement('div');
        activationLine.className = 'roll-meta-line';
        activationLine.textContent = `Activation: ${abilityMeta.details.activation}`;
        card.appendChild(activationLine);
      }
    }
    if (abilityMeta.desc){
      const desc = document.createElement('div');
      desc.className = 'roll-desc';
      desc.textContent = abilityMeta.desc;
      card.appendChild(desc);
    }
    appendRollCardImage(card, msg);
    return card;
  }
  const dmgMeta = parseDamageCard(msg);
  if (dmgMeta){
    const card = document.createElement('div');
    card.className = 'roll-card roll-damage';
    const title = document.createElement('div');
    title.className = 'roll-title';
    title.textContent = msg.text || 'Weapon Damage';
    card.appendChild(title);
    const topDivider = document.createElement('div');
    topDivider.className = 'roll-divider';
    card.appendChild(topDivider);
    dmgMeta.types.forEach((row, idx)=>{
      const rowEl = document.createElement('div');
      rowEl.className = 'roll-dmg-row';
      const typeEl = document.createElement('div');
      typeEl.className = 'roll-dmg-type';
      typeEl.textContent = row.name;
      const valueEl = document.createElement('div');
      valueEl.className = 'roll-dmg-value';
      valueEl.textContent = row.total;
      rowEl.appendChild(typeEl);
      rowEl.appendChild(valueEl);
      card.appendChild(rowEl);
      const formulaText = dmgMeta.formulas[row.name];
      if (formulaText){
        const formula = document.createElement('div');
        formula.className = 'roll-formula';
        formula.textContent = `[ ${formulaText} ]`;
        card.appendChild(formula);
      }
      if (idx < dmgMeta.types.length - 1){
        const sep = document.createElement('div');
        sep.className = 'roll-divider';
        card.appendChild(sep);
      }
    });
    appendRollCardImage(card, msg);
    return card;
  }
  return null;
}

function renderCampaignChat(){
  if (!campaignChatLog) return;
  campaignChatLog.innerHTML = '';
  const visible = CAMPAIGN_CHAT_MESSAGES.filter(campaignMessageVisible).sort((a,b)=>a.ts-b.ts);
  if (!visible.length){
    campaignChatLog.innerHTML = '<div class="muted">No messages yet.</div>';
    return;
  }
  let lastGroup = null;
  visible.forEach(msg=>{
    const key = `${msg.user}|${msg.character_id}`;
    const within = lastGroup && lastGroup.key === key && (msg.ts - lastGroup.lastTs) <= 5 * 60 * 1000;
    let group = lastGroup?.el;
    if (!within){
      group = document.createElement('div');
      group.className = 'chat-group';
      const head = document.createElement('div');
      head.className = 'chat-head';
      const avatar = document.createElement('div');
      avatar.className = 'chat-avatar';
      const img = document.createElement('img');
      img.src = msg.character_avatar || (msg.character_id ? `/characters/${encodeURIComponent(msg.character_id)}/avatar` : '');
      img.onerror = () => { img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9WUZPi8AAAAASUVORK5CYII='; };
      avatar.appendChild(img);
      const info = document.createElement('div');
      info.innerHTML = `<div class="chat-user">${msg.character_name}</div><div class="muted">${msg.user}</div>`;
      head.appendChild(avatar);
      head.appendChild(info);
      group.appendChild(head);
      const lines = document.createElement('div');
      lines.className = 'chat-lines';
      group.appendChild(lines);
      campaignChatLog.appendChild(group);
      lastGroup = { key, el: group, lastTs: msg.ts };
    }
    const lines = group.querySelector('.chat-lines');
    const line = document.createElement('div');
    const imageSrc = imageFromChat(msg);
    if (msg.type === 'image' || (imageSrc && msg.type !== 'roll')){
      line.className = `chat-line chat-image ${msg.visibility}`;
      if (msg.text){
        const caption = document.createElement('div');
        caption.className = 'caption';
        caption.textContent = msg.text;
        line.appendChild(caption);
      }
      const img = document.createElement('img');
      img.src = imageSrc;
      img.alt = msg.text || 'Image';
      line.appendChild(img);
      const meta = document.createElement('div');
      meta.className = 'muted';
      meta.textContent = `${new Date(msg.ts).toLocaleTimeString()} | ${msg.visibility}`;
      line.appendChild(meta);
      lines.appendChild(line);
      if (lastGroup) lastGroup.lastTs = msg.ts;
      return;
    }
    if (msg.type === 'roll'){
      const card = buildRollCard({ ...msg, image: imageSrc });
      if (card){
        line.className = `chat-line chat-roll ${msg.visibility}`;
        const meta = document.createElement('div');
        meta.className = 'roll-foot';
        meta.textContent = `${new Date(msg.ts).toLocaleTimeString()} | ${msg.visibility}`;
        card.appendChild(meta);
        line.appendChild(card);
        lines.appendChild(line);
        if (lastGroup) lastGroup.lastTs = msg.ts;
        return;
      }
    }
    line.className = `chat-line ${msg.visibility}`;
    const title = document.createElement('div');
    title.textContent = msg.text || (msg.type === 'roll' ? 'Roll' : 'Message');
    line.appendChild(title);
    (msg.lines || []).forEach(l=>{
      if (!l) return;
      const div = document.createElement('div');
      div.className = 'muted';
      div.textContent = l;
      line.appendChild(div);
    });
    const meta = document.createElement('div');
    meta.className = 'muted';
    meta.textContent = `${new Date(msg.ts).toLocaleTimeString()} | ${msg.visibility}`;
    line.appendChild(meta);
    lines.appendChild(line);
    if (lastGroup) lastGroup.lastTs = msg.ts;
  });
  campaignChatLog.scrollTop = campaignChatLog.scrollHeight;
}

function saveCampaignChatLocal(){
  if (!CAMPAIGN_CHAT_STORAGE_KEY) return;
  localStorage.setItem(CAMPAIGN_CHAT_STORAGE_KEY, JSON.stringify(CAMPAIGN_CHAT_MESSAGES.slice(-400)));
}

function loadCampaignChatLocal(){
  if (!CAMPAIGN_CHAT_STORAGE_KEY) return [];
  const raw = localStorage.getItem(CAMPAIGN_CHAT_STORAGE_KEY);
  if (!raw) return [];
  try{
    return JSON.parse(raw).map(normalizeCampaignChatMessage);
  }catch{
    return [];
  }
}

async function loadCampaignChat(){
  if (!CAMPAIGN_ID) return;
  if (!campaignChatLog) return;
  if (!CAMPAIGN_CHAT_API_OK){
    setCampaignChatMessages(loadCampaignChatLocal());
    renderCampaignChat();
    return;
  }
  try{
    const res = await api(`/campaigns/${encodeURIComponent(CAMPAIGN_ID)}/chat`);
    setCampaignChatMessages((res.messages || res.chat || []).map(normalizeCampaignChatMessage));
    renderCampaignChat();
  }catch(e){
    CAMPAIGN_CHAT_API_OK = false;
    closeCampaignChatSocket();
    setCampaignChatMessages(loadCampaignChatLocal());
    renderCampaignChat();
    if (campaignChatStatus) campaignChatStatus.textContent = 'Chat API unavailable, using local log.';
  }
}

function scheduleCampaignChatRefresh(){
  if (CAMPAIGN_CHAT_REFRESH_TIMER) return;
  CAMPAIGN_CHAT_REFRESH_TIMER = setTimeout(()=>{
    CAMPAIGN_CHAT_REFRESH_TIMER = null;
    loadCampaignChat();
  }, 500);
}

function startCampaignChatPolling(){
  if (CAMPAIGN_CHAT_POLL) return;
  CAMPAIGN_CHAT_POLL = setInterval(loadCampaignChat, 5000);
}

function stopCampaignChatPolling(){
  if (!CAMPAIGN_CHAT_POLL) return;
  clearInterval(CAMPAIGN_CHAT_POLL);
  CAMPAIGN_CHAT_POLL = null;
}

function campaignChatSocketUrl(){
  const token = localStorage.getItem('auth_token') || '';
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  return `${proto}://${location.host}/campaigns/${encodeURIComponent(CAMPAIGN_ID)}/chat/ws?token=${encodeURIComponent(token)}`;
}

function closeCampaignChatSocket(){
  if (CAMPAIGN_CHAT_WS){
    CAMPAIGN_CHAT_WS.close();
    CAMPAIGN_CHAT_WS = null;
  }
  if (CAMPAIGN_CHAT_WS_RETRY){
    clearTimeout(CAMPAIGN_CHAT_WS_RETRY);
    CAMPAIGN_CHAT_WS_RETRY = null;
  }
}

function scheduleCampaignChatReconnect(){
  if (CAMPAIGN_CHAT_WS_RETRY) return;
  CAMPAIGN_CHAT_WS_RETRY = setTimeout(()=>{
    CAMPAIGN_CHAT_WS_RETRY = null;
    connectCampaignChatSocket();
  }, 2000);
}

function connectCampaignChatSocket(){
  if (!CAMPAIGN_ID || !CAMPAIGN_CHAT_API_OK) return;
  if (CAMPAIGN_CHAT_WS && (CAMPAIGN_CHAT_WS.readyState === WebSocket.OPEN || CAMPAIGN_CHAT_WS.readyState === WebSocket.CONNECTING)) return;
  const token = localStorage.getItem('auth_token') || '';
  if (!token){
    startCampaignChatPolling();
    return;
  }
  CAMPAIGN_CHAT_WS = new WebSocket(campaignChatSocketUrl());
  CAMPAIGN_CHAT_WS.onopen = ()=>{
    if (campaignChatStatus) campaignChatStatus.textContent = 'Live';
    stopCampaignChatPolling();
  };
  CAMPAIGN_CHAT_WS.onmessage = (event)=>{
    let payload = null;
    try{
      const data = JSON.parse(event.data || '{}');
      payload = data.message || data;
    }catch{
      return;
    }
    if (!payload) return;
    if (addCampaignChatMessage(payload)){
      renderCampaignChat();
    }
  };
  CAMPAIGN_CHAT_WS.onclose = ()=>{
    CAMPAIGN_CHAT_WS = null;
    if (CAMPAIGN_CHAT_API_OK){
      if (campaignChatStatus) campaignChatStatus.textContent = 'Reconnecting...';
      scheduleCampaignChatReconnect();
      startCampaignChatPolling();
    }
  };
  CAMPAIGN_CHAT_WS.onerror = ()=>{};
}

function serializeRollEntry(entry){
  const parts = Array.from(entry.children).map(el=> (el.textContent || '').trim()).filter(Boolean);
  const titleEl = entry.querySelector('.title');
  const title = titleEl ? titleEl.textContent : (parts[0] || 'Log');
  if (parts[0] === title) parts.shift();
  const image = entry?.dataset?.image || '';
  const imageCaption = entry?.dataset?.imageCaption || '';
  return { title, lines: parts, image, imageCaption };
}

function buildRollCardFromEntry(entry){
  const data = serializeRollEntry(entry);
  if (!data.title) return null;
  const msg = { type:'roll', text: data.title, lines: data.lines || [], image: data.image, imageCaption: data.imageCaption };
  const card = buildRollCard(msg);
  if (!card) return null;
  const metaText = entry.querySelector('.meta')?.textContent || '';
  if (metaText){
    const foot = document.createElement('div');
    foot.className = 'roll-foot';
    foot.textContent = metaText;
    card.appendChild(foot);
  }
  return card;
}

async function postCampaignChatMessage(payload){
  if (!CAMPAIGN_ID) return false;
  if (CAMPAIGN_CHAT_API_OK){
    try{
      await api(`/campaigns/${encodeURIComponent(CAMPAIGN_ID)}/chat`, {
        method:'POST',
        headers:{ 'content-type':'application/json' },
        body: JSON.stringify(payload)
      });
      return true;
    }catch(e){
      CAMPAIGN_CHAT_API_OK = false;
      closeCampaignChatSocket();
      if (campaignChatStatus) campaignChatStatus.textContent = 'Chat API unavailable, using local log.';
    }
  }
  addCampaignChatMessage(payload);
  saveCampaignChatLocal();
  renderCampaignChat();
  return false;
}

function queueCampaignChat(entry){
  if (!CAMPAIGN_ID) return;
  const data = serializeRollEntry(entry);
  const charId = CHAR?.id || CID || '';
  const displayName = (nameEl?.value || CHAR?.name || charId || 'Character');
  const lines = (data.lines || []).slice();
  if (data.image && !lines.some(l=> /^Image:/i.test(l))){
    lines.push(`Image: ${data.image}`);
  }
  const payload = {
    type: 'roll',
    text: data.title,
    lines,
    visibility: campaignChatVisibility(),
    ts: Date.now(),
    user: CURRENT_USER?.username || CHAR?.owner || 'Unknown',
    character_id: charId,
    character_name: displayName,
    character_avatar: charId ? `/characters/${encodeURIComponent(charId)}/avatar` : ''
  };
  postCampaignChatMessage(payload).then((ok)=>{
    if (ok) scheduleCampaignChatRefresh();
  });
}

function appendRollLog(entry){
  if (CAMPAIGN_ID){
    queueCampaignChat(entry);
    return;
  }
  if (!rollLogEl) return;
  if (rollLogEmptyEl) rollLogEmptyEl.style.display = 'none';
  const card = buildRollCardFromEntry(entry);
  rollLogEl.appendChild(card || entry);
  rollLogEl.scrollTop = rollLogEl.scrollHeight;
  ROLL_LOG_COUNT += 1;
  if (rollLogCountEl) rollLogCountEl.textContent = `(${ROLL_LOG_COUNT})`;
}

function appendRollDesc(entry){
  if (!ROLL_CONTEXT) return;
  const html = ROLL_CONTEXT.logDescHtml || '';
  const text = ROLL_CONTEXT.logDescText || '';
  if (html){
    const desc = document.createElement('div');
    desc.innerHTML = html;
    entry.appendChild(desc);
  }else if (text){
    const desc = document.createElement('div');
    desc.textContent = text;
    entry.appendChild(desc);
  }
}

function appendInfoLog(ctx){
  const entry = document.createElement('div');
  entry.className = 'roll-entry';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = ctx?.title || 'Info';
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = new Date().toLocaleTimeString();
  entry.appendChild(title);
  entry.appendChild(meta);
  (ctx?.detailLines || []).forEach(line=>{
    if (!line) return;
    const div = document.createElement('div');
    div.className = 'muted';
    div.textContent = line;
    entry.appendChild(div);
  });
  if (ctx?.descHtml){
    const desc = document.createElement('div');
    desc.innerHTML = ctx.descHtml;
    entry.appendChild(desc);
  }else if (ctx?.descText){
    const desc = document.createElement('div');
    desc.textContent = ctx.descText;
    entry.appendChild(desc);
  }
  const infoLine = document.createElement('div');
  infoLine.textContent = 'Info only (no dice roll).';
  entry.appendChild(infoLine);
  appendRollLog(entry);
}

function queueInfoOpen(cb){
  clearTimeout(ROLL_CLICK_TIMER);
  ROLL_CLICK_TIMER = setTimeout(cb, 200);
}

function handleInfoClick(e, cb){
  if (!e || !cb) return;
  if (e.target.closest('button')) return;
  if (e.target.closest('a')) return;
  if (e.target.closest('input') || e.target.closest('select') || e.target.closest('textarea')) return;
  if (e.detail > 1){
    clearTimeout(ROLL_CLICK_TIMER);
    return;
  }
  queueInfoOpen(cb);
}

function clearRollLog(){
  if (!rollLogEl) return;
  rollLogEl.innerHTML = '';
  if (rollLogEmptyEl){
    rollLogEmptyEl.style.display = '';
    rollLogEl.appendChild(rollLogEmptyEl);
  }
  ROLL_LOG_COUNT = 0;
  if (rollLogCountEl) rollLogCountEl.textContent = '';
}

function rollDice(count, sides){
  const rolls = [];
  for (let i=0; i<count; i++) rolls.push(Math.floor(Math.random() * sides) + 1);
  const total = rolls.reduce((a,b)=>a+b,0);
  return { rolls, total };
}

function parseRollExpression(expr){
  const raw = expr.trim();
  if (!raw) return null;
  const adv = /\badv\b/i.test(raw);
  const dis = /\bdis\b/i.test(raw);
  const cleaned = raw.replace(/\badv\b/ig,'').replace(/\bdis\b/ig,'').trim();
  const match = cleaned.match(/^(\d+)?d(\d+)([+-]\d+)?$/i);
  if (!match) return null;
  const count = Math.max(1, Number(match[1] || 1));
  const sides = Math.max(2, Number(match[2] || 6));
  const mod = Number(match[3] || 0);
  return { count, sides, mod, adv, dis, label: `${count}d${sides}${mod ? (mod > 0 ? `+${mod}` : mod) : ''}` };
}

function buildChatRollMessage(expr, visibility){
  const parsed = parseRollExpression(expr);
  if (!parsed) return { error:'Invalid roll format. Use /r XdY +Z adv|dis.' };
  const attempt = () => {
    const dice = rollDice(parsed.count, parsed.sides);
    return { rolls: dice.rolls, subtotal: dice.total, total: dice.total + parsed.mod };
  };
  let picked = attempt();
  let alt = null;
  if ((parsed.adv || parsed.dis) && !(parsed.adv && parsed.dis)){
    alt = attempt();
    picked = parsed.adv ? (picked.total >= alt.total ? picked : alt) : (picked.total <= alt.total ? picked : alt);
  }
  const lines = [];
  lines.push(`Expression: ${parsed.label}${parsed.adv ? ' adv' : ''}${parsed.dis ? ' dis' : ''}`.trim());
  lines.push(`Rolls: ${picked.rolls.join(' + ')} = ${picked.subtotal} ${parsed.mod ? (parsed.mod > 0 ? `+ ${parsed.mod}` : `- ${Math.abs(parsed.mod)}`) : ''}`.trim());
  lines.push(`Total: ${picked.total}`);
  if (alt){
    lines.push(`Other: ${alt.rolls.join(' + ')} = ${alt.subtotal} ${parsed.mod ? (parsed.mod > 0 ? `+ ${parsed.mod}` : `- ${Math.abs(parsed.mod)}`) : ''}`.trim());
  }
  return { text:`Roll ${parsed.label}`, lines, visibility };
}

async function handleCampaignChatSend(){
  const raw = (campaignChatInput?.value || '').trim();
  if (!raw || !CAMPAIGN_ID) return;
  let visibility = campaignChatVisibilityEl?.value || 'public';
  let content = raw;
  if (content.startsWith('/w')){
    visibility = 'whisper';
    content = content.slice(2).trim();
  }else if (content.startsWith('/s')){
    visibility = 'self';
    content = content.slice(2).trim();
  }
  const charId = CHAR?.id || CID || '';
  const displayName = (nameEl?.value || CHAR?.name || charId || 'Character');
  const basePayload = {
    visibility,
    ts: Date.now(),
    user: CURRENT_USER?.username || CHAR?.owner || 'Unknown',
    character_id: charId,
    character_name: displayName,
    character_avatar: charId ? `/characters/${encodeURIComponent(charId)}/avatar` : ''
  };
  if (content.startsWith('/r')){
    const expr = content.slice(2).trim();
    const roll = buildChatRollMessage(expr, visibility);
    if (roll.error){
      alert(roll.error);
      return;
    }
    await postCampaignChatMessage({ ...basePayload, type:'roll', text: roll.text, lines: roll.lines });
  }else{
    await postCampaignChatMessage({ ...basePayload, type:'message', text: content, lines: [] });
  }
  scheduleCampaignChatRefresh();
  if (campaignChatInput) campaignChatInput.value = '';
}

async function initCampaignChat(){
  if (CAMPAIGN_CHAT_READY) return;
  toggleCampaignChatPanel();
  if (!CAMPAIGN_ID || !campaignChatPanel) return;
  CAMPAIGN_CHAT_READY = true;
  campaignChatSend?.addEventListener('click', handleCampaignChatSend);
  campaignChatInput?.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter' && !e.shiftKey){
      e.preventDefault();
      handleCampaignChatSend();
    }
  });
  campaignChatVisibilityEl?.addEventListener('change', ()=>{
    if (campaignChatVisibilityEl) setCampaignChatVisibilityPref(campaignChatVisibilityEl.value);
  });
  await loadCampaignInfo();
  if (campaignChatSpeaker) campaignChatSpeaker.textContent = nameEl?.value || CHAR?.name || 'Character';
  if (campaignChatVisibilityEl) campaignChatVisibilityEl.value = campaignChatVisibility();
  await loadCampaignChat();
  if (CAMPAIGN_CHAT_API_OK){
    connectCampaignChatSocket();
  }else{
    window.addEventListener('storage', (e)=>{
      if (e.key === CAMPAIGN_CHAT_STORAGE_KEY){
        setCampaignChatMessages(loadCampaignChatLocal());
        renderCampaignChat();
      }
    });
  }
}

function runRoll(){
  if (!ROLL_CONTEXT) return;
  if (ROLL_CONTEXT.infoOnly) return;
  const base = Number(rollBaseEl?.value || 0) || 0;
  const mod = Number(rollModEl?.value || 0) || 0;
  const targetRaw = rollTargetEl?.value;
  const target = targetRaw === '' || targetRaw == null ? null : Number(targetRaw);
  const conds = collectRollConditions();
  const mode = rollAdvEl?.value || 'normal';
  const rollKind = ROLL_CONTEXT?.rollKind || '';
  const rollModeLabel = mode === 'adv' ? 'Advantage' : (mode === 'dis' ? 'Disadvantage' : 'Simple');

  const first = rollOnce(base, mod, conds, { kind: rollKind });
  let second = null;
  let chosen = first;
  if (mode !== 'normal'){
    second = rollOnce(base, mod, conds, { kind: rollKind });
    chosen = (mode === 'adv')
      ? (first.total >= second.total ? first : second)
      : (first.total <= second.total ? first : second);
  }

  const isMaxRoll = rollKind === 'skill'
    && chosen.crit
    && chosen.crit.sign > 0
    && chosen.crit.roll === 10
    && Array.isArray(chosen.rolls)
    && chosen.rolls[0] === 10;
  const critNote = (rollKind === 'skill' && chosen.crit)
    ? {
      label: isMaxRoll ? 'Maximum Roll' : (chosen.crit.sign > 0 ? 'Critical Success' : 'Critical Fail'),
      delta: chosen.crit.sign * chosen.crit.roll,
      isMax: isMaxRoll
    }
    : null;

  const preCondTotal = chosen.total;
  let finalTotal = preCondTotal;
  let successState = '';
  let conditionDelta = 0;
  if (target != null && Number.isFinite(target)){
    successState = preCondTotal >= target ? 'success' : 'fail';
    if (successState === 'success' && conds.jinxed){
      finalTotal -= conds.jinxed;
      conditionDelta = -conds.jinxed;
    }else if (successState === 'fail' && conds.motivated){
      finalTotal += conds.motivated;
      conditionDelta = conds.motivated;
    }
  }

  const summaryLine = mode === 'normal'
    ? rollSummaryText(chosen)
    : `Roll A: ${rollSummaryText(first)} | Roll B: ${rollSummaryText(second)} | Chosen: ${chosen === first ? 'A' : 'B'}`;
  const condSummary = formatConditionsSummary(conds);
  const resultText = target != null && Number.isFinite(target)
    ? `Result: ${finalTotal} (target ${target}, ${successState}${conditionDelta ? `, adjusted ${conditionDelta > 0 ? '+' : ''}${conditionDelta}` : ''})`
    : `Result: ${finalTotal}`;

  if (rollResultEl){
    rollResultEl.textContent = resultText;
    rollResultEl.style.display = '';
  }

  const entry = document.createElement('div');
  entry.className = 'roll-entry';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = ROLL_CONTEXT.title || 'Roll';
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = new Date().toLocaleTimeString();
  entry.appendChild(title);
  entry.appendChild(meta);

  (ROLL_CONTEXT.detailLines || []).forEach(line=>{
    if (!line) return;
    const div = document.createElement('div');
    div.className = 'muted';
    div.textContent = line;
    entry.appendChild(div);
  });

  appendRollDesc(entry);

  if (rollKind === 'skill'){
    const modeLine = document.createElement('div');
    modeLine.className = 'muted';
    modeLine.textContent = `Roll type: ${rollModeLabel}`;
    entry.appendChild(modeLine);
    if (critNote){
      const critLine = document.createElement('div');
      critLine.className = 'muted';
      critLine.textContent = `Critical: ${critNote.label} ${critNote.delta >= 0 ? '+' : ''}${critNote.delta}`;
      entry.appendChild(critLine);
    }
  }

  const rollLine = document.createElement('div');
  rollLine.textContent = resultText;
  entry.appendChild(rollLine);

  const breakdown = document.createElement('div');
  breakdown.className = 'muted';
  breakdown.textContent = `${summaryLine} | Base ${base} | Mod ${mod}`;
  entry.appendChild(breakdown);

  if (condSummary){
    const condLine = document.createElement('div');
    condLine.className = 'muted';
    condLine.textContent = `Conditions: ${condSummary}`;
    entry.appendChild(condLine);
  }

  if (critNote?.isMax){
    emitDazzlingSparkEffect(entry);
  }
  appendRollLog(entry);
}

function abilityRollDetails(a){
  const isPassive = (a?.type || '').toLowerCase() !== 'active';
  const desc = isPassive ? (a?.passive?.description_html || a?.passive?.description || a?.description_html || a?.description || '') : (a?.description_html || a?.description || '');
  const cost = isPassive ? '' : abilityCostText(a);
  const range = isPassive ? '' : (a?.active?.range || a?.range || '');
  const aoe = isPassive ? '' : (a?.active?.aoe || a?.aoe || '');
  const activation = isPassive ? '' : (a?.active?.activation || a?.activation || '');
  const type = a?.type || '';
  return { desc, cost, range, aoe, activation, type };
}

function openSkillRoll(charKey, charLabel, skillName){
  const adj = skillAdjTotal(charKey, skillName);
  const cond = getCombatRollModifiers('skill', skillName);
  openRollModal({
    title: skillName,
    subtitle: `${charLabel} skill`,
    baseLabel: 'Skill value',
    base: adj.total,
    mod: cond.mod,
    adv: cond.adv || 'normal',
    autoConds: cond.conds,
    detailsText: `Skill: ${skillName} (${charLabel})`,
    descText: '',
    detailLines: [`Skill: ${skillName} (${charLabel})`],
    rollKind: 'skill'
  });
}

function openAbilityRoll(a, sourceLabel){
  const details = abilityRollDetails(a);
  const titleText = a?.name || a?.id || 'Ability';
  const parts = [];
  if (details.type) parts.push(`Type: ${details.type}`);
  if (details.cost) parts.push(`Cost: ${details.cost}`);
  if (details.range) parts.push(`Range: ${details.range}`);
  if (details.aoe) parts.push(`AoE: ${details.aoe}`);
  if (details.activation) parts.push(`Activation: ${details.activation}`);
  const detailLine = parts.join(' | ');
  const lines = [];
  if (sourceLabel) lines.push(`Source: ${sourceLabel}`);
  if (detailLine) lines.push(detailLine);
  openRollModal({
    title: titleText,
    subtitle: sourceLabel ? `${sourceLabel} ability` : 'Ability',
    baseLabel: 'Base value',
    base: 0,
    detailsText: detailLine,
    descHtml: details.desc || '',
    detailLines: lines,
    infoOnly: true
  });
}

function openCombatAbilityRoll(a, sourceLabel){
  const details = abilityRollDetails(a);
  const titleText = a?.name || a?.id || 'Ability';
  const parts = [];
  if (details.type) parts.push(`Type: ${details.type}`);
  if (details.cost) parts.push(`Cost: ${details.cost}`);
  if (details.range) parts.push(`Range: ${details.range}`);
  if (details.aoe) parts.push(`AoE: ${details.aoe}`);
  if (details.activation) parts.push(`Activation: ${details.activation}`);
  const detailLine = parts.join(' | ');
  const lines = [];
  if (sourceLabel) lines.push(`Source: ${sourceLabel}`);
  if (detailLine) lines.push(detailLine);
  openRollModal({
    title: titleText,
    subtitle: sourceLabel ? `${sourceLabel} ability` : 'Ability',
    baseLabel: 'Base value',
    base: 0,
    detailsText: detailLine,
    descHtml: details.desc || '',
    logDescHtml: details.desc || '',
    detailLines: lines,
    infoOnly: false
  });
}

function openSpellRoll(sp, meta, info){
  const titleText = info?.nameDisplay || meta?.alt_name || sp?.name || 'Spell';
  const rangeText = info?.range ? (String(info.range).toLowerCase().startsWith('range:') ? info.range : `Range: ${info.range}`) : '';
  const aoeText = info?.aoe ? (String(info.aoe).toLowerCase().startsWith('aoe:') ? info.aoe : `AoE: ${info.aoe}`) : '';
  const activationRaw = sp?.activation || sp?.cast_time || '';
  const activationText = activationRaw ? (String(activationRaw).toLowerCase().startsWith('activation:') ? activationRaw : `Activation: ${activationRaw}`) : '';
  const parts = ['Type: Active'];
  if (info?.cost) parts.push(`Cost: ${info.cost}`);
  if (rangeText) parts.push(rangeText);
  if (aoeText) parts.push(aoeText);
  if (activationText) parts.push(activationText);
  const detailLine = parts.join(' | ');
  const effectText = String(info?.desc || '').replace(/<[^>]+>/g, '').trim();
  const lines = [];
  if (detailLine) lines.push(detailLine);
  if (effectText) lines.push(`Effect: ${effectText}`);
  if (info?.effectsDesc) lines.push(`Effects: ${info.effectsDesc}`);
  openRollModal({
    title: titleText,
    subtitle: 'Spell',
    baseLabel: 'Base value',
    base: 0,
    detailsText: detailLine,
    descHtml: info?.desc || '',
    detailLines: lines,
    infoOnly: true
  });
}

function openCombatSpellRoll(sp, meta, info){
  const titleText = info?.nameDisplay || meta?.alt_name || sp?.name || 'Spell';
  const rangeText = info?.range ? (String(info.range).toLowerCase().startsWith('range:') ? info.range : `Range: ${info.range}`) : '';
  const aoeText = info?.aoe ? (String(info.aoe).toLowerCase().startsWith('aoe:') ? info.aoe : `AoE: ${info.aoe}`) : '';
  const activationRaw = sp?.activation || sp?.cast_time || '';
  const activationText = activationRaw ? (String(activationRaw).toLowerCase().startsWith('activation:') ? activationRaw : `Activation: ${activationRaw}`) : '';
  const parts = ['Type: Active'];
  if (info?.cost) parts.push(`Cost: ${info.cost}`);
  if (rangeText) parts.push(rangeText);
  if (aoeText) parts.push(aoeText);
  if (activationText) parts.push(activationText);
  const detailLine = parts.join(' | ');
  const effectText = String(info?.desc || '').replace(/<[^>]+>/g, '').trim();
  const lines = [];
  if (detailLine) lines.push(detailLine);
  if (effectText) lines.push(`Effect: ${effectText}`);
  if (info?.effectsDesc) lines.push(`Effects: ${info.effectsDesc}`);
  openRollModal({
    title: titleText,
    subtitle: 'Spell',
    baseLabel: 'Base value',
    base: 0,
    detailsText: detailLine,
    descHtml: info?.desc || '',
    logDescHtml: info?.desc || '',
    detailLines: lines,
    infoOnly: false
  });
}

function wireRollModal(){
  rollClose?.addEventListener('click', closeRollModal);
  rollCancel?.addEventListener('click', closeRollModal);
  rollBackdrop?.addEventListener('click', (e)=>{ if (e.target === rollBackdrop) closeRollModal(); });
  rollRun?.addEventListener('click', runRoll);
  rollLogClear?.addEventListener('click', clearRollLog);
}

  function itemChoiceMods(it){
    const mods = [];
    (it.modifiers || []).forEach(m=>{
      if (String(m.target||'').startsWith('choice:')) mods.push({ ...m, __source:'Item' });
    });
    return mods;
  }
  function resolveUpgradeModifiers(u, meta){
  const holder = (Array.isArray(u?.holder_modifiers) && u.holder_modifiers.length) ? u.holder_modifiers : [];
  if (holder.length) return holder;
  const mods = Array.isArray(u?.modifiers) ? u.modifiers : [];
  if (mods.length) return mods;
  const metaHolder = (Array.isArray(meta?.holder_modifiers) && meta.holder_modifiers.length) ? meta.holder_modifiers : [];
  if (metaHolder.length) return metaHolder;
  return Array.isArray(meta?.modifiers) ? meta.modifiers : [];
}
  function upgradeChoiceMods(u, meta, choiceKey){
    const name = meta?.name || u?.name || u?.id || 'Upgrade';
    const mods = resolveUpgradeModifiers(u, meta);
    return (mods || []).filter(m=> String(m.target||'').startsWith('choice:')).map(m=> ({
      ...m,
      __source:`Upgrade: ${name}`,
      __choice_key: choiceKey || ''
    }));
  }
function itemHasChoice(it){
  return itemChoiceMods(it).length > 0;
}
function itemChoiceKey(it){
    const key = String(it?.item_id || it?.id || '').trim();
    if (key) return key;
    const name = String(it?.name || '').trim();
    return name || '';
  }
  function upgradeChoiceKeyLegacy(it, upgrade, idx){
    const itemKey = itemChoiceKey(it);
    if (!itemKey) return '';
    const upgId = String(upgrade?.id || upgrade?.key || upgrade || '').trim() || 'upgrade';
    const target = String(upgrade?.target || '').trim() || 'any';
    const pos = Number.isFinite(idx) ? idx : 0;
    return `${itemKey}::upg:${upgId}:${target}:${pos}`;
  }
  function upgradeChoiceKey(it, upgrade, idx){
    const itemKey = itemChoiceKey(it);
    if (!itemKey) return '';
    const choiceId = String(upgrade?.choice_id || upgrade?.choiceId || upgrade?.uid || '').trim();
    if (choiceId) return `${itemKey}::upg:${choiceId}`;
    return upgradeChoiceKeyLegacy(it, upgrade, idx);
  }
  function migrateUpgradeChoiceKeys(items){
    let changed = false;
    (items || []).forEach(it=>{
      (it.upgrades || []).forEach((u, idx)=>{
        const legacyKey = upgradeChoiceKeyLegacy(it, u, idx);
        const newKey = upgradeChoiceKey(it, u, idx);
        if (!legacyKey || !newKey || legacyKey === newKey) return;
        if (ITEM_CHOICES[legacyKey] && !ITEM_CHOICES[newKey]){
          ITEM_CHOICES[newKey] = ITEM_CHOICES[legacyKey];
          changed = true;
        }
        if (ITEM_CHOICES[legacyKey]){
          delete ITEM_CHOICES[legacyKey];
          changed = true;
        }
      });
    });
    return changed;
  }
  function pruneItemChoices(){
    if (!LINKED_INV) return;
    const ids = new Set();
    (LINKED_INV.items || []).forEach(it=>{
      const baseKey = itemChoiceKey(it);
      if (baseKey) ids.add(baseKey);
      (it.upgrades || []).forEach((u, idx)=>{
        ids.add(upgradeChoiceKey(it, u, idx));
      });
    });
  Object.keys(ITEM_CHOICES).forEach(id=>{ if (!ids.has(String(id))) delete ITEM_CHOICES[id]; });
  }

function craftomancyMax(){
  return Math.max(0, Math.floor(numOr(DERIVED_CACHE?.craftomancy_max, 0)));
}
function collectFocusedCraftomancies(){
  const list = [];
  (LINKED_INV?.items || []).forEach(it=>{
    (it.craftomancies || []).forEach(cm=>{
      if (!cm || !cm.focused) return;
      list.push({ item: it, craft: cm });
    });
  });
  return list;
}
function craftomancyFocusUsed(){
  return collectFocusedCraftomancies().reduce((sum, entry)=>{
    const cost = Number(entry.craft?.focus_cost) || (entry.craft?.is_complex ? 3 : 1);
    return sum + cost;
  }, 0);
}
function updateCraftomancyCounter(){
  const el = document.getElementById('craftomancy-counter');
  if (!el) return;
  const used = craftomancyFocusUsed();
  const max = craftomancyMax();
  el.textContent = `Craftomancy Focus: ${used} / ${max}`;
  el.style.color = used > max ? '#f66' : '';
}

function craftInfoForSpell(sp, quality, supreme){
  const row = craftRowForQuality(quality);
  const baseCat = sp?.category || 'Novice';
  const allowedIdx = craftCategoryIndex(row.category);
  const catIdx = craftCategoryIndex(baseCat);
  const allowed = (catIdx >= 0 && allowedIdx >= 0 && catIdx <= allowedIdx);
  const effectiveCategory = (supreme ? (craftNextCategory(baseCat) || baseCat) : baseCat);
  const complex = craftSpellIsComplex(sp);
  const price = row.price * (complex ? 2 : 1);
  const hours = row.hours * (complex ? 2 : 1);
  const focusCost = complex ? 3 : 1;
  return {
    allowed,
    baseCat,
    effectiveCategory,
    allowedCat: row.category,
    skill: row.skill,
    dc: row.dc,
    die: row.die,
    price,
    hours,
    complex,
    focusCost
  };
}

function openCraftomancyModal(it){
  if (!craftAddModal || !craftAddBackdrop) return;
  CRAFT_TARGET_ITEM = it;
  CRAFT_SEARCH_RESULTS = [];
  craftSearchQ.value = '';
  craftAddStatus.textContent = '';
  if (craftSupremeEl) craftSupremeEl.checked = false;
  if (craftAddTitle) craftAddTitle.textContent = `Add Craftomancy - ${it?.alt_name || it?.name || 'Item'}`;
  const quality = it?.quality || 'Adequate';
  const row = craftRowForQuality(quality);
  const count = (it?.craftomancies || []).length;
  const warn = count >= 1 ? 'Second craftomancy requires advanced Craftomancer.' : '';
  craftAddInfo.textContent = `Quality: ${quality} | Max category: ${row.category} | Skill ${row.skill} (DC ${row.dc}, ID ${row.die}) | Base price ${row.price} Jelly | Time ${row.hours}h. ${warn}`;
  craftSearchBody.innerHTML = '<tr><td colspan="4" class="empty">Use search to list approved spells.</td></tr>';
  craftAddModal.classList.remove('hidden');
  craftAddModal.classList.add('open');
  craftAddBackdrop.classList.add('open');
}

function closeCraftomancyModal(){
  if (!craftAddModal || !craftAddBackdrop) return;
  CRAFT_TARGET_ITEM = null;
  craftAddModal.classList.add('hidden');
  craftAddModal.classList.remove('open');
  craftAddBackdrop.classList.remove('open');
}

async function searchCraftomancySpells(){
  if (!CRAFT_TARGET_ITEM) return;
  const q = (craftSearchQ.value || '').trim();
  craftAddStatus.textContent = '';
  craftSearchBody.innerHTML = '<tr><td colspan="4" class="empty">Searching...</td></tr>';
  try{
    if (!SCHOOLS.length) await fetchSchools();
  }catch{}
  try{
    const qs = q ? `?name=${encodeURIComponent(q)}&status=green&limit=200` : `?status=green&limit=200`;
    const res = await fetch(`/spells${qs}`);
    const data = await res.json().catch(()=>({}));
    const spells = data.spells || [];
    CRAFT_SEARCH_RESULTS = spells;
    renderCraftSearchResults();
  }catch(e){
    craftSearchBody.innerHTML = `<tr><td colspan="4" class="empty">Error: ${e.message}</td></tr>`;
  }
}

function renderCraftSearchResults(){
  if (!CRAFT_TARGET_ITEM) return;
  const spells = CRAFT_SEARCH_RESULTS || [];
  const supreme = !!craftSupremeEl?.checked;
  const quality = CRAFT_TARGET_ITEM.quality || 'Adequate';
  if (!spells.length){
    craftSearchBody.innerHTML = '<tr><td colspan="4" class="empty">No results.</td></tr>';
    return;
  }
  craftSearchBody.innerHTML = '';
  spells.forEach(sp=>{
    const info = craftInfoForSpell(sp, quality, supreme);
    const schools = (sp.schools || []).map(s=>s.name||s.id).join(', ');
    const tr = document.createElement('tr');
    const costTxt = info.allowed
      ? `${info.price} Jelly | ${info.hours}h | DC ${info.dc} | Skill ${info.skill} (${info.die})${info.complex ? ' | complex x2' : ''}`
      : `Requires ${info.allowedCat} or lower`;
    const catTxt = info.effectiveCategory ? `${info.baseCat}${info.effectiveCategory !== info.baseCat ? ` -> ${info.effectiveCategory}` : ''}` : info.baseCat;
    tr.innerHTML = `
      <td>${invEscapeHtml(sp.name || 'Spell')}<div class="muted">Schools: ${invEscapeHtml(schools || '-')}</div></td>
      <td>${invEscapeHtml(catTxt)}</td>
      <td>${invEscapeHtml(costTxt)}</td>
      <td><button class="btn small" ${info.allowed ? '' : 'disabled'}>Add</button></td>
    `;
    tr.querySelector('button')?.addEventListener('click', ()=> addCraftomancyFromSpell(sp));
    craftSearchBody.appendChild(tr);
  });
}

async function addCraftomancyFromSpell(sp){
  if (!CRAFT_TARGET_ITEM) return;
  const crafts = CRAFT_TARGET_ITEM.craftomancies || [];
  if (crafts.length >= 2){
    craftAddStatus.textContent = 'This item already has 2 craftomancies.';
    return;
  }
  const supreme = !!craftSupremeEl?.checked;
  const quality = CRAFT_TARGET_ITEM.quality || 'Adequate';
  const info = craftInfoForSpell(sp, quality, supreme);
  if (!info.allowed){
    craftAddStatus.textContent = `Spell exceeds quality limit (${info.allowedCat}).`;
    return;
  }
  const note = `Add craftomancy ${sp.name || sp.id} for ${info.price} Jelly (${info.hours}h, DC ${info.dc}, Skill ${info.skill})?`;
  if (!confirm(note)) return;
  try{
    craftAddStatus.textContent = 'Adding craftomancy...';
    const currency = invGlobalCurEl?.value || 'Jelly';
    const r = await fetch(`/inventories/${encodeURIComponent(getInventorySourceId())}/items/${encodeURIComponent(CRAFT_TARGET_ITEM.item_id)}/craftomancy`, {
      method:'POST',
      headers:{ 'Content-Type':'application/json', ...authHeaders() },
      body: JSON.stringify({ spell_id: sp.id, supreme, currency })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== 'success') throw new Error(j.message || 'Add failed');
    if (j.warning) alert(j.warning);
    LINKED_INV = j.inventory;
    renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
    renderAbilitySpellsBucket();
    closeCraftomancyModal();
  }catch(e){
    craftAddStatus.textContent = `Failed: ${e.message}`;
  }
}

async function setCraftomancyFocus(it, cm, focused){
  const sourceId = getInventorySourceId();
  if (!sourceId) return;
  try{
    const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(it.item_id)}/craftomancy/${encodeURIComponent(cm.id)}`, {
      method:'PATCH',
      headers:{ 'Content-Type':'application/json', ...authHeaders() },
      body: JSON.stringify({ focused })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== 'success') throw new Error(j.message || 'Update failed');
    LINKED_INV = j.inventory;
    renderAbilitySpellsBucket();
    updateCraftomancyCounter();
  }catch(e){
    alert(e.message);
  }
}

async function removeCraftomancy(it, cm){
  const sourceId = getInventorySourceId();
  if (!sourceId) return;
  if (!confirm(`Remove craftomancy ${cm.spell_name || cm.spell_id}? Cost: 500 Jelly.`)) return;
  try{
    const currency = invGlobalCurEl?.value || 'Jelly';
    const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(it.item_id)}/craftomancy/${encodeURIComponent(cm.id)}/remove`, {
      method:'POST',
      headers:{ 'Content-Type':'application/json', ...authHeaders() },
      body: JSON.stringify({ currency })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== 'success') throw new Error(j.message || 'Remove failed');
    LINKED_INV = j.inventory;
    renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
    renderAbilitySpellsBucket();
  }catch(e){
    alert(e.message);
  }
}

async function invAddContainer(){
  const name = (invNewContNameEl.value || "Container").trim();
  const sourceId = getInventorySourceId();
  if (!sourceId) return;
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/containers`, {
    method: "POST",
    headers: { "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ name })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Create failed"); return; }
  invNewContNameEl.value = "";
  LINKED_INV = j.inventory;
  renderInventoryUI();
  recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function invAddFunds(){
  const currency = invFundCurEl.value || "Jelly";
  const amountRaw = parseInt(invFundAmtEl.value || "0", 10);
  const note = (invFundNoteEl.value || (amountRaw >= 0 ? "Top up" : "Withdrawal")).trim();
  if (!amountRaw){ invFundStatus.textContent = "Enter a non-zero amount."; return; }
  const sourceId = getInventorySourceId();
  if (!sourceId){ invFundStatus.textContent = "Link an inventory first."; return; }
  invFundStatus.textContent = "Saving transaction...";
  try{
    const path = `/inventories/${encodeURIComponent(sourceId)}/deposit`;
    const r = await fetch(path, {
      method:"POST",
      headers:{ "Content-Type":"application/json", ...authHeaders() },
      body: JSON.stringify({ currency, amount: amountRaw, note })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success") throw new Error(j.message || "Update failed");
    invFundAmtEl.value = ""; invFundNoteEl.value = "";
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
    invFundStatus.textContent = "Saved.";
    invToggleModal(invFundModal, invFundBackdrop, false);
  }catch(e){
    invFundStatus.textContent = "Failed: " + e.message;
  }
}

function invGetRowCategory(r){
  if (r.kind === "weapon" || r.__kind === "weapon") return "weapon";
  if (r.kind === "equipment" || r.__kind === "equipment") return r.category ? `equipment:${r.category}` : "equipment";
  if (r.kind === "tool" || r.__kind === "tool") return "tool";
  return "object";
}

async function invFetchCatalog(kind, q, limit, tags){
  const url = kind === "weapon" ? "/catalog/weapons"
            : kind === "equipment" ? "/catalog/equipment"
            : kind === "tool" ? "/catalog/tools"
            : "/catalog/objects";
  const params = new URLSearchParams();
  if (q) params.set("q", q);
  if (tags) params.set("tags", tags);
  if (limit) params.set("limit", limit);
  const r = await fetch(`${url}?${params.toString()}`, { headers: authHeaders() });
  const j = await r.json();
  const key = Object.keys(j).find(k=>Array.isArray(j[k]));
  const rows = key ? j[key] : [];
  return rows.map(x=>({ ...x, __kind: kind }));
}

function invBuildCategoryOptions(rows){
  const cats = ["__all", ...new Set(rows.map(invGetRowCategory))];
  invCatEl.innerHTML = '';
  cats.forEach(c=>{
    const o=document.createElement('option'); o.value=c; o.textContent = c==="__all" ? "All" : c; invCatEl.appendChild(o);
  });
}

function invRenderResults(){
    const list = invResultsEl;
    list.innerHTML = '';
    if (!INV_FILTERED.length){
      list.innerHTML = '<div class="muted">No results.</div>';
      return;
    }
    const container = invGlobalContEl.value;
    const currency  = invGlobalCurEl.value || "Jelly";
  INV_FILTERED.forEach(r=>{
    const line = document.createElement("div");
    line.className = "row";
    line.style.borderBottom = "1px solid #222";
    line.style.padding = "6px 0";
      const cat = invGetRowCategory(r);
      const price = (r.price != null) ? `Price: ${r.price}` : "";
      const enc = (r.enc != null) ? `Enc: ${Number(r.enc||0).toFixed(1)}` : "";
      line.innerHTML = `
        <div style="flex:1;min-width:260px;">
          <div><b>${invEscapeHtml(r.name || r.title || "Item")}</b></div>
          <div class="muted">${invEscapeHtml(cat)} ${price ? " - "+price : ""} ${enc ? " - "+enc : ""}</div>
        </div>
        <input type="number" min="1" value="1" style="width:90px" class="qty">
        <button class="btn small buy">Add</button>
      `;
      line.querySelector(".buy").addEventListener("click", async ()=>{
        const qty = Math.max(1, parseInt(line.querySelector(".qty").value||"1", 10));
      const choice = await invPromptPricingChoice(r);
      if (!choice) return;
      await invBuyItem(r.__kind || "object", r.id, qty, container, currency, choice);
    });
    list.appendChild(line);
  });
}

function invParseCustomPriceInput(inputStr){
  if (inputStr == null) return null;
  const raw = String(inputStr).trim();
  if (!raw) return null;
  const percentMark = raw.startsWith('%') || raw.endsWith('%');
  const numeric = raw.replace('%','');
  const num = Number(numeric);
  if (!Number.isFinite(num) || num < 0) return null;
  if (percentMark){
    return { priceModifier: num / 100 };
  }
  return { customPrice: num };
}

async function invPromptPricingChoice(row){
  return await new Promise(resolve=>{
    const basePrice = row?.price != null ? Number(row.price) : 0;
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:4000; display:grid; place-items:center; padding:12px;';
    const card = document.createElement('div');
    card.className = 'price-choice-card';
    card.style.cssText = 'background:#11121b; border:1px solid #2a2a3a; border-radius:12px; padding:14px; box-shadow:0 12px 40px rgba(0,0,0,0.45); color:#f3f3f5; font-family:inherit;';
    card.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:8px; margin-bottom:10px;">
        <div style="min-width:0;">
          <div class="price-choice-title">${invEscapeHtml(row?.name || row?.title || 'Item')}</div>
          <div class="muted" style="font-size:0.9rem;">Base price: ${basePrice || 0}</div>
        </div>
        <button id="price-close" class="btn small" style="background:#222635; border-color:#2f3548;">?</button>
      </div>
      <div class="price-choice-grid">
        <label class="price-choice-option">
          <input type="radio" name="price-mode" value="market" checked> <span>Buy at market price</span>
        </label>
        <label class="price-choice-option">
          <input type="radio" name="price-mode" value="custom"> <span>Custom</span>
        </label>
        <label class="price-choice-option">
          <input type="radio" name="price-mode" value="take"> <span>Take (price 0)</span>
        </label>
        <div class="price-choice-actions">
          <button id="price-cancel" class="btn small btn-secondary">Cancel</button>
          <button id="price-apply" class="btn small">Apply</button>
        </div>
      </div>
    `;
    overlay.appendChild(card);
    document.body.appendChild(overlay);

    const cleanup = (val)=>{ overlay.remove(); resolve(val); };
    card.querySelector('#price-close').addEventListener('click', ()=>cleanup(null));
    card.querySelector('#price-cancel').addEventListener('click', ()=>cleanup(null));
    overlay.addEventListener('click', (e)=>{ if (e.target === overlay) cleanup(null); });

    const applyBtn = card.querySelector('#price-apply');
    applyBtn.addEventListener('click', ()=>{
      const mode = card.querySelector('input[name="price-mode"]:checked')?.value || 'market';
      if (mode === 'take'){ cleanup({ pricingMode:'take', customPrice:0 }); return; }
      if (mode === 'market'){ cleanup({ pricingMode:'market' }); return; }
      openCustomPriceModal(basePrice).then(choice=>{
        if (!choice) return;
        cleanup({ pricingMode:'custom', ...choice });
      });
    });
  });
}

function openCustomPriceModal(basePrice){
  return new Promise(resolve=>{
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:4001; display:grid; place-items:center; padding:12px;';
    const card = document.createElement('div');
    card.className = 'price-choice-card';
    card.style.cssText = 'background:#11121b; border:1px solid #2a2a3a; border-radius:12px; padding:14px; box-shadow:0 12px 40px rgba(0,0,0,0.45); color:#f3f3f5; font-family:inherit;';
    card.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:8px; margin-bottom:10px;">
        <div style="min-width:0;">
          <div class="price-choice-title">Custom price</div>
          <div class="muted" style="font-size:0.9rem;">Base price: ${basePrice || 0}</div>
        </div>
        <button id="custom-close" class="btn small" style="background:#222635; border-color:#2f3548;">?</button>
      </div>
      <div class="price-choice-grid">
        <div class="price-choice-custom">
          <div class="price-choice-field">
            <span class="muted" style="min-width:80px;">% modifier</span>
            <input id="price-mod-input" type="number" step="1" min="0" style="flex:1; min-width:0; padding:8px; border-radius:8px; border:1px solid #2d3042; background:#181b2a; color:#f3f3f5;" value="${Math.round(((parseFloat(invPriceModEl?.value || '1') || 1) * 100))}">
          </div>
          <div class="price-choice-field">
            <span class="muted" style="min-width:80px;">Exact price</span>
            <input id="price-exact-input" type="number" step="1" min="0" style="flex:1; min-width:0; padding:8px; border-radius:8px; border:1px solid #2d3042; background:#181b2a; color:#f3f3f5;" placeholder="${basePrice || 0}">
          </div>
          <div class="muted" style="grid-column:1/-1; font-size:0.9rem;">Tip: fill either % modifier or exact price. Leave both blank to cancel.</div>
        </div>
        <div class="price-choice-actions">
          <button id="custom-cancel" class="btn small btn-secondary">Cancel</button>
          <button id="custom-apply" class="btn small">Apply</button>
        </div>
      </div>
    `;
    overlay.appendChild(card);
    document.body.appendChild(overlay);

    const cleanup = (val)=>{ overlay.remove(); resolve(val); };
    card.querySelector('#custom-close').addEventListener('click', ()=>cleanup(null));
    card.querySelector('#custom-cancel').addEventListener('click', ()=>cleanup(null));
    overlay.addEventListener('click', (e)=>{ if (e.target === overlay) cleanup(null); });
    card.querySelector('#custom-apply').addEventListener('click', ()=>{
      const pctRaw = card.querySelector('#price-mod-input').value;
      const priceRaw = card.querySelector('#price-exact-input').value;
      const parsedPct = pctRaw ? invParseCustomPriceInput(`%${pctRaw}`) : null;
      const parsedPrice = priceRaw ? invParseCustomPriceInput(priceRaw) : null;
      const choice = parsedPrice || parsedPct;
      if (!choice){
        alert('Enter a % modifier or an exact price for custom mode.');
        return;
      }
      cleanup(choice);
    });
  });
}


  async function invDoSearch(){
    const q = (invQEl.value || "").trim();
    const tags = (invTagEl?.value || "").trim();
    const kind = invKindEl.value;
    const limit = parseInt(invLimitEl.value || "50", 10);
    INV_LAST_RESULTS = await invFetchCatalog(kind, q, limit, tags);
  INV_FILTERED = INV_LAST_RESULTS.slice();
  invBuildCategoryOptions(INV_LAST_RESULTS);
  invRenderResults();
}

function invClearSearch(){
  invQEl.value = "";
  if (invTagEl) invTagEl.value = "";
  INV_LAST_RESULTS = [];
  INV_FILTERED = [];
  invBuildCategoryOptions([]);
  invRenderResults();
}

async function invBuyItem(kind, ref_id, quantity, container_id, currency, opts = {}){
    const equipFlag = invEquippedFlagEl.value === "1";
    const sourceId = getInventorySourceId();
    if (!sourceId){ alert("Link an inventory first."); return; }
    if (!equipFlag && container_id === SELF_CONTAINER_ID){
      const firstNonSelf = Array.from(invGlobalContEl.options || []).map(o=>o.value).find(v=>v !== SELF_CONTAINER_ID);
      container_id = firstNonSelf || "";
    }
    const pricingMode = opts.pricingMode || 'market';
    const priceModifier = (opts.priceModifier != null) ? opts.priceModifier : (parseFloat(invPriceModEl?.value || "1") || 1);
    const customPrice = opts.customPrice;
    const payload = { kind, ref_id, quantity, container_id, currency, equipped: equipFlag, pricing_mode: pricingMode };
    if (pricingMode === 'custom'){
      if (priceModifier != null) payload.price_modifier = priceModifier;
      if (customPrice != null) payload.custom_price = customPrice;
    } else if (pricingMode === 'take') {
      payload.custom_price = 0;
    }
    const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/purchase`, {
      method: "POST",
      headers: { "Content-Type":"application/json", ...authHeaders() },
      body: JSON.stringify(payload)
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success") { alert(j.message || "Purchase failed"); return; }
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
    invToggleModal(invCatalogModal, invCatalogBackdrop, false);
  }

async function saveInvAltName(item_id, alt_name){
  const sourceId = getInventorySourceId();
  if (!sourceId) throw new Error("Link an inventory first.");
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(item_id)}`, {
    method:"PATCH",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ alt_name })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ throw new Error(j.message || "Save failed"); }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
  return j.inventory;
}

async function saveInvLinkedNature(item_id, linked_nature){
  const sourceId = getInventorySourceId();
  if (!sourceId) throw new Error("Link an inventory first.");
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(item_id)}`, {
    method:"PATCH",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ linked_nature })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ throw new Error(j.message || "Save failed"); }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
  return j.inventory;
}

  async function upgradeQuality(item_id, to){
  const sourceId = getInventorySourceId();
  if (!sourceId) throw new Error("Link an inventory first.");
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(item_id)}/upgrade_quality`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ to })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ throw new Error(j.message || "Upgrade failed"); }
  return j.inventory;
}

async function installUpgrade(item_id, upgrade_id, targetOverride=""){
  const meta = (window.UPGRADE_META || {})[upgrade_id] || null;
  let target = targetOverride || "";
  if (!target && meta && Array.isArray(meta.targets) && meta.targets.length){
    const counts = {};
    const current = (LINKED_INV?.items || []).find(i=>i.item_id===item_id);
    const existing = current?.upgrades || [];
    existing.forEach(u=>{ if(u.target){ counts[u.target]=(counts[u.target]||0)+1; } });
    const options = meta.targets.map(t=>`${t} (${counts[t]||0}/2)`).join(", ");
    const choice = prompt(`Select target for ${meta.name || "upgrade"} [${options}]`, meta.targets[0]);
    if (!choice) return null;
    if (!meta.targets.includes(choice)){
      alert("Invalid target."); return null;
    }
    if ((counts[choice]||0) >= 2){
      alert("Target already has two upgrades."); return null;
    }
    target = choice;
  }
  const sourceId = getInventorySourceId();
  if (!sourceId) throw new Error("Link an inventory first.");
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(item_id)}/install_upgrade`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ upgrade_id, target })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ throw new Error(j.message || "Install failed"); }
  return j.inventory;
}

async function removeUpgrade(item_id, upgrade_id, target=""){
  const sourceId = getInventorySourceId();
  if (!sourceId) throw new Error("Link an inventory first.");
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(item_id)}/remove_upgrade`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ upgrade_id, target })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ throw new Error(j.message || "Remove failed"); }
  return j.inventory;
}

  async function fetchUpgrades(kind, slot){
  const qs = [];
  if (kind) qs.push(`kind=${encodeURIComponent(kind)}`);
  if (slot) qs.push(`slot=${encodeURIComponent(slot)}`);
  const url = `/upgrades${qs.length ? '?'+qs.join('&') : ''}`;
  const r = await fetch(url, { headers: { ...authHeaders() } });
  const j = await r.json();
  if (j.status !== "success") throw new Error(j.message || "Load upgrades failed");
  const ups = j.upgrades || [];
  ups.forEach(u=>{ UPGRADE_META[u.id] = u; });
    return ups;
  }

  async function downgradeQuality(item_id, to){
    const sourceId = getInventorySourceId();
    if (!sourceId) throw new Error("Link an inventory first.");
    const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(item_id)}/downgrade_quality`, {
      method: "POST",
      headers: { "Content-Type": "application/json", ...authHeaders() },
      body: JSON.stringify({ to })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success"){ throw new Error(j.message || "Downgrade failed"); }
    return j.inventory;
  }

function normalizeItemKind(it){
  return String(it?.kind || it?.__kind || it?.type || '').trim().toLowerCase();
}
function normalizeItemSlot(it){
  return String(it?.equipment_slot || it?.slot || '').trim().toLowerCase();
}
function upgradeMatchesItem(upg, it){
  const itemKind = normalizeItemKind(it);
  if (itemKind){
    const kinds = [
      ...(Array.isArray(upg?.item_types) ? upg.item_types : []),
      upg?.kind
    ].map(k=> String(k || '').trim().toLowerCase()).filter(Boolean);
    if (kinds.length && !kinds.includes(itemKind)) return false;
    if (!kinds.length && upg?.kind && String(upg.kind).toLowerCase() !== itemKind) return false;
  }
  if (itemKind === 'equipment'){
    const itemSlot = normalizeItemSlot(it);
    const slotReq = String(upg?.slot || '').trim().toLowerCase();
    const slots = (Array.isArray(upg?.slots) ? upg.slots : []).map(s=> String(s || '').trim().toLowerCase()).filter(Boolean);
    if (slotReq && (!itemSlot || slotReq !== itemSlot)) return false;
    if (slots.length){
      if (!itemSlot) return false;
      if (!slots.includes(itemSlot)) return false;
    }
  }
  return true;
}

async function loadUpgradeOptions(labelEl, selectEl, it){
  if (!labelEl || !selectEl) return;
  labelEl.textContent = "Install upgrade (loading...)";
  selectEl.innerHTML = "";
  try{
    const kind = normalizeItemKind(it);
    const ups = await fetchUpgrades(kind, "");
    const filtered = ups.filter(u=> upgradeMatchesItem(u, it));
    if (!filtered.length){
      labelEl.textContent = "Install upgrade (none available)";
      const o = document.createElement("option"); o.textContent = "-- none --"; selectEl.appendChild(o);
      return;
    }
    labelEl.textContent = "Install upgrade";
    selectEl.innerHTML = '<option value=\"\">-- select upgrade --</option>';
    filtered.forEach(u=>{
      const o = document.createElement("option");
      o.value = u.id;
      const ttxt = (u.targets && u.targets.length) ? ` - target: ${u.targets.join("/")}` : "";
      const excl = u.exclusive_group ? ` - excl:${u.exclusive_group}` : "";
      o.textContent = `${u.name}${u.slot ? ` (${u.slot})` : ""}${ttxt}${excl}`;
      selectEl.appendChild(o);
    });
  }catch(e){
    labelEl.textContent = "Install upgrade (load failed)";
    const o = document.createElement("option");
    o.textContent = "Error loading upgrades";
    selectEl.appendChild(o);
  }
}

async function toggleEquipInline(it){
  const sourceId = getInventorySourceId();
  if (!sourceId){ alert("Link an inventory first."); return; }
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(it.item_id)}`, {
    method:"PATCH",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ equipped: it.equipped === false })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Update failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

function alchemyTierFromPrice(price){
  const ladder = [ [10000,6],[2000,5],[1000,4],[200,3],[100,2],[50,1] ];
  let tier = 1;
  const p = Number(price||0);
  for (const [min, t] of ladder){
    if (p >= min){ tier = t; break; }
  }
  return tier;
}

async function sellItemInline(it, price){
  const currency = invGlobalCurEl?.value || "Jelly";
  const payload = { price, currency };
  const sourceId = getInventorySourceId();
  if (!sourceId){ alert("Link an inventory first."); return; }
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(it.item_id)}/sell`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify(payload)
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Sell failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function disposeItemInline(it){
  const currency = invGlobalCurEl?.value || "Jelly";
  const sourceId = getInventorySourceId();
  if (!sourceId){ alert("Link an inventory first."); return; }
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(it.item_id)}/dispose`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Dispose failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function useItemInline(it){
  const currency = invGlobalCurEl?.value || "Jelly";
  const sourceId = getInventorySourceId();
  if (!sourceId){ alert("Link an inventory first."); return; }
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(it.item_id)}/use`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Use failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function refillAlchemyInline(it){
  const currency = invGlobalCurEl?.value || "Jelly";
  const sourceId = getInventorySourceId();
  if (!sourceId){ alert("Link an inventory first."); return; }
  const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(it.item_id)}/refill_alchemy`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ currency })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Refill failed"); return; }
  LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
}

async function toggleContainerInclude(containerId, include){
  const sourceId = getInventorySourceId();
  if (!sourceId || !containerId) return;
  try{
    const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/containers/${encodeURIComponent(containerId)}`, {
      method:"PATCH",
      headers:{ "Content-Type":"application/json", ...authHeaders() },
      body: JSON.stringify({ include })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success") throw new Error(j.message || "Update failed");
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
  }catch(e){
    alert(e.message);
    renderInventoryUI();
  }
}

async function moveItemToContainer(it, containerId){
  const sourceId = getInventorySourceId();
  if (!sourceId || !containerId) return;
  if (it.equipped===false && containerId === SELF_CONTAINER_ID){
    alert('Only equipped items can be on Self.');
    return;
  }
  try{
    const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/items/${encodeURIComponent(it.item_id)}`, {
      method:"PATCH",
      headers:{ "Content-Type":"application/json", ...authHeaders() },
      body: JSON.stringify({ container_id: containerId })
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success"){ throw new Error(j.message || "Move failed"); }
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
  }catch(e){
    alert(e.message);
  }
}

async function deleteContainer(containerId){
  const sourceId = getInventorySourceId();
  if (!sourceId || !containerId) return;
  if (!confirm('Delete this container? Items will be moved to another container.')) return;
  try{
    const r = await fetch(`/inventories/${encodeURIComponent(sourceId)}/containers/${encodeURIComponent(containerId)}`, {
      method:"DELETE",
      headers:{ ...authHeaders() }
    });
    const j = await r.json().catch(()=>({}));
    if (j.status !== "success"){ throw new Error(j.message || "Delete failed"); }
    LINKED_INV = j.inventory; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
  }catch(e){
    alert(e.message);
  }
}

function openInvItemModal(it){
  const equipped = it.equipped !== false;
  const qty = Number(it.quantity || 1);
  const encUnit = Number(it.enc || 0);
  const encTotal = encUnit * qty;
  const paidUnit = Number(it.paid_unit ?? it.base_price ?? 0) || 0;
  const totalPaid = paidUnit * qty;
  const titleText = it.alt_name ? `${it.alt_name} (${it.name || 'Item'})` : (it.name || 'Item');
  invItemTitle.textContent = titleText;
  invItemBody.innerHTML = "";
  invItemActions.innerHTML = "";
  const hasChoice = itemHasChoice(it);

  const nameRow = document.createElement("div");
  nameRow.className = "row";
  nameRow.style.gap = "6px";
  const nameInput = document.createElement("input");
  nameInput.placeholder = "Display name (sets alt name)";
  nameInput.value = it.alt_name || it.name || "";
  nameInput.style.flex = "1";
  const commitName = debounce(async ()=>{
    try{ await saveInvAltName(it.item_id, nameInput.value || ""); }catch(e){ console.warn(e); }
  }, 500);
  nameInput.addEventListener("input", commitName);
  nameInput.addEventListener("blur", ()=>commitName());
  nameRow.appendChild(nameInput);
  invItemBody.appendChild(nameRow);

  const info = document.createElement("div");
  info.className = "info-grid";
  const totalPrice = Number.isFinite(totalPaid) ? totalPaid : 0;
  const cells = [
    { label: "Type", value: it.kind || "object" },
    { label: "Quality", value: it.quality || "X" },
    { label: "Enc (unit)", value: encUnit.toFixed(1) },
    { label: "Enc (total)", value: encTotal.toFixed(1) },
    { label: "Quantity", value: qty },
    { label: "Total price", value: totalPrice.toFixed(0) }
  ];
  cells.forEach(c=>{
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.innerHTML = `<div class="label">${invEscapeHtml(c.label)}</div><div><strong>${invEscapeHtml(c.value)}</strong></div>`;
    info.appendChild(cell);
  });
  invItemBody.appendChild(info);

  const itemKind = normalizeItemKind(it);
  const canLinkNature = itemKind === 'weapon' && (weaponIsAnimarma(it) || weaponHasBenedictionUpgrade(it));
  if (canLinkNature){
    const natureRow = document.createElement("div");
    natureRow.className = "row";
    natureRow.style.gap = "8px";
    const label = document.createElement("label");
    label.className = "muted";
    label.textContent = "Linked nature";
    const select = document.createElement("select");
    select.innerHTML = ['<option value="">-- None --</option>']
      .concat(NATURES.map(n=>`<option value="${n}">${n}</option>`))
      .join('');
    select.value = weaponLinkedNature(it) || '';
    select.addEventListener("change", async ()=>{
      try{ await saveInvLinkedNature(it.item_id, select.value || ""); }catch(e){ console.warn(e); }
    });
    natureRow.appendChild(label);
    natureRow.appendChild(select);
    invItemBody.appendChild(natureRow);
  }

  const descText = (it.description || it.desc || it.description_html || '').toString().trim();
  if (descText){
    const desc = document.createElement("div");
    desc.className = "inv-desc-box";
    desc.innerHTML = descText;
    invItemBody.appendChild(desc);
  }

  const modLine = buildModifierSummary(it);
  if (modLine){
    const mods = document.createElement("div");
    mods.className = "muted";
    mods.textContent = `Applies: ${modLine}`;
    invItemBody.appendChild(mods);
  }

  const craftSection = document.createElement("div");
  craftSection.className = "home-card";
  const craftHead = document.createElement("div");
  craftHead.className = "row";
  craftHead.style.alignItems = "center";
  craftHead.style.gap = "10px";
  const craftCount = (it.craftomancies || []).length;
  craftHead.innerHTML = `<h3 style="margin:0;">Craftomancy</h3><span class="pill-soft">${craftCount} / 1</span>`;
  const craftAddBtn = document.createElement("button");
  craftAddBtn.className = "btn small";
  craftAddBtn.textContent = "Add craftomancy";
  if (!it.quality){
    craftAddBtn.disabled = true;
    craftAddBtn.title = "Item quality required.";
  }else if (craftCount >= 2){
    craftAddBtn.disabled = true;
    craftAddBtn.title = "Craftomancy limit reached.";
  }
  craftAddBtn.addEventListener("click", ()=> openCraftomancyModal(it));
  craftHead.appendChild(craftAddBtn);
  craftSection.appendChild(craftHead);
  if (craftCount >= 1){
    const warn = document.createElement("div");
    warn.className = "muted";
    warn.textContent = "Second craftomancy requires advanced Craftomancer.";
    craftSection.appendChild(warn);
  }

  const craftList = document.createElement("div");
  craftList.className = "upg-list";
  const crafts = it.craftomancies || [];
  if (!crafts.length){
    const empty = document.createElement("div");
    empty.className = "muted";
    empty.textContent = "No craftomancy installed.";
    craftList.appendChild(empty);
  }else{
    crafts.forEach(cm=>{
      const row = document.createElement("div");
      row.className = "upg-row";
      const cmName = cm.spell_name || cm.spell_id || "Spell";
      const catText = cm.effective_category || cm.spell_category || "";
      const metaLine = [
        cm.craft_skill != null ? `Skill ${cm.craft_skill}` : "",
        cm.craft_dc != null ? `DC ${cm.craft_dc}` : "",
        cm.craft_die ? `ID ${cm.craft_die}` : "",
        cm.craft_hours != null ? `${cm.craft_hours}h` : "",
        cm.craft_price != null ? `${cm.craft_price} Jelly` : ""
      ].filter(Boolean).join(" | ");
      row.innerHTML = `
        <div class="row" style="justify-content:space-between; align-items:center; gap:8px;">
          <label class="row" style="gap:6px; align-items:center;">
            <input type="checkbox" ${cm.focused ? "checked" : ""}>
            <strong>${invEscapeHtml(cmName)}</strong>
          </label>
          <span class="pill-soft">${invEscapeHtml(catText || "Category")}</span>
        </div>
        <div class="muted">${invEscapeHtml(metaLine || "Craft details")}${cm.is_complex ? " | Focus 3 slots" : " | Focus 1 slot"}</div>
        ${cm.supreme ? `<div class="muted">Supreme Enchantment applied.</div>` : ""}
      `;
      const checkbox = row.querySelector("input[type='checkbox']");
      checkbox?.addEventListener("change", ()=> setCraftomancyFocus(it, cm, checkbox.checked));
      const btnRow = document.createElement("div");
      btnRow.className = "btn-row";
      const rem = document.createElement("button");
      rem.className = "btn btn-secondary small";
      rem.textContent = "Remove";
      rem.addEventListener("click", async ()=>{ await removeCraftomancy(it, cm); closeInvItemModal(); });
      btnRow.appendChild(rem);
      row.appendChild(btnRow);
      craftList.appendChild(row);
    });
  }
  craftSection.appendChild(craftList);
  invItemBody.appendChild(craftSection);

  if (hasChoice){
    const choiceHint = document.createElement("div");
    choiceHint.className = "muted";
    choiceHint.textContent = "This item has configurable choices.";
    invItemBody.appendChild(choiceHint);
  }

  if (it.kind === "weapon" || it.kind === "equipment"){
    const upSection = document.createElement("div");
    upSection.className = "home-card";
    const capLabel = `${(it.upgrades || []).length} / ${slotsForQuality(it.quality) || 0}`;
    const upHead = document.createElement("div");
    upHead.className = "row";
    upHead.style.alignItems = "center";
    upHead.style.gap = "10px";
    upHead.innerHTML = `<h3 style="margin:0;">Upgrades</h3><span class="pill-soft">${capLabel}</span>`;
    upSection.appendChild(upHead);

    const installRow = document.createElement("div");
    installRow.className = "row";
    installRow.style.gap = "8px";
    const ulabel = document.createElement("label"); ulabel.className = "muted"; ulabel.textContent = "Install upgrade";
    const uselect = document.createElement("select"); uselect.id = "inv-up-select";
    uselect.innerHTML = '<option value="">-- select upgrade --</option>';
    const ubtn = document.createElement("button"); ubtn.className = "btn small"; ubtn.textContent = "Install";
    installRow.appendChild(ulabel); installRow.appendChild(uselect); installRow.appendChild(ubtn);
    upSection.appendChild(installRow);

    loadUpgradeOptions(ulabel, uselect, it);
    ubtn.addEventListener("click", async ()=>{
      const sel = uselect.value;
      if (!sel){ alert("Select an upgrade first."); return; }
      let target = "";
      const meta = (window.UPGRADE_META || {})[sel];
      if (meta && Array.isArray(meta.targets) && meta.targets.length){
        const choice = prompt(`Select target for ${meta.name || "upgrade"} (${meta.targets.join(", ")})`, meta.targets[0]);
        if (!choice || !meta.targets.includes(choice)){ alert("Invalid target."); return; }
        const existing = (it.upgrades || []).filter(u=>u.target===choice).length;
        if (existing >= 2){ alert("Target already has two upgrades."); return; }
        target = choice;
      }
      try{
        const inv = await installUpgrade(it.item_id, sel, target);
        if (inv){ LINKED_INV = inv; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave(); }
        closeInvItemModal();
      }catch(e){ alert(e.message); }
    });

    const upList = document.createElement("div");
    upList.className = "upg-list";
    const ups = it.upgrades || [];
    if (!ups.length){
      const empty = document.createElement("div");
      empty.className = "muted";
      empty.textContent = "No upgrades installed.";
      upList.appendChild(empty);
    }else{
        ups.forEach((u, idx)=>{
          const upgId = u.id || u.key || u;
          const meta = (window.UPGRADE_META || {})[upgId] || {};
          const title = meta.name || u.name || upgId || "Upgrade";
          const desc = u.description_html || u.description || meta.description_html || meta.description || "";

        const row = document.createElement("div");
        row.className = "upg-row";

        const head = document.createElement("div");
        head.className = "row";
        head.style.justifyContent = "space-between";
        head.style.alignItems = "center";
        head.innerHTML = `<h4 style="margin:0;">${invEscapeHtml(title)}</h4>${u.target ? `<span class="pill-soft">Target: ${invEscapeHtml(u.target)}</span>` : ""}`;
        row.appendChild(head);

        if (desc){
          const dd = document.createElement("div");
          dd.className = "muted";
          dd.innerHTML = desc;
          row.appendChild(dd);
        }

        const btns = document.createElement("div");
        btns.className = "btn-row";
        const rem = document.createElement("button");
        rem.className = "btn btn-secondary small";
        rem.textContent = "Remove";
        rem.addEventListener("click", async ()=>{
          try{
            const inv = await removeUpgrade(it.item_id, upgId, u.target || "");
            LINKED_INV = inv; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
            closeInvItemModal();
          }catch(e){ alert(e.message); }
        });
          const choiceKey = upgradeChoiceKey(it, u, idx);
          const choiceMods = upgradeChoiceMods(u, meta, choiceKey);
          btns.appendChild(rem);
          if (choiceMods.length){
            const edit = document.createElement("button");
            edit.className = "btn small";
            edit.textContent = "Configure";
            edit.title = "Configure upgrade choices";
            edit.addEventListener("click", ()=> openUpgradeChoiceModal(it, u, idx));
            btns.appendChild(edit);
          }
        row.appendChild(btns);
        upList.appendChild(row);
      });
    }

    upSection.appendChild(upList);
    invItemBody.appendChild(upSection);
  }

  const btnRow = document.createElement("div");
  btnRow.className = "btn-row";

  if (it.consumable){
    const useBtn = document.createElement("button");
    useBtn.className = "btn small";
    useBtn.textContent = "Use";
    if ((Number(it.quantity)||0) <= 0) useBtn.disabled = true;
    useBtn.addEventListener("click", async ()=>{
      await useItemInline(it);
      closeInvItemModal();
    });
    btnRow.appendChild(useBtn);
  }else{
    const equipBtn = document.createElement("button");
    equipBtn.className = "btn small";
    equipBtn.textContent = equipped ? "Unequip" : "Equip";
    equipBtn.addEventListener("click", async ()=>{
      await toggleEquipInline(it);
      closeInvItemModal();
    });
    btnRow.appendChild(equipBtn);
  }

  const moveWrap = document.createElement("div");
  moveWrap.className = "row";
  moveWrap.style.gap = "6px";
  const moveSel = document.createElement("select");
  const stowedId = it.stowed_container_id || (it.container_id !== SELF_CONTAINER_ID ? it.container_id : "");
  const allowed = (LINKED_INV?.containers || []).filter(cc=> it.equipped!==false ? true : cc.id !== SELF_CONTAINER_ID);
  allowed.forEach(cc=>{
    const o=document.createElement("option");
    o.value = cc.id;
    o.textContent = cc.name || cc.id;
    moveSel.appendChild(o);
  });
  if (stowedId){ moveSel.value = stowedId; }
  const moveBtn = document.createElement("button");
  moveBtn.className = "btn small";
  moveBtn.textContent = "Move";
  if (!moveSel.children.length){
    moveSel.disabled = true;
    moveBtn.disabled = true;
    moveBtn.title = "Add another container to move items.";
  }
  moveBtn.addEventListener("click", async ()=>{
    const dest = moveSel.value;
    if (!dest) return;
    await moveItemToContainer(it, dest);
    closeInvItemModal();
  });
  moveWrap.appendChild(moveSel);
  moveWrap.appendChild(moveBtn);
  btnRow.appendChild(moveWrap);

  const sellBtn = document.createElement("button");
  sellBtn.className = "btn small";
  sellBtn.textContent = "Sell";
  sellBtn.addEventListener("click", async ()=>{
    const fallback = Number(it.base_price ?? it.paid_unit ?? 0) || 0;
    const ask = prompt("Sell price per unit (blank to cancel)", fallback);
    if (ask === null) return;
    const price = Number(ask);
    if (!Number.isFinite(price) || price < 0){ alert("Enter a valid price"); return; }
    await sellItemInline(it, price);
    closeInvItemModal();
  });
  btnRow.appendChild(sellBtn);

  const disposeBtn = document.createElement("button");
  disposeBtn.className = "btn btn-secondary small";
  disposeBtn.textContent = "Dispose";
  disposeBtn.addEventListener("click", async ()=>{
    if (!confirm("Dispose this item? This removes it with no revenue.")) return;
    await disposeItemInline(it);
    closeInvItemModal();
  });
  btnRow.appendChild(disposeBtn);

  if (it.kind === "weapon" || it.kind === "equipment"){
    const qWrap = document.createElement("div");
    qWrap.className = "row";
    qWrap.style.gap = "6px";
    const qSelect = document.createElement("select");
    const currentQuality = String(it.quality || "Adequate");
    QUALITY_ORDER.forEach(q=>{
      const opt = document.createElement("option");
      opt.value = q;
      opt.textContent = q;
      qSelect.appendChild(opt);
    });
    qSelect.value = QUALITY_ORDER.find(q=> lc(q) === lc(currentQuality)) || "Adequate";
    const qBtn = document.createElement("button");
    qBtn.className = "btn small";
    qBtn.textContent = "Change quality";
    qBtn.addEventListener("click", async ()=>{
      const target = qSelect.value;
      if (!target) return;
      const curIdx = QUALITY_ORDER.findIndex(q=> lc(q) === lc(currentQuality));
      const targetIdx = QUALITY_ORDER.findIndex(q=> lc(q) === lc(target));
      if (curIdx < 0 || targetIdx < 0) return;
      if (targetIdx === curIdx) return;
      try{
        const inv = targetIdx > curIdx
          ? await upgradeQuality(it.item_id, target)
          : await downgradeQuality(it.item_id, target);
        LINKED_INV = inv; renderInventoryUI(); recomputePassiveAgg(); renderStatistics(); updateDerived(); queueSave();
        closeInvItemModal();
      }catch(e){
        alert(e.message);
      }
    });
    qWrap.appendChild(qSelect);
    qWrap.appendChild(qBtn);
    btnRow.appendChild(qWrap);
  }

  if (hasChoice){
    const choiceBtn = document.createElement("button");
    choiceBtn.className = "btn small";
    choiceBtn.textContent = "Configure choices";
    choiceBtn.addEventListener("click", async ()=>{
      await openItemChoiceModal(it);
      closeInvItemModal();
    });
    btnRow.appendChild(choiceBtn);
  }

  invItemActions.appendChild(btnRow);

  if (it.alchemy_tool){
    const refillRow = document.createElement("div");
    refillRow.className = "btn-row";
    const refillBtn = document.createElement("button");
    refillBtn.className = "btn small";
    const tier = alchemyTierFromPrice(it.base_price);
    const cost = 50 * tier;
    refillBtn.textContent = `Refill (+1, ${cost} Jelly)`;
    refillBtn.addEventListener("click", async ()=>{
      await refillAlchemyInline(it);
      closeInvItemModal();
    });
    refillRow.appendChild(refillBtn);
    invItemActions.appendChild(refillRow);
  }

  invItemModal.classList.remove("hidden");
  invItemModal.classList.add("open");
  invItemBackdrop.classList.remove("hidden");
  invItemBackdrop.classList.add("open");
}

function closeInvItemModal(){
  invItemModal.classList.add('hidden');
  invItemModal.classList.remove('open');
  invItemBackdrop.classList.remove('open');
}

function deriveSpellListInitialValuesFromChar(){
  if (!CHAR || !CHAR.stats) return null;
  const iv = {
    mag: totalFromInvest(investVal(CHAR.stats.magic?.invest, 0)),
    natures: {fire:0,water:0,wind:0,earth:0,sun:0,moon:0,lightning:0,ki:0},
    skills: {aura:0,incantation:0,enchantement:0,potential:0,restoration:0,stealth:0,investigation:0,charm:0,intimidation:0,absorption:0,spirit:0},
  };
  const ints = CHAR.stats.intensities || {};
  const intsLc = {};
  for (const [name, val] of Object.entries(ints)){
    intsLc[name.toLowerCase()] = investVal(val, 0);
  }
  for (const k of Object.keys(iv.natures)){
    iv.natures[k] = Math.max(0, Math.floor(intsLc[k] ?? 0));
  }
  for (const [key, ckey] of Object.entries(SKILL_TO_CHAR)){
    const label = SKILL_LABEL[key] || title(key);
    iv.skills[key] = skillTotalAdjustedFor(ckey, label).total;
  }
  return iv;
}

function drawAvatarCanvas(){
  if (!AVATAR_IMG) return;
  const ctx = avatarCanvas.getContext('2d');
  const zoom = parseFloat(avatarZoomEl.value || "1");
  const ox = parseFloat(avatarOffsetXEl.value || "0");
  const oy = parseFloat(avatarOffsetYEl.value || "0");
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,avatarCanvas.width, avatarCanvas.height);
  const w = AVATAR_IMG.width * zoom;
  const h = AVATAR_IMG.height * zoom;
  const x = (avatarCanvas.width - w)/2 + ox;
  const y = (avatarCanvas.height - h)/2 + oy;
  ctx.drawImage(AVATAR_IMG, x, y, w, h);
  avatarPreview.src = avatarCanvas.toDataURL('image/png');
}

avatarZoomEl?.addEventListener('input', drawAvatarCanvas);
avatarOffsetXEl?.addEventListener('input', drawAvatarCanvas);
avatarOffsetYEl?.addEventListener('input', drawAvatarCanvas);

avatarFileEl?.addEventListener('change', ()=>{
  const f = avatarFileEl.files?.[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = (e)=>{
    const img = new Image();
    img.onload = ()=>{
      AVATAR_IMG = img;
      // Fit the image in the 256x256 frame by default, then allow zooming in
      const fitZoom = Math.min(avatarCanvas.width / img.width, avatarCanvas.height / img.height);
      avatarZoomEl.min = (fitZoom * 0.5).toFixed(2);
      avatarZoomEl.max = (fitZoom * 4).toFixed(2);
      avatarZoomEl.step = "0.01";
      avatarZoomEl.value = fitZoom.toFixed(2);
      avatarOffsetXEl.value = "0";
      avatarOffsetYEl.value = "0";
      drawAvatarCanvas();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(f);
});

async function uploadAvatar(){
  if (!AVATAR_IMG){
    avatarStatusEl.textContent = 'Pick an image first.';
    return;
  }
  avatarStatusEl.textContent = 'Uploading...';
  await new Promise(res=> requestAnimationFrame(res));
  drawAvatarCanvas();
  await new Promise((resolve, reject)=>{
    avatarCanvas.toBlob(async (blob)=>{
      if (!blob){ reject(new Error("Cannot encode image")); return; }
      try{
        const fd = new FormData();
        fd.append('file', blob, 'avatar.png');
        const r = await fetch(`/characters/${encodeURIComponent(CID)}/avatar`, {
          method:'POST',
          headers: authHeaders(),
          body: fd
        });
        const j = await r.json().catch(()=>({}));
        if (j.status !== "success"){ throw new Error(j.message || "Upload failed"); }
        avatarStatusEl.textContent = 'Uploaded.';
        avatarPreview.src = `/characters/${encodeURIComponent(CID)}/avatar?ts=${Date.now()}`;
      }catch(e){
        avatarStatusEl.textContent = e.message;
      }
      resolve();
    }, 'image/png');
  });
}
avatarUploadBtn?.addEventListener('click', uploadAvatar);
function toggleAvatarModal(open){
  if (!avatarModal || !avatarBackdrop) return;
  if (open){
    avatarModal.classList.remove('hidden');
    avatarModal.classList.add('open');
    avatarBackdrop.classList.add('open');
  }else{
    avatarModal.classList.add('hidden');
    avatarModal.classList.remove('open');
    avatarBackdrop.classList.remove('open');
  }
}
avatarOpenBtn?.addEventListener('click', ()=>{
  toggleAvatarModal(true);
});
avatarClose?.addEventListener('click', ()=> toggleAvatarModal(false));
avatarCancel?.addEventListener('click', ()=> toggleAvatarModal(false));
avatarBackdrop?.addEventListener('click', (e)=>{ if (e.target===avatarBackdrop) toggleAvatarModal(false); });

function normalizeIV(iv){
  const defN = {fire:0,water:0,wind:0,earth:0,sun:0,moon:0,lightning:0,ki:0};
  const defS = {aura:0,incantation:0,enchantement:0,potential:0,restoration:0,stealth:0,investigation:0,charm:0,intimidation:0,absorption:0,spirit:0};
  const n = Object.assign({}, defN), s = Object.assign({}, defS);
  for (const k in (iv?.natures||{})) n[k.toLowerCase()] = +(iv.natures[k]||0);
  for (const k in (iv?.skills||{}))  s[k.toLowerCase()] = +(iv.skills[k]||0);
  return { mag: +(iv?.mag||0), natures:n, skills:s };
}

function title(str){
  const s = (str ?? '').toString();
  return s ? s.charAt(0).toUpperCase() + s.slice(1) : '';
}

const SKILL_ALIASES = {
  enchantment: "enchantement",
  enchante: "enchantement",
  incantation: "incantation",
  incantaion: "incantation",
  icnantaion: "incantation",
  incatation: "incantation",
  resto: "restoration",
};
const SKILL_LABEL = {
  aura: "Aura",
  incantation: "Incantation",
  enchantement: "Enchantment",
  potential: "Potential",
  restoration: "Restoration",
  stealth: "Stealth",
  investigation: "Investigation",
  charm: "Charm",
  intimidation: "Intimidation",
  absorption: "Absorption",
  spirit: "Spirit",
};
const SKILL_TO_CHAR = {
  aura: "magic",
  incantation: "magic",
  enchantement: "magic",
  potential: "magic",
  restoration: "magic",
  stealth: "dexterity",
  investigation: "wisdom",
  charm: "presence",
  intimidation: "willpower",
  absorption: "willpower",
  spirit: "willpower",
};
function normSkillKey(s){
  const cleaned = (s || "").toString().trim().toLowerCase().replace(/[^a-z]/g, "");
  return SKILL_ALIASES[cleaned] || cleaned;
}
function skillValFromIV(skillName, iv){
  const key = normSkillKey(skillName);
  if (!iv || !iv.skills) return 0;
  if (key && key in iv.skills) return numOr(iv.skills[key], 0);
  // fallback: loose match
  const found = Object.entries(iv.skills).find(([k])=> normSkillKey(k) === key);
  return found ? numOr(found[1], 0) : 0;
}
function skillValFromChar(skillName){
  const key = normSkillKey(skillName);
  const ckey = SKILL_TO_CHAR[key];
  if (!ckey) return null;
  const label = SKILL_LABEL[key] || title(key);
  return skillTotalAdjustedFor(ckey, label);
}

function currentIV(){
  return normalizeIV(deriveSpellListInitialValuesFromChar());
}

async function fetchSchools(){
  if (SCHOOLS.length) return SCHOOLS;
  const res = await api('/schools');
  SCHOOLS = res.schools || [];
  return SCHOOLS;
}

function renderSpellListSummary(){
  if (!LINKED_SPELL_LIST){
    slSummaryEl.textContent = 'No spell list linked.';
    return;
  }
  const count = Array.isArray(LINKED_SPELL_LIST.spells) ? LINKED_SPELL_LIST.spells.length : (LINKED_SPELL_LIST.count || 0);
  const iv = currentIV();
  slSummaryEl.textContent = `${LINKED_SPELL_LIST.name || 'Spell List'} - Spells: ${count} - MAG: ${iv.mag}`;
}

function renderXpLedger(){
  if (!xpLedgerBody) return;
  if (!XP_LEDGER.length){
    xpLedgerBody.innerHTML = '<div class="muted">No XP changes recorded yet.</div>';
    return;
  }
  xpLedgerBody.innerHTML = '';
  XP_LEDGER.forEach(ent=>{
    const delta = Math.floor(Number(ent.delta)||0);
    const sign = delta >= 0 ? '+' : '';
    const ts = ent.ts ? new Date(ent.ts).toLocaleString() : '';
    const row = document.createElement('div');
    row.className = 'home-card';
    row.innerHTML = `
      <div class="row" style="justify-content:space-between; align-items:flex-start; gap:10px;">
        <div>
          <div><strong>${ent.kind || 'XP change'}</strong></div>
          <div class="muted">${ts}</div>
          ${ent.note ? `<div class="muted">${ent.note}</div>` : ''}
        </div>
        <div style="text-align:right;">
          <div><strong>XP ${sign}${delta}</strong></div>
          <div class="muted">XP ${ent.xp} - Lv ${ent.level}</div>
        </div>
      </div>
    `;
    xpLedgerBody.appendChild(row);
  });
}

function logXpChange(kind, delta, note=''){
  const entry = {
    ts: new Date().toISOString(),
    kind: kind || 'XP change',
    delta: Math.floor(Number(delta)||0),
    xp: XP,
    level: CHAR.level
  };
  if (note) entry.note = note;
  XP_LEDGER = [entry, ...(XP_LEDGER||[])].slice(0, 100);
  CHAR.xp_ledger = XP_LEDGER;
  renderXpLedger();
}

function toggleXpLedger(open){
  if (!xpLedgerModal || !xpLedgerBackdrop) return;
  if (open){
    renderXpLedger();
    xpLedgerModal.classList.remove('hidden'); xpLedgerModal.classList.add('open');
    xpLedgerBackdrop.classList.add('open');
  }else{
    xpLedgerModal.classList.add('hidden'); xpLedgerModal.classList.remove('open');
    xpLedgerBackdrop.classList.remove('open');
  }
}

function renderXpProgress(){
  if (!xpProgressEl) return;
  const lvl = Math.max(1, Math.floor(Number(CHAR.level)||1));
  const xp = Math.max(0, Math.floor(Number(XP)||0));
  const maxed = lvl >= MAX_LEVEL;
  const curCap = xpForLevel(lvl);
  const nextCap = maxed ? curCap : xpForLevel(lvl+1);
  const span = Math.max(1, nextCap - curCap);
  const pctRaw = maxed ? 100 : ((xp - curCap) / span) * 100;
  const pct = Math.min(100, Math.max(0, Math.round(pctRaw)));
  if (xpBarFillEl) xpBarFillEl.style.width = `${pct}%`;
  if (xpBarTextEl) xpBarTextEl.textContent = maxed ? 'MAX' : `${pct}%`;
  if (maxed){
    xpProgressEl.textContent = `XP: ${xp} (level ${lvl} maxed)`;
  }else{
    const toNext = Math.max(0, nextCap - xp);
    xpProgressEl.textContent = `XP: ${xp} (level ${lvl}) - Need ${toNext} more to reach level ${lvl+1}`;
  }
}
async function renderSchoolSpellCounters(){
  if (!CHAR || !CHAR.stats) return;
  try{ if (!SCHOOLS.length) await fetchSchools(); }catch{}
  const magVal = totalFromInvest(investVal(CHAR.stats.magic?.invest, 0));
  const msMAG = milestone('magic');
  let simpleSchools = 0, complexSchools = 0;
  ADDED_SCHOOLS.forEach(id=>{
    const s = (SCHOOLS||[]).find(x=>String(x.id||x.name)===String(id));
    if (!s) return;
    const type = (s.school_type || s.type || '').toLowerCase();
    if (type === 'complex') complexSchools++; else simpleSchools++;
  });
  const metaMap = SPELLLIST_META.spell_meta || {};
  const isPrepared = (sp)=> ((metaMap[sp.id]?.status || 'known') === 'learnt');
  const findSchoolByRef = (ref)=>{
    const id = String(ref.id || ref.name || '').toLowerCase();
    return (SCHOOLS||[]).find(s=> String(s.id||'').toLowerCase()===id || String(s.name||'').toLowerCase()===id);
  };
  const spellTypes = (sp)=>{
    const refs = sp.schools || [];
    const types = [];
    refs.forEach(r=>{
      const s = findSchoolByRef(r);
      if (!s || s.upgrade) return;
      const t = (s.school_type || s.type || '').toLowerCase();
      if (t) types.push(t);
    });
    return types;
  };
  let simplePrepared = 0, complexPrepared = 0;
  SPELLLIST_SPELLS.forEach(sp=>{
    if (!isPrepared(sp)) return;
    const types = spellTypes(sp);
    if (!types.length) return;
    const hasComplex = types.includes('complex');
    const onlySimple = types.every(t=>t==='simple');
    if (hasComplex) complexPrepared++;
    else if (onlySimple) simplePrepared++;
  });
  const maxSimpleSchools = null; // unlimited simple schools
    const maxComplexSchools = numOr(DERIVED_CACHE?.complex_schools, msMAG || 0);
  const maxSimplePreparedBase = magVal;
  const maxComplexPreparedBase = msMAG * 2;
  const simpleAdj = applyOps(maxSimplePreparedBase, PASSIVE.spell_slots?.simple);
  const complexAdj = applyOps(maxComplexPreparedBase, PASSIVE.spell_slots?.complex);
  const maxSimplePrepared = Math.max(0, Math.floor(simpleAdj.value));
  const maxComplexPrepared = Math.max(0, Math.floor(complexAdj.value));
  if (cntSchSimpleEl)  cntSchSimpleEl.textContent  = `Simple schools: ${simpleSchools}${maxSimpleSchools != null ? ` / ${maxSimpleSchools}` : ''}`;
  if (cntSchComplexEl) cntSchComplexEl.textContent = `Complex schools: ${complexSchools} / ${maxComplexSchools}`;
  if (cntSpSimpleEl)   cntSpSimpleEl.textContent   = `Simple spell slots: ${simplePrepared} / ${maxSimplePrepared}`;
  if (cntSpComplexEl)  cntSpComplexEl.textContent  = `Complex spell slots: ${complexPrepared} / ${maxComplexPrepared}`;
}
const MS_CATEGORIES = [
  {name:"Avant-Garde", min:50},
  {name:"Supreme Archmage", min:46},
  {name:"Archmage", min:42},
  {name:"Grand Master", min:35},
  {name:"Master", min:31},
  {name:"High Mage", min:27},
  {name:"Magister", min:20},
  {name:"Mage", min:16},
  {name:"Adept", min:12},
  {name:"Disciple", min:8},
  {name:"Apprentice", min:6},
  {name:"Novice", min:4},
];
function mapMsCategory(ms){
  const v = Number(ms) || 0;
  const hit = MS_CATEGORIES.find(c => v >= c.min);
  return hit ? hit.name : "--";
}

function msForSchool(school){
  const iv = currentIV() || {};
  const skillKeyRaw = school.linked_skill || '';
  const skillKey = normSkillKey(skillKeyRaw);
  const valFromIV = skillValFromIV(skillKeyRaw, iv);
  const valFromChar = skillValFromChar(skillKeyRaw);
  const skillVal = Math.max(valFromIV ?? 0, valFromChar ?? 0);
  const ints = (school.linked_intensities || []).map(lc);
  const vals = ints
    .map(k => {
      const name = INTENSITIES.find(n=> lc(n) === k) || k;
      const val = skillTotalAdjustedFor('magic', name);
      return { key:k, val:numOr(val, 0) };
    })
    .sort((a,b)=> (b.val - a.val) || a.key.localeCompare(b.key));
  const top1 = vals[0] || { key:null, val:0 };
  const top2 = vals[1] || { key:null, val:0 };
  const magMod = charAdjMod('magic').mod;

  let natureBase = top1.val;
  let natureName = top1.key;
  let magUsed = 0;

  if (top2.key){
    const secondPlusMag = top2.val + magMod;
    const useSecond = !(top1.val > secondPlusMag);
    natureBase = useSecond ? top2.val : top1.val;
    natureName = useSecond ? top2.key : top1.key;
    magUsed = useSecond ? magMod : 0;
  }

  const natureTotal = natureBase + magUsed;
  const ms = skillVal + natureTotal;
  return {
    ms,
    category: mapMsCategory(ms),
    skillVal,
    skillKey,
    top1: top1.val,
    top2: top2.val,
    natureName,
    natureBase,
    natureTotal,
    magUsed,
    magMod,
  };
}
function msForSchoolWithMods(school){
  const base = msForSchool(school);
  const key = String(school.id || school.name || '').toLowerCase();
  const adj = applyOps(base.ms, PASSIVE.school[key]);
  return { ...base, ms: adj.value, notes: adj.notes };
}

function isComplexEligible(school){
  const magTotal = totalFromInvest(investVal(CHAR.stats.magic?.invest, 0));
  if (magTotal < 10) return false;
  const linked = (school.linked_intensities || []).map(lc);
  const needed = linked.length <= 1 ? 1 : 2;
  const iv = currentIV() || {};
  const count = linked.map(k=> numOr(iv.natures?.[k], 0)).filter(v=> v >= 10).length;
  return count >= needed;
}

function toggleSchoolModal(open){
  if (!slSchModal || !slSchBackdrop) return;
  if (open){
    slSchModal.classList.remove('hidden'); slSchBackdrop.classList.remove('hidden');
    slSchModal.classList.add('open'); slSchBackdrop.classList.add('open');
  }else{
    slSchModal.classList.add('hidden'); slSchBackdrop.classList.add('hidden');
    slSchModal.classList.remove('open'); slSchBackdrop.classList.remove('open');
    if (slSchStatus) slSchStatus.textContent = '';
  }
}

function setSchoolOrderStatus(msg){
  if (!slSchOrderStatusEl) return;
  slSchOrderStatusEl.textContent = msg || '';
}

function setAddedSchoolsOrder(order, { saveMeta = false } = {}){
  const cleaned = [];
  const seen = new Set();
  (order || []).forEach(id=>{
    const key = String(id || '');
    if (!key || seen.has(key)) return;
    seen.add(key);
    cleaned.push(key);
  });
  ADDED_SCHOOLS = new Set(cleaned);
  if (CHAR && CHAR.stats) CHAR.stats.selected_schools = cleaned.slice();
  if (saveMeta){
    const payload = { selected_schools: cleaned, pinned_schools: cleaned };
    saveSpellListMeta(payload).catch(()=>{});
  }
  queueSave();
  return cleaned;
}

async function applyAddedSchoolSort(mode){
  const sortMode = String(mode || '').toLowerCase();
  if (sortMode !== 'name' && sortMode !== 'ms'){
    setSchoolOrderStatus('');
    return false;
  }
  if (!ADDED_SCHOOLS.size){
    setSchoolOrderStatus('No schools to sort.');
    return false;
  }
  if (!SCHOOLS.length){
    try{ await fetchSchools(); }catch{}
  }
  const orderAll = Array.from(ADDED_SCHOOLS).map(String);
  if (!orderAll.length){
    setSchoolOrderStatus('No schools to sort.');
    return false;
  }
  const known = [];
  const unknown = [];
  orderAll.forEach(id=>{
    const s = (SCHOOLS||[]).find(x=> String(x.id||x.name) === String(id));
    if (s) known.push({ id: String(id), s });
    else unknown.push(id);
  });
  if (!known.length && !unknown.length){
    setSchoolOrderStatus('No schools to sort.');
    return false;
  }
  if (sortMode === 'name'){
    known.sort((a,b)=> (a.s.name || a.id || '').localeCompare((b.s.name || b.id || ''), undefined, { sensitivity: 'base' }));
  }else{
    known.sort((a,b)=>{
      const ams = msForSchoolWithMods(a.s).ms;
      const bms = msForSchoolWithMods(b.s).ms;
      if (bms !== ams) return bms - ams;
      return (a.s.name || a.id || '').localeCompare((b.s.name || b.id || ''), undefined, { sensitivity: 'base' });
    });
  }
  const order = known.map(entry=> entry.id).concat(unknown);
  setAddedSchoolsOrder(order, { saveMeta: true });
  await renderAddedSchools();
  setSchoolOrderStatus(sortMode === 'name' ? 'Sorted by name.' : 'Sorted by MS (high to low).');
  return true;
}

function moveAddedSchool(id, direction){
  const order = Array.from(ADDED_SCHOOLS).map(String);
  const idx = order.indexOf(String(id));
  if (idx < 0) return;
  const delta = direction === 'up' ? -1 : 1;
  const next = idx + delta;
  if (next < 0 || next >= order.length) return;
  const updated = order.slice();
  updated.splice(next, 0, updated.splice(idx, 1)[0]);
  setAddedSchoolsOrder(updated, { saveMeta: true });
  if (slSchOrderEl) slSchOrderEl.value = 'manual';
  setSchoolOrderStatus('');
  renderAddedSchools();
}

async function renderAddedSchools(){
  if (!slSchoolsEl) return;
  if (!SCHOOLS.length){
    try{ await fetchSchools(); }catch{}
  }
  slSchoolsEl.innerHTML = '';
  if (!ADDED_SCHOOLS.size){
    slSchoolsEl.innerHTML = '<div class="muted">No schools added yet.</div>';
    setSchoolOrderStatus('');
    return;
  }
  const list = Array.from(ADDED_SCHOOLS).map(id=>{
    const s = (SCHOOLS||[]).find(x=>String(x.id||x.name)===String(id));
    return s ? { id, s } : null;
  }).filter(Boolean);
  if (!list.length){
    slSchoolsEl.innerHTML = '<div class="muted">No schools added yet.</div>';
    setSchoolOrderStatus('');
    return;
  }
  list.forEach(({id,s}, idx)=>{
    const msInfo = msForSchoolWithMods(s);
    const ms = msInfo.ms;
    const cat = mapMsCategory(ms) || s.category || s.type || '--';
    const tipLines = [
      `Skill (${s.linked_skill || 'skill'}): ${msInfo.skillVal || 0}`,
      `Top nature: ${msInfo.top1 || 0}`,
      `Second nature: ${msInfo.top2 || 0}`,
      `Used: ${msInfo.natureName ? title(msInfo.natureName) : '—'} ${msInfo.natureBase || 0}${msInfo.magUsed ? ` + MAG ${msInfo.magUsed}` : ''}`,
      `Total MS: ${ms}`,
    ];
    if (msInfo.notes && msInfo.notes.length){
      tipLines.push('MS modifiers:');
      msInfo.notes.forEach(n=> tipLines.push(`- ${n}`));
    }
    const div = document.createElement('div');
    div.className = 'abi-item';
    const isFirst = idx === 0;
    const isLast = idx === list.length - 1;
    div.innerHTML = `
      <div class="grow">
        <div><strong>${s.name || id}</strong></div>
        <div class="muted" title="${tipLines.join('\n').replace(/"/g,'&quot;')}">MS: ${ms} | Category: ${cat}</div>
      </div>
      <span class="tag">${(s.school_type || s.type || '').toUpperCase()}</span>
      <div class="row" style="gap:6px; flex-wrap:wrap;">
        <button class="btn small" data-move="up" data-id="${id}" ${isFirst ? 'disabled' : ''}>↑</button>
        <button class="btn small" data-move="down" data-id="${id}" ${isLast ? 'disabled' : ''}>↓</button>
        <button class="btn small" data-remove="${id}">X</button>
      </div>
    `;
    const remBtn = div.querySelector('button[data-remove]');
    const upBtn = div.querySelector('button[data-move="up"]');
    const downBtn = div.querySelector('button[data-move="down"]');
    remBtn?.addEventListener('click', async ()=>{
      ADDED_SCHOOLS.delete(String(id));
      try{ await saveSpellListMeta({ selected_schools: Array.from(ADDED_SCHOOLS) }); }catch{}
      if (CHAR && CHAR.stats) CHAR.stats.selected_schools = Array.from(ADDED_SCHOOLS);
      queueSave();
      renderAddedSchools();
      renderSchoolSpellCounters();
    });
    upBtn?.addEventListener('click', ()=> moveAddedSchool(id, 'up'));
    downBtn?.addEventListener('click', ()=> moveAddedSchool(id, 'down'));
    slSchoolsEl.appendChild(div);
  });
}


async function quickAddSchools(){
  if (!SCHOOLS.length){ await fetchSchools(); }
  const before = new Set(ADDED_SCHOOLS);
  SCHOOLS.forEach(s=>{
    const type = (s.school_type || s.type || '').toLowerCase();
    if (type === 'simple'){
      ADDED_SCHOOLS.add(String(s.id||s.name));
    }else if (type === 'complex' && isComplexEligible(s)){
      ADDED_SCHOOLS.add(String(s.id||s.name));
    }
  });
  const addedCount = ADDED_SCHOOLS.size - before.size;
  if (slSchoolsStatusEl) slSchoolsStatusEl.textContent = addedCount ? `Added ${addedCount} school(s).` : 'No new schools met the requirements.';
  CHAR.stats.selected_schools = Array.from(ADDED_SCHOOLS);
  const sortMode = slSchOrderEl ? slSchOrderEl.value : 'manual';
  const sorted = sortMode !== 'manual' ? await applyAddedSchoolSort(sortMode) : false;
  if (!sorted){
    const payload = { selected_schools: Array.from(ADDED_SCHOOLS), pinned_schools: Array.from(ADDED_SCHOOLS) };
    try{ await saveSpellListMeta(payload); }catch{}
    await renderAddedSchools();
  }
  renderSchoolSpellCounters();
  queueSave();
}

async function openManualAddModal(){
  if (!SELECTED_SPELL_LIST_ID){
    slSchoolsStatusEl.textContent = 'Link a spell list first.';
    return;
  }
  if (!slSchBody) return;
  slSchBody.innerHTML = '<tr><td colspan="4" class="empty">Loading...</td></tr>';
  if (!SCHOOLS.length){ await fetchSchools(); }
  const available = (SCHOOLS||[]).filter(s=> !ADDED_SCHOOLS.has(String(s.id||s.name)));
  available.sort((a,b)=> (b.category||'').localeCompare(a.category||'') || (a.name||'').localeCompare(b.name||''));
  slSchBody.innerHTML = '';
  if (!available.length){
    slSchBody.innerHTML = '<tr><td colspan="4" class="empty">No remaining schools to add.</td></tr>';
  }else{
    available.forEach(s=>{
      const id = String(s.id||s.name);
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input type="checkbox" value="${id}"></td>
        <td>${s.name || id}</td>
        <td>${s.school_type || s.type || ''}</td>
        <td>${s.category || ''}</td>
      `;
      slSchBody.appendChild(tr);
    });
  }
  toggleSchoolModal(true);
}

async function applyManualAdd(){
  if (!slSchBody) return;
  if (!SELECTED_SPELL_LIST_ID){
    slSchoolsStatusEl.textContent = 'Link a spell list first.';
    return;
  }
  const selected = Array.from(slSchBody.querySelectorAll('input[type="checkbox"]:checked')).map(el=>el.value);
  selected.forEach(id=> ADDED_SCHOOLS.add(String(id)));
  toggleSchoolModal(false);
  const sortMode = slSchOrderEl ? slSchOrderEl.value : 'manual';
  const sorted = sortMode !== 'manual' ? await applyAddedSchoolSort(sortMode) : false;
  if (!sorted){
    const payload = { selected_schools: Array.from(ADDED_SCHOOLS), pinned_schools: Array.from(ADDED_SCHOOLS) };
    try{ await saveSpellListMeta(payload); }catch{}
    await renderAddedSchools();
  }
  if (slSchoolsStatusEl) slSchoolsStatusEl.textContent = selected.length ? `Added ${selected.length} school(s).` : 'No schools selected.';
  renderSchoolSpellCounters();
  queueSave();
}

function addXp(amount){
  const inc = Math.max(0, Math.floor(Number(amount)||0));
  if (!inc) return;
  const prevXp = XP;
  XP = Math.max(0, XP + inc);
  CHAR.xp = XP;
  const lvl = levelFromXp(XP);
  CHAR.level = lvl;
  CHAR.stats.level = CHAR.level;
  levelEl.value = lvl;
  renderXpProgress();
  updateDerived();
  renderSublimations();
  refreshArchetypeAbilities();
  logXpChange('Add XP', XP - prevXp, `Added ${inc} XP`);
  queueSave();
}

function setLevelManual(lvl){
  const val = Math.max(1, Math.min(MAX_LEVEL, Math.floor(Number(lvl)||1)));
  const prevXp = XP;
  CHAR.level = val;
  CHAR.stats.level = CHAR.level;
  levelEl.value = val;
  if (XP < xpForLevel(val)) XP = xpForLevel(val);
  CHAR.xp = XP;
  renderXpProgress();
  updateDerived();
  renderSublimations();
  refreshArchetypeAbilities();
  logXpChange('Set level', XP - prevXp, `Set level to ${val}`);
  queueSave();
}

function renderSpellRows(){
  if (!slSpellsBody) return;
  const metaMap = SPELLLIST_META.spell_meta || {};
  if (!SPELLLIST_SPELLS.length){
    slSpellsBody.innerHTML = '<tr><td colspan="5" class="empty">No spells. Add some.</td></tr>';
    return;
  }
  slSpellsBody.innerHTML = '';
  SPELLLIST_SPELLS.forEach(sp=>{
    const meta = metaMap[sp.id] || {};
    const alt = meta.alt_name || '';
    const status = meta.status || 'known';
    const nameDisplay = alt || sp.name || 'Spell';
    const tr = document.createElement('tr');
    const schools = (sp.schools||[]).map(s=>s.name||s.id).join(', ');
    tr.innerHTML = `
      <td><div class="k">${nameDisplay}</div><div class="muted">id: ${sp.id}</div></td>
      <td>${schools || '—'}</td>
      <td>${sp.category || '—'}</td>
      <td>
        <select class="sl-status" data-id="${sp.id}">
        <option value="known" ${status==="known"?"selected":""}>Learnt</option>
        <option value="learnt" ${status==="learnt"?"selected":""}>Prepared</option>
        </select>
      </td>
      <td><button class="btn small" data-remove="${sp.id}">X</button></td>
    `;
    slSpellsBody.appendChild(tr);
  });
  slSpellsBody.querySelectorAll('.sl-status').forEach(sel=>{
    sel.addEventListener('change', ()=>{
      const id = sel.getAttribute('data-id');
      SPELLLIST_META.spell_meta = SPELLLIST_META.spell_meta || {};
      const cur = SPELLLIST_META.spell_meta[id] || {};
      SPELLLIST_META.spell_meta[id] = { ...cur, status: sel.value };
      saveSpellListMeta({ spell_meta: SPELLLIST_META.spell_meta }).catch(()=>{});
      renderAbilitySpellsBucket();
      renderSchoolSpellCounters();
    });
  });
  slSpellsBody.querySelectorAll('button[data-remove]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.getAttribute('data-remove');
      if (!confirm(`Remove spell ${id}?`)) return;
      await removeSpellFromList(id);
    });
  });
}

function renderAbilitySpellsBucket(){
  const el = document.getElementById('abi-list-spells');
  if (!el) return;
  el.innerHTML = '';
  const craftEntries = collectFocusedCraftomancies();
  if (!SPELLLIST_SPELLS.length && !craftEntries.length){
    el.innerHTML = '<div class="muted">No linked spells.</div>';
    return;
  }
  // lazy-load effects for descriptions
  if (!Object.keys(EFFECTS_BY_ID).length && !EFFECTS_PROMISE){
    ensureEffectsLoaded().then(()=> renderAbilitySpellsBucket());
  }
  const metaMap = SPELLLIST_META.spell_meta || {};
  const onlyLearned = !!(abiSpellsOnlyLearnedEl && abiSpellsOnlyLearnedEl.checked);
  const ordered = applySpellSort(SPELLLIST_SPELLS, ABI_SORT_SPELLS, metaMap);
  const visible = ordered.filter(sp=> !onlyLearned || (metaMap[sp.id]?.status === 'learnt'));
  const sortMode = String(ABI_SORT_SPELLS || '').toLowerCase();
  const manualMode = sortMode === 'manual';
  const moveIndexById = {};
  visible.forEach((sp, idx)=>{ moveIndexById[String(sp?.id || '')] = idx; });
  const craftOrdered = craftEntries.slice();
  if (sortMode === 'az' || sortMode === 'za'){
    craftOrdered.sort((a, b)=>{
      const aCraft = a?.craft || {};
      const bCraft = b?.craft || {};
      const aName = spellDisplayName({ id: aCraft.spell_id || '', name: aCraft.spell_name || '' }, metaMap);
      const bName = spellDisplayName({ id: bCraft.spell_id || '', name: bCraft.spell_name || '' }, metaMap);
      return String(aName).localeCompare(String(bName), undefined, { sensitivity: 'base' });
    });
    if (sortMode === 'za') craftOrdered.reverse();
  }
  visible.forEach(sp=>{
    const meta = metaMap[sp.id] || {};
    const nameDisplay = spellDisplayName(sp, metaMap);
    const desc = meta.description || sp.description || sp.description_long || sp.desc || '';
    const flavor = sp.flavor || sp.flavour || '';
    const userFlavor = meta.flavor || meta.flavour || '';
    const effectDetails = Array.isArray(sp.effects_detail) ? sp.effects_detail : [];
    let effectsDesc = effectDetails.map(e=> e.description || e.detail || e).filter(Boolean).join(' | ');
    const effectCounts = {};
    (sp.effects || []).forEach(eid=>{
      const k = String(eid||'').toLowerCase();
      effectCounts[k] = (effectCounts[k]||0) + 1;
    });
    const resolvedEffects = Object.entries(effectCounts).map(([id,count])=>{
      const eff = EFFECTS_BY_ID[id] || {};
      const base = eff.description || eff.effect || eff.text || eff.name || id;
      const countTxt = count > 1 ? ` x${count}` : '';
      return `${base}${countTxt}`;
    }).filter(Boolean);
    if (resolvedEffects.length){
      effectsDesc = effectsDesc ? `${effectsDesc} | ${resolvedEffects.join(' | ')}` : resolvedEffects.join(' | ');
    }else if (!effectsDesc){
      const rawEffect = sp.effect || sp.effect_text || sp.effectText || sp.effect_description || sp.effects_description;
      if (rawEffect) effectsDesc = String(rawEffect);
    }
    const costParts = [];
    if (sp.en_cost != null) costParts.push(`EN: ${sp.en_cost}`);
    const cost = costParts.join(' || ');
    const range = sp.range != null ? `Range: ${sp.range}` : '';
    const aoe = sp.aoe ? `AoE: ${sp.aoe}` : '';
    const div = document.createElement('div');
    div.className = 'abi-item';
    const statusLabel = (meta.status === 'learnt') ? 'Prepared' : 'Learnt';
    const titleKey = spellColorKey(sp);
    const id = String(sp?.id || '');
    const moveIdx = moveIndexById[id];
    const isFirst = moveIdx === 0;
    const isLast = moveIdx === visible.length - 1;
    const disableMove = !manualMode;
    div.innerHTML = `
        <div class="grow">
          <div><strong class="title-color-target">${nameDisplay}</strong> <span class="muted">${statusLabel}</span></div>
          <div class="muted" style="font-size:.85rem">${desc}</div>
          ${flavor ? `<div class="muted" style="font-size:.8rem"><em>${flavor}</em></div>` : ''}
          ${userFlavor ? `<div class="muted" style="font-size:.8rem"><em>User note: ${userFlavor}</em></div>` : ''}
          ${effectsDesc ? `<div class="muted" style="font-size:.8rem">Effects: ${effectsDesc}</div>` : ''}
          <div class="muted" style="font-size:.8rem">${cost} ${range?` || ${range}`:''} ${aoe?` || ${aoe}`:''}</div>
        </div>
        <div class="row" style="gap:6px; flex-wrap:wrap;">
          <button class="btn small" data-move="up" data-id="${id}" title="${manualMode ? 'Move up' : 'Switch order to Manual to move'}" ${disableMove || isFirst ? 'disabled' : ''}>&#8593;</button>
          <button class="btn small" data-move="down" data-id="${id}" title="${manualMode ? 'Move down' : 'Switch order to Manual to move'}" ${disableMove || isLast ? 'disabled' : ''}>&#8595;</button>
          <span class="tag">${sp.category || ''}</span>
        </div>
      `;
    registerTitleColorTarget(div.querySelector('.title-color-target'), titleKey, nameDisplay);
    div.addEventListener('click', (e)=> handleInfoClick(e, ()=> openSpellRoll(sp, meta, { cost, range, aoe, desc, effectsDesc, statusLabel, nameDisplay })));
    div.querySelector('button[data-move="up"]')?.addEventListener('click', ()=> moveSpellOrder(sp.id, 'up', { onlyLearned }));
    div.querySelector('button[data-move="down"]')?.addEventListener('click', ()=> moveSpellOrder(sp.id, 'down', { onlyLearned }));
    el.appendChild(div);
  });

  craftOrdered.forEach(entry=>{
    const cm = entry.craft || {};
    const sp = {
      id: cm.spell_id || '',
      name: cm.spell_name || '',
      category: cm.effective_category || cm.spell_category || '',
      description: cm.spell_description || '',
      description_long: cm.spell_description_long || '',
      desc: cm.spell_description || '',
      flavor: cm.spell_flavor || '',
      effects: cm.spell_effects || [],
      effects_detail: cm.spell_effects_detail || [],
      mp_cost: cm.spell_mp_cost,
      en_cost: cm.spell_en_cost,
      range: cm.spell_range,
      aoe: cm.spell_aoe,
      duration: cm.spell_duration
    };
    const nameDisplay = spellDisplayName(sp, metaMap);
    const desc = sp.description || sp.description_long || sp.desc || '';
    const flavor = sp.flavor || '';
    const effectDetails = Array.isArray(sp.effects_detail) ? sp.effects_detail : [];
    let effectsDesc = effectDetails.map(e=> e.description || e.detail || e).filter(Boolean).join(' | ');
    const effectCounts = {};
    (sp.effects || []).forEach(eid=>{
      const k = String(eid||'').toLowerCase();
      effectCounts[k] = (effectCounts[k]||0) + 1;
    });
    const resolvedEffects = Object.entries(effectCounts).map(([id,count])=>{
      const eff = EFFECTS_BY_ID[id] || {};
      const base = eff.description || eff.effect || eff.text || eff.name || id;
      const countTxt = count > 1 ? ` x${count}` : '';
      return `${base}${countTxt}`;
    }).filter(Boolean);
    if (resolvedEffects.length){
      effectsDesc = effectsDesc ? `${effectsDesc} | ${resolvedEffects.join(' | ')}` : resolvedEffects.join(' | ');
    }
    const costParts = [];
    if (sp.en_cost != null) costParts.push(`EN: ${sp.en_cost}`);
    const cost = costParts.join(' || ');
    const range = sp.range != null ? `Range: ${sp.range}` : '';
    const aoe = sp.aoe ? `AoE: ${sp.aoe}` : '';
    const div = document.createElement('div');
    div.className = 'abi-item';
    const statusLabel = 'Craftomancy';
    const titleKey = spellColorKey(sp) || entryColorKey('craft', cm);
    div.innerHTML = `
      <div class="grow">
        <div><strong class="title-color-target">${nameDisplay}</strong> <span class="muted">${statusLabel}</span></div>
        <div class="muted" style="font-size:.85rem">${desc}</div>
        ${flavor ? `<div class="muted" style="font-size:.8rem"><em>${flavor}</em></div>` : ''}
        ${effectsDesc ? `<div class="muted" style="font-size:.8rem">Effects: ${effectsDesc}</div>` : ''}
        <div class="muted" style="font-size:.8rem">${cost} ${range?` || ${range}`:''} ${aoe?` || ${aoe}`:''}</div>
      </div>
      <div class="row" style="gap:6px; flex-wrap:wrap;">
        <span class="tag">${sp.category || ''}</span>
        <span class="tag">Craftomancy</span>
      </div>
    `;
    registerTitleColorTarget(div.querySelector('.title-color-target'), titleKey, nameDisplay);
    div.addEventListener('click', (e)=> handleInfoClick(e, ()=> openSpellRoll(sp, {}, { cost, range, aoe, desc, effectsDesc, statusLabel, nameDisplay })));
    el.appendChild(div);
  });
}

function openSpellAddModal(){
  slAddModal.classList.remove('hidden');
  slAddModal.classList.add('open');
  slAddBackdrop.classList.add('open');
}
function closeSpellAddModal(){
  slAddModal.classList.add('hidden');
  slAddModal.classList.remove('open');
  slAddBackdrop.classList.remove('open');
  slAddStatus.textContent = '';
}

async function loadSpellListsList(){
  slStatusEl.textContent = 'Loading spell lists...';
  try{
    const res = await api('/spell_lists/mine');
    SPELL_LISTS = res.lists || [];
    slSelectEl.innerHTML = '<option value="">-- Select spell list --</option>';
    SPELL_LISTS.forEach(lst=>{
      const opt = document.createElement('option');
      opt.value = lst.id;
      opt.textContent = lst.name || lst.id;
      if (lst.id === SELECTED_SPELL_LIST_ID) opt.selected = true;
      slSelectEl.appendChild(opt);
    });
    slStatusEl.textContent = '';
  }catch(e){
    slStatusEl.textContent = 'Load failed: ' + e.message;
  }
}

async function loadSpellListMeta(id){
  const res = await api(`/spell_lists/${encodeURIComponent(id)}/meta`);
  SPELLLIST_META = res.meta || {};
  const metaSel = Array.isArray(SPELLLIST_META.selected_schools) ? SPELLLIST_META.selected_schools : null;
  const metaPinned = Array.isArray(SPELLLIST_META.pinned_schools) ? SPELLLIST_META.pinned_schools : null;
  const statSel = Array.isArray(CHAR.stats?.selected_schools) ? CHAR.stats.selected_schools : null;
  const raw = (metaSel && metaSel.length) ? metaSel
            : (metaPinned && metaPinned.length) ? metaPinned
            : (statSel && statSel.length) ? statSel
            : (metaSel ?? metaPinned ?? statSel ?? []);
  setAddedSchools(raw || []);
}

async function saveSpellListMeta(patch){
  if (!SELECTED_SPELL_LIST_ID) return;
  const res = await fetch(`/spell_lists/${encodeURIComponent(SELECTED_SPELL_LIST_ID)}/meta`, {
    method:"PUT",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify(patch)
  });
  const j = await res.json();
  if (j.status !== "success") throw new Error(j.message || "Save failed");
  SPELLLIST_META = { ...SPELLLIST_META, ...(patch || {}) };
  if (patch && Array.isArray(patch.selected_schools)){
    ADDED_SCHOOLS = new Set(patch.selected_schools.map(String));
  }
}

async function fetchSpellListSpells(id){
  const res = await api(`/spell_lists/${encodeURIComponent(id)}/spells`);
  return res.spells || [];
}

async function removeSpellFromList(id){
  const r = await fetch(`/spell_lists/${encodeURIComponent(SELECTED_SPELL_LIST_ID)}/spells/${encodeURIComponent(id)}`, {
    method:"DELETE",
    headers: authHeaders()
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ alert(j.message || "Remove failed"); return; }
  await reloadSpellListData();
}

async function addSpellsToList(ids){
  const r = await fetch(`/spell_lists/${encodeURIComponent(SELECTED_SPELL_LIST_ID)}/spells`, {
    method:"POST",
    headers:{ "Content-Type":"application/json", ...authHeaders() },
    body: JSON.stringify({ ids })
  });
  const j = await r.json().catch(()=>({}));
  if (j.status !== "success"){ slAddStatus.textContent = j.message || "Add failed"; return; }
  slAddStatus.textContent = `Added ${j.added?.length || ids.length} spell(s).`;
  await reloadSpellListData();
}

async function searchSpells(q){
  const qs = q ? `?name=${encodeURIComponent(q)}` : '';
  const res = await api('/spells'+qs);
  return res.spells || [];
}

async function renderSpellSearch(){
  const q = slSearchQ.value.trim();
  slAddStatus.textContent = '';
  slSearchBody.innerHTML = '<tr><td colspan="4" class="empty">Searching...</td></tr>';
  try{
    const rows = await searchSpells(q);
    if (!rows.length){
      slSearchBody.innerHTML = '<tr><td colspan="4" class="empty">No results.</td></tr>';
      return;
    }
    slSearchBody.innerHTML = '';
    rows.forEach(sp=>{
      const tr = document.createElement('tr');
      const schools = (sp.schools||[]).map(s=>s.name||s.id).join(', ');
      tr.innerHTML = `
        <td>${sp.name || 'Spell'}</td>
        <td>${schools || '—'}</td>
        <td>${sp.category || '—'}</td>
        <td><button class="btn small" data-add="${sp.id}">Add</button></td>
      `;
      tr.querySelector('button').addEventListener('click', ()=> addSpellsToList([sp.id]));
      slSearchBody.appendChild(tr);
    });
  }catch(e){
    slSearchBody.innerHTML = `<tr><td colspan="4" class="empty">Error: ${e.message}</td></tr>`;
  }
}

async function reloadSpellListData(){
  if (!SELECTED_SPELL_LIST_ID){
    SPELLLIST_SPELLS=[]; SPELLLIST_META={};
    if (CHAR && CHAR.stats) setAddedSchools(CHAR.stats.selected_schools || []);
    renderSpellRows(); renderAddedSchools(); renderSpellListSummary(); renderAbilitySpellsBucket(); renderSchoolSpellCounters(); recomputePassiveAgg(); renderStatistics(); updateDerived(); renderCombatSpellList(); renderCombatEtUsage(); return;
  }
  await loadSpellListMeta(SELECTED_SPELL_LIST_ID);
  SPELLLIST_SPELLS = await fetchSpellListSpells(SELECTED_SPELL_LIST_ID);
  trackUpdatedAt("spells", SPELLLIST_SPELLS, "Spells");
  await ensureEffectsLoaded();
  renderSpellListSummary();
  await fetchSchools();
  renderAddedSchools();
  renderSpellRows();
  renderAbilitySpellsBucket();
  renderSchoolSpellCounters();
  recomputePassiveAgg(); renderStatistics(); updateDerived(); renderCombatSpellList(); renderCombatEtUsage(); queueSave();
}

function getSpeciesAbilityId(){
  return String(CHAR?.stats?.species_ability_id || '').trim();
}
function setSpeciesAbilityId(id){
  if (!CHAR) return;
  if (!CHAR.stats) CHAR.stats = normalizeStats(CHAR.stats || {});
  CHAR.stats.species_ability_id = id || '';
}
function ensureSpeciesAbilityLinked(){
  const id = getSpeciesAbilityId();
  if (!id) return;
  if (!Array.isArray(CHAR.abilities)) CHAR.abilities = [];
  const set = new Set(CHAR.abilities.map(x=> String(x||'').trim()).filter(Boolean));
  if (!set.has(id)) CHAR.abilities.push(id);
}
function abilityDescHtml(ability){
  return String(ability?.description_html || ability?.description || '').trim();
}
function updateSpeciesDesc(id){
  if (!speciesDescEl) return;
  const hit = SPECIES_ABILITIES.find(a=> String(a.id) === String(id || ''));
  const html = abilityDescHtml(hit);
  if (html){
    speciesDescEl.innerHTML = html;
    speciesDescEl.style.display = '';
  }else{
    speciesDescEl.innerHTML = '';
    speciesDescEl.style.display = 'none';
  }
}
async function loadSpeciesList(){
  if (!speciesSelectEl) return;
  if (speciesStatusEl) speciesStatusEl.textContent = 'Loading species...';
  speciesSelectEl.innerHTML = '<option value="">-- Select species --</option>';
  try{
    const res = await api('/abilities?source=Specie');
    SPECIES_ABILITIES = res.abilities || [];
    SPECIES_ABILITIES.sort((a,b)=> String(a.name||a.id||'').localeCompare(String(b.name||b.id||'')));
    SPECIES_ABILITIES.forEach(a=>{
      const opt = document.createElement('option');
      opt.value = a.id;
      opt.textContent = a.name || a.id;
      speciesSelectEl.appendChild(opt);
    });
    const current = getSpeciesAbilityId();
    if (current) speciesSelectEl.value = current;
    updateSpeciesDesc(current);
    if (speciesStatusEl) speciesStatusEl.textContent = '';
  }catch(e){
    if (speciesStatusEl) speciesStatusEl.textContent = 'Load species failed: ' + e.message;
  }
}
async function applySpeciesSelection(id){
  if (!CHAR || !speciesSelectEl) return;
  const next = String(id || '').trim();
  const current = getSpeciesAbilityId();
  if (next === current) return;
  if (speciesStatusEl) speciesStatusEl.textContent = 'Applying...';
  if (current){
    await removeAbilityFromChar(current);
  }
  if (next){
    await addAbilityToChar(next);
  }
  setSpeciesAbilityId(next);
  speciesSelectEl.value = next;
  if (speciesStatusEl) speciesStatusEl.textContent = next ? 'Species applied.' : 'Species cleared.';
  updateSpeciesDesc(next);
  queueSave();
}

function getBoonAbilityId(){
  return String(CHAR?.stats?.boon_ability_id || '').trim();
}
function setBoonAbilityId(id){
  if (!CHAR) return;
  if (!CHAR.stats) CHAR.stats = normalizeStats(CHAR.stats || {});
  CHAR.stats.boon_ability_id = id || '';
}
function ensureBoonAbilityLinked(){
  const id = getBoonAbilityId();
  if (!id) return;
  if (!Array.isArray(CHAR.abilities)) CHAR.abilities = [];
  const set = new Set(CHAR.abilities.map(x=> String(x||'').trim()).filter(Boolean));
  if (!set.has(id)) CHAR.abilities.push(id);
}
function updateBoonDesc(id){
  if (!boonDescEl) return;
  const hit = BOON_ABILITIES.find(a=> String(a.id) === String(id || ''));
  const html = abilityDescHtml(hit);
  if (html){
    boonDescEl.innerHTML = html;
    boonDescEl.style.display = '';
  }else{
    boonDescEl.innerHTML = '';
    boonDescEl.style.display = 'none';
  }
}
async function loadBoonList(){
  if (!boonSelectEl) return;
  if (boonStatusEl) boonStatusEl.textContent = 'Loading boons...';
  boonSelectEl.innerHTML = '<option value="">-- Select boon --</option>';
  try{
    const res = await api('/abilities?source=Boon');
    BOON_ABILITIES = res.abilities || [];
    BOON_ABILITIES.sort((a,b)=> String(a.name||a.id||'').localeCompare(String(b.name||b.id||'')));
    BOON_ABILITIES.forEach(a=>{
      const opt = document.createElement('option');
      opt.value = a.id;
      opt.textContent = a.name || a.id;
      boonSelectEl.appendChild(opt);
    });
    const current = getBoonAbilityId();
    if (current) boonSelectEl.value = current;
    updateBoonDesc(current);
    if (boonStatusEl) boonStatusEl.textContent = '';
  }catch(e){
    if (boonStatusEl) boonStatusEl.textContent = 'Load boons failed: ' + e.message;
  }
}
async function applyBoonSelection(id){
  if (!CHAR || !boonSelectEl) return;
  const next = String(id || '').trim();
  const current = getBoonAbilityId();
  if (next === current) return;
  if (boonStatusEl) boonStatusEl.textContent = 'Applying...';
  if (current){
    await removeAbilityFromChar(current);
  }
  if (next){
    await addAbilityToChar(next);
  }
  setBoonAbilityId(next);
  boonSelectEl.value = next;
  if (boonStatusEl) boonStatusEl.textContent = next ? 'Boon applied.' : 'Boon cleared.';
  updateBoonDesc(next);
  queueSave();
}

async function loadArchetypesList(){
  try{
    const res = await api('/archetypes');
    ARCHETYPES = res.archetypes || [];
    arcSelectEl.innerHTML = '<option value=\"\">-- Select archetype --</option>';
    ARCHETYPES.forEach(a=>{
      const opt = document.createElement('option');
      opt.value = a.id;
      opt.textContent = a.name || a.id;
      if (CHAR?.archetype_id === a.id) opt.selected = true;
      arcSelectEl.appendChild(opt);
    });
  }catch(e){
    arcStatusEl.textContent = 'Load archetypes failed: '+e.message;
  }
}

async function fetchAbilitiesByIds(ids){
  if (!ids || !ids.length) return [];
  const qs = '?ids=' + encodeURIComponent(ids.join(','));
  const res = await api('/abilities/bulk'+qs);
  return res.abilities || [];
}

async function computeArchetypeUnlockedIds(archetype, lvl){
  if (!archetype) return [];
  const effRank = _archetypeRankForLevel(Math.max(1, Number(lvl)||1));
  const ranks = archetype.ranks || [];
  const unlocked = ranks.filter(r=> Number(r.rank||0) <= effRank);
  const byId = {};
  unlocked.forEach(r=>{
    const id = r.ability_id || r.ability || r.id;
    if (id) byId[id] = r;
  });
  const replaced = new Set();
  unlocked.forEach(r=>{
    const rep = r.replaces_id || r.replaces || '';
    if (rep && byId[rep]) replaced.add(rep);
  });
  const ids = Object.keys(byId);
  if (ids.length){
    const docs = await fetchAbilitiesByIds(ids);
    docs.forEach(d=>{
      const rep = String(d?.archetype_replaces || '').trim();
      if (rep && byId[rep]) replaced.add(rep);
    });
  }
  const keep = [];
  unlocked.forEach(r=>{
    const id = r.ability_id || r.ability || r.id;
    if (!id || replaced.has(id)) return;
    if (!keep.includes(id)) keep.push(id);
  });
  return keep;
}

async function computeRankedUnlockedIds(sourceDoc, effRank){
  if (!sourceDoc) return [];
  const ranks = sourceDoc.ranks || [];
  const unlocked = ranks.filter(r=> Number(r.rank||0) <= effRank);
  const byId = {};
  unlocked.forEach(r=>{
    const id = r.ability_id || r.ability || r.id;
    if (id) byId[id] = r;
  });
  const replaced = new Set();
  unlocked.forEach(r=>{
    const rep = r.replaces_id || r.replaces || '';
    if (rep && byId[rep]) replaced.add(rep);
  });
  const ids = Object.keys(byId);
  if (ids.length){
    const docs = await fetchAbilitiesByIds(ids);
    docs.forEach(d=>{
      const rep = String(d?.archetype_replaces || '').trim();
      if (rep && byId[rep]) replaced.add(rep);
    });
  }
  const keep = [];
  unlocked.forEach(r=>{
    const id = r.ability_id || r.ability || r.id;
    if (!id || replaced.has(id)) return;
    if (!keep.includes(id)) keep.push(id);
  });
  return keep;
}

function linkedSkillRank(sourceDoc){
  const skills = sourceDoc?.linked_skills || [];
  let best = 0;
  let bestSkill = '';
  for (const s of skills){
    const ck = charKeyForSkillName(s);
    if (!ck) continue;
    const adj = skillAdjTotal(ck, s);
    const val = numOr(adj.total, 0);
    if (val > best){
      best = val;
      bestSkill = s;
    }
  }
  const maxRank = Array.isArray(sourceDoc?.ranks) ? sourceDoc.ranks.length : 0;
  const thresholds = [6, 8, 10, 12, 14, 16];
  const total = Math.floor(best);
  let rank = 0;
  for (let i = 0; i < thresholds.length; i++){
    if (total >= thresholds[i]) rank = i + 1;
  }
  rank = Math.min(rank, maxRank);
  return { rank, bestSkill, bestValue: best };
}

function prereqErrorsForRules(rules, stats){
  const out = [];
  if (!rules || !stats) return out;
  const charKeys = ["reflex","dexterity","body","wisdom","presence","magic","willpower","tech"];
  const modMap = {};
  charKeys.forEach(k=>{
    const invest = investVal(stats?.[k]?.invest, 0);
    modMap[k] = totalFromInvest(invest);
  });
  if (rules.mag_highest){
    const mag = modMap.magic;
    const others = charKeys.filter(k=>k!=="magic").map(k=>modMap[k]);
    if (!others.every(v=> mag >= v)) out.push("Magic is not highest.");
  }
  if (rules.wis_half_mag){
    const wis = modMap.wisdom;
    const mag = modMap.magic;
    if (wis < (mag/2)) out.push("Wisdom below half of Magic.");
  }
  const orderRules = rules.char_order || [];
  if (orderRules.length){
    const vals = charKeys.map(k=>({ key:k, val:modMap[k] }));
    vals.sort((a,b)=> (b.val - a.val) || a.key.localeCompare(b.key));
    for (const r of orderRules){
      const key = r.key;
      const pos = Number(r.position || 0);
      if (!key || !modMap[key] || ![1,2,3].includes(pos)) continue;
      const myVal = modMap[key];
      const higher = vals.filter(v=> v.val > myVal).length;
      if (pos === 1 && higher !== 0) out.push(`${key} not highest.`);
      if (pos === 2 && higher > 1) out.push(`${key} not top 2.`);
      if (pos === 3 && higher > 2) out.push(`${key} not top 3.`);
    }
  }
  const anyRules = rules.char_order_any || [];
  if (anyRules.length){
    const vals = charKeys.map(k=>({ key:k, val:modMap[k] }));
    vals.sort((a,b)=> (b.val - a.val) || a.key.localeCompare(b.key));
    anyRules.forEach(r=>{
      const pos = Number(r.position || 0);
      const keys = Array.isArray(r.keys) ? r.keys : [];
      if (![1,2,3].includes(pos) || !keys.length) return;
      let ok = false;
      keys.forEach(k=>{
        if (!modMap[k]) return;
        const myVal = modMap[k];
        const higher = vals.filter(v=> v.val > myVal).length;
        if (pos === 1 && higher === 0) ok = true;
        if (pos === 2 && higher <= 1) ok = true;
        if (pos === 3 && higher <= 2) ok = true;
      });
      if (!ok) out.push(`One of ${keys.join(", ")} must be top ${pos}.`);
    });
  }
  const minRules = rules.char_min || {};
  Object.entries(minRules).forEach(([k, v])=>{
    const req = Number(v);
    if (!Number.isFinite(req)) return;
    if ((modMap[k] ?? 0) < req) out.push(`${k} below minimum ${req}.`);
  });
  return out;
}

async function refreshArchetypeAbilities(){
  if (!CHAR?.archetype_id){
    CHAR.archetype_rank = _archetypeRankForLevel(Math.max(1, Number(CHAR.level)||1));
    CHAR.computed_archetype_abilities = [];
    COMPUTED_ARC_ABILITIES = [];
    await renderArchetypePanel();
    await refreshExpertiseAbilities();
    await refreshDivineManifestationAbilities();
    return;
  }
  const arc = ARCHETYPES.find(a=>a.id===CHAR.archetype_id);
  if (!arc){
    CHAR.computed_archetype_abilities = [];
    COMPUTED_ARC_ABILITIES = [];
    await renderArchetypePanel();
    await refreshExpertiseAbilities();
    await refreshDivineManifestationAbilities();
    return;
  }
  CHAR.archetype_rank = _archetypeRankForLevel(Math.max(1, Number(CHAR.level)||1));
  const ids = await computeArchetypeUnlockedIds(arc, CHAR.level);
  CHAR.computed_archetype_abilities = ids;
  COMPUTED_ARC_ABILITIES = ids.slice();
  await renderArchetypePanel();
  await refreshExpertiseAbilities();
  await refreshDivineManifestationAbilities();
}

  async function renderArchetypePanel(){
    if (!CHAR?.archetype_id){
      ARC_ASSIGNED = [];
      recomputePassiveAgg();
      renderAbilitiesTab();
      renderStatistics();
      updateDerived();
      renderSublimations();
      arcSummaryEl.textContent = 'No archetype linked.';
      if (arcStatusEl){
        arcStatusEl.textContent = '';
        arcStatusEl.style.color = '';
      }
      if (arcDescEl){
        arcDescEl.innerHTML = '';
        arcDescEl.style.display = 'none';
      }
      arcAbilitiesEl.innerHTML = '<div class="muted">Select an archetype.</div>';
      return;
    }
    const arc = ARCHETYPES.find(a=>a.id===CHAR.archetype_id);
    const rank = CHAR.archetype_rank || _archetype_rank_for_level(Number(CHAR.level||1));
    arcSummaryEl.textContent = `${arc?.name || CHAR.archetype_id} - Rank: ${rank}`;
    if (arcStatusEl){
      const errs = prereqErrorsForRules(arc?.prereq_rules || {}, CHAR?.stats || {});
      if (errs.length){
        arcStatusEl.textContent = `Prereq not met: ${errs.join(' ')}`;
        arcStatusEl.style.color = '#f66';
      }else{
        arcStatusEl.textContent = '';
        arcStatusEl.style.color = '';
      }
    }
    if (arcDescEl){
      const arcDesc = (arc?.description_html || arc?.description || "").toString().trim();
      arcDescEl.innerHTML = arcDesc;
      arcDescEl.style.display = arcDesc ? '' : 'none';
    }
    COMPUTED_ARC_ABILITIES = (CHAR.computed_archetype_abilities || []).slice();
    if (!COMPUTED_ARC_ABILITIES.length){
      ARC_ASSIGNED = [];
      recomputePassiveAgg();
      renderAbilitiesTab();
      renderStatistics();
      updateDerived();
      renderSublimations();
      arcAbilitiesEl.innerHTML = '<div class="muted">No unlocked abilities yet.</div>';
      return;
    }
    const docs = await fetchAbilitiesByIds(COMPUTED_ARC_ABILITIES);
    ARC_ASSIGNED = docs.slice();
    const count = COMPUTED_ARC_ABILITIES.length;
    arcAbilitiesEl.innerHTML = `<div class="muted">${count} ${count === 1 ? 'ability' : 'abilities'} shown under Passive / Active.</div>`;
    renderAbilitiesTab();
    recomputePassiveAgg();
    renderStatistics();
    updateDerived();
    renderSublimations();
  }

async function refreshExpertiseAbilities(){
  const ids = (CHAR?.expertise_ids || []).map(x=> String(x||'').trim()).filter(Boolean);
  if (!expAbilitiesEl) return;
  if (!ids.length){
    if (expPanelEl) expPanelEl.style.display = 'none';
    EXP_ASSIGNED = [];
    COMPUTED_EXP_ABILITIES = [];
    if (expSummaryEl) expSummaryEl.textContent = 'No expertise linked.';
    expAbilitiesEl.innerHTML = '<div class="muted">No expertise selected.</div>';
    updateExpertiseCounters();
    renderAbilitiesTab();
    recomputePassiveAgg();
    renderStatistics();
    updateDerived();
    renderSublimations();
    return;
  }
  if (expPanelEl) expPanelEl.style.display = '';
  const entries = EXPERTISES.filter(e=> ids.includes(String(e.id)));
  const meta = [];
  let allIds = [];
  for (const entry of entries){
    const rankInfo = linkedSkillRank(entry);
    const unlocked = await computeRankedUnlockedIds(entry, rankInfo.rank);
    meta.push({ entry, rankInfo, unlocked });
    allIds = allIds.concat(unlocked);
  }
  const uniqueIds = Array.from(new Set(allIds));
  const docs = uniqueIds.length ? await fetchAbilitiesByIds(uniqueIds) : [];
  EXP_ASSIGNED = docs.slice();
  COMPUTED_EXP_ABILITIES = uniqueIds.slice();
  renderExpertisePanel(meta, docs);
  renderAbilitiesTab();
  recomputePassiveAgg();
  renderStatistics();
  updateDerived();
  renderSublimations();
}

async function refreshDivineManifestationAbilities(){
  const ids = (CHAR?.divine_manifestation_ids || []).map(x=> String(x||'').trim()).filter(Boolean);
  if (!dimaAbilitiesEl) return;
  if (!ids.length){
    if (dimaPanelEl) dimaPanelEl.style.display = 'none';
    DIMA_ASSIGNED = [];
    COMPUTED_DIMA_ABILITIES = [];
    if (dimaSummaryEl) dimaSummaryEl.textContent = 'No divine manifestation linked.';
    dimaAbilitiesEl.innerHTML = '<div class="muted">No divine manifestation selected.</div>';
    updateExpertiseCounters();
    renderAbilitiesTab();
    recomputePassiveAgg();
    renderStatistics();
    updateDerived();
    renderSublimations();
    return;
  }
  if (dimaPanelEl) dimaPanelEl.style.display = '';
  const entries = DIVINE_MANIFESTATIONS.filter(e=> ids.includes(String(e.id)));
  const meta = [];
  let allIds = [];
  for (const entry of entries){
    const rankInfo = linkedSkillRank(entry);
    const unlocked = await computeRankedUnlockedIds(entry, rankInfo.rank);
    meta.push({ entry, rankInfo, unlocked });
    allIds = allIds.concat(unlocked);
  }
  const uniqueIds = Array.from(new Set(allIds));
  const docs = uniqueIds.length ? await fetchAbilitiesByIds(uniqueIds) : [];
  DIMA_ASSIGNED = docs.slice();
  COMPUTED_DIMA_ABILITIES = uniqueIds.slice();
  renderDivineManifestationPanel(meta, docs);
  renderAbilitiesTab();
  recomputePassiveAgg();
  renderStatistics();
  updateDerived();
  renderSublimations();
}

function renderExpertisePanel(meta, docs){
  if (!expAbilitiesEl) return;
  expAbilitiesEl.innerHTML = '';
  if (expSummaryEl){
    expSummaryEl.textContent = meta.length ? `Linked: ${meta.length}` : 'No expertise linked.';
    expSummaryEl.style.color = '';
  }
  if (!meta.length){
    expAbilitiesEl.innerHTML = '<div class="muted">No expertise selected.</div>';
    return;
  }
  if (expSummaryEl){
    const warn = [];
    meta.forEach(item=>{
      const entry = item.entry || {};
      const errs = prereqErrorsForRules(entry.prereq_rules || {}, CHAR?.stats || {});
      if (errs.length){
        warn.push(`${entry.name || entry.id}: ${errs.join(' ')}`);
      }
    });
    if (warn.length){
      expSummaryEl.textContent = `Linked: ${meta.length} - Prereq not met: ${warn.join(' | ')}`;
      expSummaryEl.style.color = '#f66';
    }
  }

  meta.forEach(item=>{
    const entry = item.entry || {};
    const rank = item.rankInfo?.rank ?? 0;
    const bestSkill = item.rankInfo?.bestSkill || '';
    const prereqErrors = prereqErrorsForRules(entry.prereq_rules || {}, CHAR?.stats || {});
    const prereqNote = prereqErrors.length ? `Prereq not met: ${prereqErrors.join(' ')}` : '';
    const unlockedCount = (item.unlocked || []).length;
    const unlockedNote = unlockedCount
      ? `${unlockedCount} ${unlockedCount === 1 ? 'ability' : 'abilities'} shown under Passive / Active.`
      : 'No unlocked abilities yet.';
    const div = document.createElement('div');
    div.className = 'abi-item abi-block';
    const entryKey = entryColorKey('expertise', entry);
    const entryTitle = entry.name || entry.id || 'Expertise';
    div.innerHTML = `
      <div style="display:grid; gap:6px; margin-bottom:8px;">
        <div class="row" style="gap:8px; align-items:center; justify-content:space-between;">
          <div class="row" style="gap:8px; align-items:center;">
            <strong class="title-color-target">${entryTitle}</strong>
            <span class="tag">Rank ${rank}</span>
          </div>
          <button class="btn small exp-remove" data-id="${entry.id}">X</button>
        </div>
        ${bestSkill ? `<div class="muted" style="font-size:.85rem">Linked skill: ${bestSkill}</div>` : ''}
        ${prereqNote ? `<div class="prereq-warn">${prereqNote}</div>` : ''}
        <div class="muted" style="font-size:.85rem">${unlockedNote}</div>
      </div>
    `;
    registerTitleColorTarget(div.querySelector('.title-color-target'), entryKey, entryTitle);
    div.querySelector('.exp-remove')?.addEventListener('click', ()=>{
      removeExpertiseById(entry.id);
    });
    expAbilitiesEl.appendChild(div);
  });
}

function renderDivineManifestationPanel(meta, docs){
  if (!dimaAbilitiesEl) return;
  dimaAbilitiesEl.innerHTML = '';
  if (dimaSummaryEl){
    dimaSummaryEl.textContent = meta.length ? `Linked: ${meta.length}` : 'No divine manifestation linked.';
    dimaSummaryEl.style.color = '';
  }
  if (!meta.length){
    dimaAbilitiesEl.innerHTML = '<div class="muted">No divine manifestation selected.</div>';
    return;
  }
  if (dimaSummaryEl){
    const warn = [];
    meta.forEach(item=>{
      const entry = item.entry || {};
      const errs = prereqErrorsForRules(entry.prereq_rules || {}, CHAR?.stats || {});
      if (errs.length){
        warn.push(`${entry.name || entry.id}: ${errs.join(' ')}`);
      }
    });
    if (warn.length){
      dimaSummaryEl.textContent = `Linked: ${meta.length} - Prereq not met: ${warn.join(' | ')}`;
      dimaSummaryEl.style.color = '#f66';
    }
  }

  meta.forEach(item=>{
    const entry = item.entry || {};
    const rank = item.rankInfo?.rank ?? 0;
    const bestSkill = item.rankInfo?.bestSkill || '';
    const prereqErrors = prereqErrorsForRules(entry.prereq_rules || {}, CHAR?.stats || {});
    const prereqNote = prereqErrors.length ? `Prereq not met: ${prereqErrors.join(' ')}` : '';
    const unlockedCount = (item.unlocked || []).length;
    const unlockedNote = unlockedCount
      ? `${unlockedCount} ${unlockedCount === 1 ? 'ability' : 'abilities'} shown under Passive / Active.`
      : 'No unlocked abilities yet.';
    const div = document.createElement('div');
    div.className = 'abi-item abi-block';
    const entryKey = entryColorKey('dima', entry);
    const entryTitle = entry.name || entry.id || 'Divine Manifestation';
    div.innerHTML = `
      <div style="display:grid; gap:6px; margin-bottom:8px;">
        <div class="row" style="gap:8px; align-items:center; justify-content:space-between;">
          <div class="row" style="gap:8px; align-items:center;">
            <strong class="title-color-target">${entryTitle}</strong>
            <span class="tag">Rank ${rank}</span>
          </div>
          <button class="btn small dima-remove" data-id="${entry.id}">X</button>
        </div>
        ${bestSkill ? `<div class="muted" style="font-size:.85rem">Linked skill: ${bestSkill}</div>` : ''}
        ${prereqNote ? `<div class="prereq-warn">${prereqNote}</div>` : ''}
        <div class="muted" style="font-size:.85rem">${unlockedNote}</div>
      </div>
    `;
    registerTitleColorTarget(div.querySelector('.title-color-target'), entryKey, entryTitle);
    div.querySelector('.dima-remove')?.addEventListener('click', ()=>{
      removeDivineManifestationById(entry.id);
    });
    dimaAbilitiesEl.appendChild(div);
  });
}

function removeExpertiseById(id){
  const target = String(id||'').trim();
  if (!target) return;
  CHAR.expertise_ids = (CHAR.expertise_ids || []).map(String).filter(x=> x !== target);
  updateExpertiseCounters();
  refreshExpertiseAbilities();
  queueSave();
}

function removeDivineManifestationById(id){
  const target = String(id||'').trim();
  if (!target) return;
  CHAR.divine_manifestation_ids = (CHAR.divine_manifestation_ids || []).map(String).filter(x=> x !== target);
  updateExpertiseCounters();
  refreshDivineManifestationAbilities();
  queueSave();
}

async function loadSpellListById(id){
  if (!id){
    LINKED_SPELL_LIST = null;
    SELECTED_SPELL_LIST_ID = '';
    if (CHAR) CHAR.spell_list_id = '';
    slStatusEl.textContent = '';
    await reloadSpellListData();
    queueSave();
    return;
  }
  slStatusEl.textContent = 'Loading spell list...';
  try{
    const res = await api('/spell_lists/' + encodeURIComponent(id));
    if (res.list){
      LINKED_SPELL_LIST = res.list;
      SELECTED_SPELL_LIST_ID = LINKED_SPELL_LIST.id || id;
      if (CHAR) CHAR.spell_list_id = SELECTED_SPELL_LIST_ID;
      slStatusEl.textContent = 'Spell list loaded';
      await reloadSpellListData();
      queueSave();
    }else{
      throw new Error('Not found');
    }
  }catch(e){
    slStatusEl.textContent = 'Load failed: ' + e.message;
  }
}

async function duplicateAndLinkSpellList(){
  if (!SELECTED_SPELL_LIST_ID){
    slStatusEl.textContent = 'Select a spell list first.';
    return;
  }
  const charName = nameEl.value?.trim() || 'Character';
  const listName = `${charName}'s Spell List`;
  slStatusEl.textContent = 'Duplicating...';
  try{
    const res = await api('/spell_lists/' + encodeURIComponent(SELECTED_SPELL_LIST_ID) + '/duplicate', {
      method:'POST',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ name: listName })
    });
    if (res.list){
      LINKED_SPELL_LIST = res.list;
      SELECTED_SPELL_LIST_ID = res.list.id;
      if (CHAR) CHAR.spell_list_id = SELECTED_SPELL_LIST_ID;
      await loadSpellListsList();
      await reloadSpellListData();
      slStatusEl.textContent = 'Duplicated and linked as ' + SELECTED_SPELL_LIST_ID;
      queueSave();
    }
  }catch(e){
    slStatusEl.textContent = 'Duplicate failed: ' + e.message;
  }
}

async function createAndLinkSpellList(){
  const charName = nameEl.value?.trim() || 'Character';
  const listName = `${charName}'s Spell List`;
  slStatusEl.textContent = 'Creating spell list...';
  try{
    const res = await api('/spell_lists', {
      method:'POST',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ name: listName })
    });
    const list = res.list || res.spell_list || res;
    SELECTED_SPELL_LIST_ID = list.id;
    LINKED_SPELL_LIST = list;
    CHAR.spell_list_id = SELECTED_SPELL_LIST_ID;
    await loadSpellListsList();
    await reloadSpellListData();
    slStatusEl.textContent = 'Created and linked.';
    queueSave();
  }catch(e){
    slStatusEl.textContent = 'Create failed: ' + e.message;
    alert(e.message);
  }
}

function charBaseMod(key){
  const invest = investVal(CHAR.stats?.[key]?.invest, 0);
  return modFromTotal(totalFromInvest(invest));
}
function charAdjMod(key){
  const base = charBaseMod(key);
  const { value, notes } = applyOps(base, PASSIVE.char[key]);
  return { mod:value, notes };
}
function skillBaseTotal(key, skill){
  // Intensities are stored under stats.intensities instead of magic.skills
  const lowerSkill = String(skill || '').toLowerCase();
  const isIntensity = key === 'magic' && INTENSITIES.some(n => n.toLowerCase() === lowerSkill);
  const inv = isIntensity
    ? investVal((CHAR.stats?.intensities || {})[skill] ?? (CHAR.stats?.intensities || {})[INTENSITIES.find(n => n.toLowerCase() === lowerSkill)], 0)
    : investVal(CHAR.stats?.[key]?.skills?.[skill], 0);
  return inv + charBaseMod(key);
}
function skillAdjTotal(key, skill){
  const base = skillBaseTotal(key, skill);
  const agg = PASSIVE.skill[`${key}|${skill}`];
  const { value, notes } = applyOps(base, agg);
  return { total:value, notes };
}
function intensityBaseValue(name){
  const invested = investVal((CHAR.stats?.intensities || {})[name], 0);
  if (!invested) return null;
  return skillAdjTotal('magic', name).total;
}
function intensityIdForValue(value){
  if (value == null) return '--';
  const base = Number(value);
  if (!Number.isFinite(base) || base <= 0) return '--';
  if (base <= 7) return '1d4';
  if (base <= 11) return '1d6';
  if (base <= 15) return '1d8';
  if (base <= 17) return '1d10';
  return '1d12';
}
function intensityTooltip(notes, idVal){
  const parts = [];
  if (Array.isArray(notes) && notes.length) parts.push(...notes);
  parts.push(`ID ${idVal}`);
  return parts.join('\n');
}
function intensityDieForNature(nature){
  const name = INTENSITIES.find(n=> lc(n) === lc(nature || ''));
  if (!name) return null;
  const baseVal = intensityBaseValue(name);
  const label = intensityIdForValue(baseVal);
  if (label === '--') return { name, label, die:'' };
  const m = String(label).match(/1d(\d+)/i);
  if (!m) return null;
  return { name, label, die:`d${m[1]}` };
}

function renderStatistics(){
  gridEl.innerHTML = '';
  for (const c of CHARACS){
    const rec = (CHAR.stats && CHAR.stats[c.key]) || { invest:0, skills:{} };
    const investedChar = investVal(rec.invest, 0);
    const total = totalFromInvest(investedChar);
    const modInfo = charAdjMod(c.key);

    const details = document.createElement('details'); details.className='panel'; details.open = true;
    details.classList.add(c.skills.length >= 5 ? 'skill-5' : 'skill-4');
    const sum = document.createElement('summary'); sum.className='hdr';
    sum.innerHTML = `
      <strong>${c.name}</strong>
      <span class="pill">${c.code}</span>
      <span class="charac-badge mod-toggle" data-target="mods-char-${c.key}" title="${modInfo.notes.join('\n')}">[ <span class="total" id="${c.key}-total">${total}</span> | <span id="${c.key}-mod">${modInfo.mod>=0? '+'+modInfo.mod : modInfo.mod}</span> ]</span>
      <span class="grow"></span>
      <span class="k">Invested</span>
      <input type="number" class="num" min="0" id="${c.key}-invest" value="${investedChar}">
    `;
    details.appendChild(sum);

    const body = document.createElement('div'); body.className='panel-body';
    const skills = document.createElement('div'); skills.className='skills';

    for (const s of c.skills){
      const invested = investVal((rec.skills||{})[s], 0);
      const adj = skillAdjTotal(c.key, s);
      const investId = skillId(c.key, s, 'invest');
      const totalId = skillId(c.key, s, 'total');
      const line = document.createElement('div'); line.className='skill-line';
      const charLabel = c.name || c.label || c.key;
      const skillLabel = invEscapeHtml(s);
      line.innerHTML = `
        <button class="roll-link skill-name" data-skill-key="${invEscapeHtml(c.key)}" data-skill-name="${skillLabel}" data-char-name="${invEscapeHtml(charLabel)}">${skillLabel}</button>
        <input type="number" class="num" min="0" id="${investId}" value="${invested}">
        <div class="skill-total badge mod-toggle" data-target="mods-${totalId}" id="${totalId}" title="${adj.notes.join('\n')}">${adj.total>=0? '+'+adj.total : adj.total}</div>
      `;
      const noteList = setNotesList(`mods-${totalId}`, adj.notes);
      line.appendChild(noteList);
      skills.appendChild(line);
      line.querySelector('.skill-name')?.addEventListener('click', (e)=>{
        if (e.detail > 1) return;
        openSkillRoll(c.key, charLabel, s);
      });
    }

    const charNotesList = setNotesList(`mods-char-${c.key}`, modInfo.notes);
    body.appendChild(charNotesList);
    body.appendChild(skills);
    details.appendChild(body);
    gridEl.appendChild(details);
  }

  // Intensities (scale with MAGIC)
  const intPanel = document.createElement('details'); intPanel.className='panel'; intPanel.open = true;
  intPanel.classList.add('intensities-panel');
  const intSummary = document.createElement('summary'); intSummary.className = 'hdr';
  intSummary.innerHTML = `<strong>Intensities</strong><span class="muted">(scale on MAGIC)</span>`;
  intPanel.appendChild(intSummary);
  const intBody = document.createElement('div'); intBody.className = 'panel-body';
  const intGrid = document.createElement('div'); intGrid.className = 'skills intensities-grid';
  intGrid.id = 'intensities-grid';
    INTENSITIES.forEach(n=>{
      const invested = investVal((CHAR.stats.intensities||{})[n], 0);
      const adj = skillAdjTotal('magic', n);
      const baseVal = intensityBaseValue(n);
      const idVal = intensityIdForValue(baseVal);
      const investId = `intensity-${n}-invest`;
      const totalId = `intensity-${n}-total`;
      const line = document.createElement('div'); line.className = 'intensity-line';
      line.innerHTML = `
        <div class="k">${n}</div>
        <input type="number" class="num" min="0" id="${investId}" value="${invested}">
        <div class="skill-total badge mod-toggle" data-target="mods-${totalId}" id="${totalId}" title="${intensityTooltip(adj.notes, idVal)}">${baseVal == null ? '--' : (adj.total>=0? '+'+adj.total : adj.total)}</div>
      `;
    line.appendChild(setNotesList(`mods-${totalId}`, adj.notes));
    intGrid.appendChild(line);
  });
  intBody.appendChild(intGrid);
  intPanel.appendChild(intBody);
  gridEl.appendChild(intPanel);

  // Intensity listeners (once)
  INTENSITIES.forEach(n=>{
    const input = document.getElementById(`intensity-${n}-invest`);
    input.addEventListener('input', ()=>{
      const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
      const cap = skillMaxForLevel(lvl);
      const pool = effectiveSkillPointPool(lvl);
      const currentVal = investVal(CHAR.stats.intensities?.[n], 0);
      const totalOther = totalSkillInvest() - currentVal;
      const desired = Math.max(0, Math.floor(investVal(input.value, 0)));
      const allowed = Math.max(0, pool - totalOther);
      const val = OVERRIDE_ENABLED ? desired : Math.min(desired, cap, allowed);
      if (!OVERRIDE_ENABLED) input.value = val;
      CHAR.stats.intensities[n] = val;
      const adj = skillAdjTotal('magic', n);
      const baseVal = intensityBaseValue(n);
      const totalId = `intensity-${n}-total`;
      const totalEl = document.getElementById(totalId);
      if (totalEl) totalEl.textContent = baseVal == null ? '--' : (adj.total>=0? '+'+adj.total : adj.total);
      if (totalEl) totalEl.title = intensityTooltip(adj.notes, intensityIdForValue(baseVal));
      setNotesList(`mods-${totalId}`, adj.notes);
      updatePointCounters();
      updateDerived();
      renderAddedSchools();
      refreshArchetypeAbilities();
      queueSave();
    });
  });

  // Wire listeners
  for (const c of CHARACS){
    const input = document.getElementById(`${c.key}-invest`);
    input.addEventListener('input', ()=>{
      const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
      const pool = effectiveStatPointPool(lvl);
      const currentVal = investVal(CHAR.stats[c.key].invest, 0);
      const totalOther = totalStatInvest() - currentVal;
      const desired = Math.max(0, Math.floor(investVal(input.value, 0)));
      const allowed = Math.max(0, pool - totalOther);
      const capInvest = statInvestCap(lvl);
      const val = OVERRIDE_ENABLED ? desired : Math.min(desired, allowed, capInvest);
      if (!OVERRIDE_ENABLED && val !== desired) input.value = val;
      CHAR.stats[c.key].invest = val;

      // update characteristic header
      const total = totalFromInvest(val);
      const modInfo = charAdjMod(c.key);
      document.getElementById(`${c.key}-total`).textContent = total;
      document.getElementById(`${c.key}-mod`).textContent = (modInfo.mod>=0? '+'+modInfo.mod : modInfo.mod);
      document.querySelector(`#${c.key}-mod`).parentElement.title = modInfo.notes.join('\\n');
      setNotesList(`mods-char-${c.key}`, modInfo.notes);

      // update skill rows
      for (const s of c.skills){
        const adj = skillAdjTotal(c.key, s);
        const el = document.getElementById(skillId(c.key, s, 'total'));
        el.textContent = (adj.total>=0? '+'+adj.total : adj.total);
        el.title = adj.notes.join('\\n');
        setNotesList(`mods-${skillId(c.key, s, 'total')}`, adj.notes);
      }
      updatePointCounters();
      updateDerived();
      renderAddedSchools();
      refreshArchetypeAbilities();
      queueSave();
    });

    for (const s of c.skills){
      const si = document.getElementById(skillId(c.key, s, 'invest'));
      si.addEventListener('input', ()=>{
        const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
        const cap = skillMaxForLevel(lvl);
        const pool = effectiveSkillPointPool(lvl);
        if (!CHAR.stats[c.key]) CHAR.stats[c.key] = { invest:0, skills:{} };
        if (!CHAR.stats[c.key].skills) CHAR.stats[c.key].skills = {};
        const currentVal = investVal(CHAR.stats[c.key].skills?.[s], 0);
        const totalOther = totalSkillInvest() - currentVal;
        const desired = Math.max(0, Math.floor(investVal(si.value, 0)));
        const allowed = Math.max(0, pool - totalOther);
        const val = OVERRIDE_ENABLED ? desired : Math.min(desired, cap, allowed);
        if (!OVERRIDE_ENABLED && val !== desired) si.value = val;
        CHAR.stats[c.key].skills[s] = val;
        const adj = skillAdjTotal(c.key, s);
        const el = document.getElementById(skillId(c.key, s, 'total'));
        el.textContent = (adj.total>=0? '+'+adj.total : adj.total);
        el.title = adj.notes.join('\\n');
        setNotesList(`mods-${skillId(c.key, s, 'total')}`, adj.notes);
        updatePointCounters();
        updateDerived();
        renderAddedSchools();
        refreshArchetypeAbilities();
        queueSave();
      });
    }
  }
  updatePointCounters();
}
function activeConditionSet(){
  const st = combatState();
  return new Set((st.conditions || []).map(s=> String(s || '').trim()).filter(Boolean));
}
function conditionLevel(prefix){
  const active = activeConditionSet();
  let max = 0;
  active.forEach(id=>{
    if (id.startsWith(prefix)){
      const n = Number(id.replace(prefix, '').replace(/[^0-9]/g, ''));
      if (Number.isFinite(n)) max = Math.max(max, n);
    }
  });
  return max;
}
function getCombatConditionFlags(){
  const active = activeConditionSet();
  return {
    toughened: active.has('toughened'),
    accelerated: active.has('accelerated'),
  };
}
function getCombatRollModifiers(kind, skillName){
  const active = activeConditionSet();
  const out = { mod: 0, adv: null, conds: { jinxed: 0, motivated: 0, reckless: false, meticulous: false } };
  const isDefense = kind === 'defense';
  const isOffense = kind === 'offense';
  if (isDefense){
    if (active.has('stunned')) out.mod -= 2;
    if (active.has('hindered')) out.mod -= 2;
    if (active.has('unbalanced')) out.mod -= 2;
    if (active.has('camouflaged')) out.mod += 1;
  }
  if (isOffense){
    if (active.has('disturbed')) out.mod -= 2;
    if (active.has('hindered')) out.mod -= 2;
    if (active.has('unbalanced')) out.mod -= 2;
  }
  if (active.has('blinded')){
    if (isDefense || isOffense) out.adv = 'dis';
  }
  if (active.has('prone') && isOffense){
    out.adv = 'dis';
  }
  if (skillName && active.has('camouflaged')){
    if (String(skillName).toLowerCase() === 'stealth') out.adv = 'adv';
  }
  out.conds.jinxed = conditionLevel('jinxed-');
  out.conds.motivated = conditionLevel('motivated-');
  out.conds.reckless = active.has('reckless');
  out.conds.meticulous = active.has('meticulous');
  return out;
}

function tensionCapForLevel(lvl){
  const v = Math.max(1, Math.floor(Number(lvl)||1));
  if (v <= 10) return 3;
  if (v <= 20) return 6;
  if (v <= 30) return 9;
  if (v <= 40) return 12;
  if (v <= 50) return 15;
  return 18;
}
function allSkillNames(){
  const set = new Set();
  for (const c of CHARACS){ (c.skills || []).forEach(s=> set.add(String(s))); }
  return Array.from(set).sort((a,b)=> a.localeCompare(b));
}
function safeSetValue(el, val){
  if (!el) return;
  if (document.activeElement === el) return;
  el.value = val;
}

function renderCombatDefenseSkills(){
  const st = combatState();
  const list = (st.defense_skills || []).map(s=> String(s||'').trim()).filter(Boolean);
  if (defSkillSelectEl){
    const current = defSkillSelectEl.value;
    defSkillSelectEl.innerHTML = '';
    list.forEach(skill=>{
      const opt = document.createElement('option');
      opt.value = skill;
      opt.textContent = skill;
      defSkillSelectEl.appendChild(opt);
    });
    if (current && list.includes(current)) defSkillSelectEl.value = current;
  }
  if (defSkillListEl){
    defSkillListEl.innerHTML = '';
    list.forEach(skill=>{
      const pill = document.createElement('span');
      pill.className = 'combat-pill';
      pill.innerHTML = `${invEscapeHtml(skill)} <button data-skill="${invEscapeHtml(skill)}" title="Remove">x</button>`;
      pill.querySelector('button')?.addEventListener('click', ()=>{
        st.defense_skills = (st.defense_skills || []).filter(s=> String(s) !== String(skill));
        renderCombatDefenseSkills();
        queueSave();
      });
      defSkillListEl.appendChild(pill);
    });
  }
  if (defAddSkillEl){
    const names = allSkillNames();
    defAddSkillEl.innerHTML = '<option value="">Select skill...</option>';
    names.forEach(n=>{
      const opt = document.createElement('option');
      opt.value = n;
      opt.textContent = n;
      defAddSkillEl.appendChild(opt);
    });
  }
}

function renderCombatTension(){
  const st = combatState();
  if (st.tension == null) st.tension = 3;
  const cap = tensionCapForLevel(CHAR?.level || 1);
  const inspired = activeConditionSet().has('inspired');
  if (tensionCapEl){
    tensionCapEl.textContent = cap;
    tensionCapEl.title = inspired ? 'Inspired: effective tension +2' : '';
  }
  safeSetValue(tensionValueEl, Math.max(0, Number(st.tension ?? 3)));
  if (tensionStrategyEl && document.activeElement !== tensionStrategyEl){
    tensionStrategyEl.value = st.tension_strategy || 'Offensive';
  }
  if (exhaustedToggleEl && document.activeElement !== exhaustedToggleEl){
    exhaustedToggleEl.checked = !!st.exhausted;
  }
}

function renderCombatEtUsage(){
  if (!combatEtUsedEl) return;
  const st = combatState();
  const abilityIds = new Set((st.active_abilities || []).map(String));
  const spellIds = new Set((st.active_spells || []).map(String));
  let used = 0;
  (collectDisplayAbilities() || []).forEach(a=>{
    const id = String(a?.id || '');
    if (!abilityIds.has(id)) return;
    if (!abilityHasActiveCost(a)) return;
    const costs = a?.active?.costs || {};
    const hpCost = Number(costs.HP || 0);
    if (hpCost) used += Math.ceil(hpCost / 5);
    ['EN','FO','MO','TX'].forEach(k=>{
      const v = Number(costs[k] || 0);
      if (Number.isFinite(v)) used += v;
    });
    if (costs.other_value != null){
      const v = Number(costs.other_value || 0);
      const label = String(costs.other_label || '').trim().toLowerCase().replace(/\s+/g, '');
      if (Number.isFinite(v) && label !== 'ms') used += v;
    }
  });
  (SPELLLIST_SPELLS || []).forEach(sp=>{
    const id = String(sp?.id || '');
    if (!spellIds.has(id)) return;
    if (!spellHasActiveCost(sp)) return;
    const enCost = Number(sp?.en_cost || 0);
    if (Number.isFinite(enCost)) used += enCost;
  });
  const maxEt = numOr(DERIVED_CACHE?.et, 0);
  combatEtUsedEl.textContent = `${used} / ${maxEt}`;
}

function renderCombatActiveAbilities(){
  if (!combatActiveAbilitiesEl) return;
  const st = combatState();
  const activeIds = Array.from(new Set((st.active_abilities || []).map(String).filter(Boolean)));
  combatActiveAbilitiesEl.innerHTML = '';
  if (!activeIds.length){
    combatActiveAbilitiesEl.innerHTML = '<span class="muted">None</span>';
    return;
  }
  const list = collectDisplayAbilities() || [];
  const byId = {};
  list.forEach(a=>{
    const id = String(a?.id || '');
    if (id) byId[id] = a;
  });
  activeIds.forEach(id=>{
    const ability = byId[id];
    const label = ability?.name || ability?.id || id;
    const pill = document.createElement('span');
    pill.className = 'combat-pill';
    pill.textContent = label;
    combatActiveAbilitiesEl.appendChild(pill);
  });
}

function renderCombatActions(){
  if (combatActionsEl){
    combatActionsEl.innerHTML = '';
    SECONDARY_ACTIONS.forEach(action=>{
      const row = document.createElement('div');
      row.className = 'combat-entry';
      row.title = action.effect || '';
      const skillOptions = String(action.attack || '').split(/\s+or\s+|\//i).map(s=> s.trim()).filter(Boolean);
      const pick = skillOptions[0] || '';
      row.innerHTML = `
        <div class="grow">
          <div><strong>${invEscapeHtml(action.name)}</strong></div>
          <div class="meta">Attack: ${invEscapeHtml(action.attack || '--')} | Defense: ${invEscapeHtml(action.defense || '--')}</div>
          <div class="muted">${invEscapeHtml(action.effect || '')}</div>
        </div>
        <div class="combat-actions-row">
          ${skillOptions.length > 1 ? `<select class="sec-skill">${skillOptions.map(s=>`<option>${invEscapeHtml(s)}</option>`).join('')}</select>` : ''}
          <button class="btn small">Roll</button>
        </div>
      `;
      const btn = row.querySelector('button');
      btn?.addEventListener('click', ()=>{
        const pickEl = row.querySelector('.sec-skill');
        const skill = pickEl ? pickEl.value : pick;
        const charKey = charKeyForSkillName(skill);
        const adj = charKey ? skillAdjTotal(charKey, skill).total : 0;
        const cond = getCombatRollModifiers('offense', skill);
        const adv = action.name === 'Detect' ? 'dis' : (cond.adv || 'normal');
        openRollModal({
          title: `${action.name}`,
          subtitle: 'Secondary Action',
          baseLabel: 'Skill value',
          base: adj,
          mod: cond.mod,
          adv,
          autoConds: cond.conds,
          detailsText: `Attack: ${action.attack} | Defense: ${action.defense}`,
          descText: action.effect,
          detailLines: [
            'Type: Passive',
            `Attack: ${action.attack}`,
            `Defense: ${action.defense}`,
            action.effect ? `Effect: ${action.effect}` : ''
          ].filter(Boolean)
        });
      });
      combatActionsEl.appendChild(row);
    });
  }
  if (combatContextActionsEl){
    combatContextActionsEl.innerHTML = '';
    CONTEXTUAL_ACTIONS.forEach(action=>{
      const row = document.createElement('div');
      row.className = 'combat-entry';
      row.title = action.effect || '';
      const isRoll = String(action.name || '').toLowerCase() === 'move aside';
      row.innerHTML = `
        <div class="grow">
          <div><strong>${invEscapeHtml(action.name)}</strong></div>
          <div class="muted">${invEscapeHtml(action.effect || '')}</div>
        </div>
        <button class="btn small">${isRoll ? 'Roll' : 'Info'}</button>
      `;
      row.querySelector('button')?.addEventListener('click', ()=>{
        if (isRoll){
          const skill = 'Athletics';
          const key = charKeyForSkillName(skill);
          const adj = key ? skillAdjTotal(key, skill).total : 0;
          const cond = getCombatRollModifiers('offense', skill);
          openRollModal({
            title: action.name,
            subtitle: 'Contextual Action',
            baseLabel: 'Skill value',
            base: adj,
            mod: cond.mod,
            adv: cond.adv || 'normal',
            autoConds: cond.conds,
            detailsText: 'Athletics vs Athletics',
            descText: action.effect,
            detailLines: [
              'Type: Passive',
              'Athletics vs Athletics',
              action.effect ? `Effect: ${action.effect}` : ''
            ].filter(Boolean)
          });
        }else{
          openRollModal({
            title: action.name,
            subtitle: 'Contextual Action',
            infoOnly: true,
            descText: action.effect,
            detailLines: [
              'Type: Passive',
              action.effect ? `Effect: ${action.effect}` : ''
            ].filter(Boolean)
          });
        }
      });
      combatContextActionsEl.appendChild(row);
    });
  }
  if (combatSpecialActionsEl){
    combatSpecialActionsEl.innerHTML = '';
    const st = combatState();
    const exhausted = st.exhausted;
    const cur = Math.max(0, Number(st.tension || 0));
    SPECIAL_ACTIONS.filter(action=> action.tier <= cur).forEach(action=>{
      const row = document.createElement('div');
      row.className = 'combat-entry';
      row.title = action.effect || '';
      row.innerHTML = `
        <div class="grow">
          <div><strong>${invEscapeHtml(action.name)}</strong> <span class="tag">Tension ${action.tier}</span></div>
          <div class="muted">${invEscapeHtml(action.effect || '')}</div>
        </div>
        <button class="btn small"${exhausted ? ' disabled' : ''}>Use</button>
      `;
      row.querySelector('button')?.addEventListener('click', ()=>{
        if (exhausted) return;
        const st = combatState();
        const cur = Math.max(0, Number(st.tension || 0));
        if (cur < action.tier){
          alert('Not enough Tension for this Special Action.');
          return;
        }
        st.exhausted = true;
        if (!activeConditionSet().has('exhausted')){
          st.conditions = Array.from(new Set([...(st.conditions || []), 'exhausted']));
        }
        renderCombatTension();
        renderCombatConditions();
        renderCombatActions();
        queueSave();
        openRollModal({
          title: action.name,
          subtitle: 'Special Action',
          infoOnly: true,
          detailsText: `Tension ${action.tier}`,
          descText: action.effect,
          detailLines: [
            'Type: Passive',
            `Tension: ${action.tier}`,
            action.effect ? `Effect: ${action.effect}` : ''
          ].filter(Boolean)
        });
      });
      combatSpecialActionsEl.appendChild(row);
    });
  }
}

function renderCombatSpecialAttacks(){
  if (!combatSpecialAttacksEl) return;
  combatSpecialAttacksEl.innerHTML = '';
  SPECIAL_ATTACKS.forEach(atk=>{
    const row = document.createElement('div');
    row.className = 'combat-entry';
    row.innerHTML = `
      <div class="grow">
        <div><strong>${invEscapeHtml(atk.name)}</strong></div>
        <div class="meta">Prereq: ${invEscapeHtml(atk.prereq || 'None')}</div>
        <div class="muted">${invEscapeHtml(atk.effect || '')}</div>
      </div>
      <button class="btn small">Info</button>
    `;
    row.querySelector('button')?.addEventListener('click', ()=>{
      openRollModal({ title: atk.name, subtitle: 'Special Attack', infoOnly:true, descText: atk.effect, detailsText:`Prereq: ${atk.prereq}` });
    });
    combatSpecialAttacksEl.appendChild(row);
  });
}

function normalizeWeaponAttributeList(value){
  if (!value) return [];
  if (Array.isArray(value)){
    return value.flatMap(v=> String(v ?? '').split(','));
  }
  return String(value).split(',');
}
function getWeaponAttributes(it){
  const attrs = [];
  const addAttrs = (val)=>{
    normalizeWeaponAttributeList(val).forEach(a=>{
      const clean = String(a || '').trim();
      if (clean) attrs.push(clean);
    });
  };
  addAttrs(it?.attributes);
  addAttrs(it?.effects);
  const catalog = weaponCatalogLookup(it);
  addAttrs(catalog?.attributes);
  addAttrs(catalog?.effects);
  return Array.from(new Set(attrs));
}
function weaponHasAttribute(it, name){
  const target = String(name || '').toLowerCase();
  return getWeaponAttributes(it).some(a=> String(a || '').toLowerCase() === target);
}
function weaponIsAnimarma(it){
  if (it?.is_animarma) return true;
  const name = String(it?.name || it?.alt_name || '').toLowerCase();
  if (name.includes('animarma')) return true;
  if (weaponHasAttribute(it, 'animarma')) return true;
  const catalog = weaponCatalogLookup(it);
  return !!catalog?.is_animarma;
}
function weaponLinkedNature(it){
  return String(it?.linked_nature || it?.nature || '').trim();
}
function formatNatureLabel(name){
  const clean = String(name || '').trim();
  if (!clean) return '';
  return clean.charAt(0).toUpperCase() + clean.slice(1);
}
function weaponHasBenedictionUpgrade(it){
  const upgrades = Array.isArray(it?.upgrades) ? it.upgrades : [];
  return upgrades.some(u=>{
    const upgId = u?.id || u?.key || u;
    const meta = (window.UPGRADE_META || {})[upgId] || {};
    const token = [
      upgId, u?.key, u?.name, meta?.key, meta?.name
    ].map(v=> String(v || '').toLowerCase()).join(' ');
    return token.includes('benediction') || token.includes('blessing');
  });
}
function ensureWeaponCatalog(){
  if (WEAPON_CATALOG_READY) return Promise.resolve(WEAPON_CATALOG_BY_ID);
  if (WEAPON_CATALOG_PROMISE) return WEAPON_CATALOG_PROMISE;
  WEAPON_CATALOG_PROMISE = fetch('/weapons', { headers: authHeaders() })
    .then(r=> r.json().catch(()=> ({})))
    .then(j=>{
      const list = j.weapons || j.weapon || j.items || j.rows || [];
      WEAPON_CATALOG_BY_ID = {};
      WEAPON_CATALOG_BY_NAME = {};
      (list || []).forEach(w=>{
        const id = String(w?.id ?? '').trim();
        if (id) WEAPON_CATALOG_BY_ID[id] = w;
        const nameKey = String(w?.name || '').trim().toLowerCase();
        if (nameKey) WEAPON_CATALOG_BY_NAME[nameKey] = w;
      });
      WEAPON_CATALOG_READY = true;
      return WEAPON_CATALOG_BY_ID;
    })
    .catch(err=>{
      console.warn('Failed to load weapon catalog', err);
      WEAPON_CATALOG_READY = true;
      return WEAPON_CATALOG_BY_ID;
    });
  return WEAPON_CATALOG_PROMISE;
}
function weaponCatalogLookup(it){
  const id = String(it?.item_id ?? it?.weapon_id ?? it?.catalog_id ?? it?.id ?? '').trim();
  if (id && WEAPON_CATALOG_BY_ID[id]) return WEAPON_CATALOG_BY_ID[id];
  const nameKey = String(it?.name || it?.alt_name || it?.title || '').trim().toLowerCase();
  if (nameKey && WEAPON_CATALOG_BY_NAME[nameKey]) return WEAPON_CATALOG_BY_NAME[nameKey];
  return null;
}
function weaponDamageValue(it){
  const direct = it?.damage ?? it?.dmg ?? it?.details?.damage ?? it?.details?.dmg ?? it?.details?.Damage
    ?? it?.stats?.damage ?? it?.base_damage ?? it?.base?.damage ?? it?.weapon?.damage
    ?? it?.item?.damage ?? it?.catalog?.damage;
  if (direct != null) return String(direct);
  const catalog = weaponCatalogLookup(it);
  const fallback = catalog?.damage ?? catalog?.dmg ?? catalog?.details?.damage ?? catalog?.details?.Damage
    ?? catalog?.stats?.damage ?? catalog?.base_damage ?? catalog?.base?.damage ?? catalog?.weapon?.damage;
  return fallback == null ? '' : String(fallback);
}
function weaponStateKey(it){
  return String(it?.id || it?.name || it?.alt_name || 'weapon');
}
function getWeaponState(it){
  const st = combatState();
  if (!st.weapon_states || typeof st.weapon_states !== 'object') st.weapon_states = {};
  const key = weaponStateKey(it);
  if (!st.weapon_states[key]){
    st.weapon_states[key] = { type: 'simple', special: SPECIAL_ATTACKS[0]?.name || '', offhand: false };
  }
  return st.weapon_states[key];
}
function weaponDamageParts(it){
  const raw = String(weaponDamageValue(it) || '').trim();
  if (!raw) return null;
  const compact = raw.replace(/\s+/g, '');
  const dieMatch = compact.match(/^(\d+)?(d\d+|ID)/i);
  if (!dieMatch) return null;
  const dice = Math.max(1, Number(dieMatch[1] || 1));
  const die = String(dieMatch[2] || '').toUpperCase();
  let rest = compact.slice(dieMatch[0].length);
  if (rest && /^[0-9]/.test(rest)) rest = `+${rest}`;
  const msMatches = Array.from(rest.matchAll(/M\(([^)]+)\)/gi));
  const ms = msMatches.map(m=> String(m[1] || '').trim().toUpperCase()).filter(Boolean);
  rest = rest.replace(/M\([^)]+\)/gi, '');
  const nums = rest.match(/[+-]\d+/g) || [];
  const flat = nums.reduce((sum, token)=> sum + Number(token), 0);
  return { dice, die, flat, ms };
}

function milestoneKeyFromCode(code){
  const map = { REF:'reflex', DEX:'dexterity', BODY:'body', WIS:'wisdom', PRE:'presence', MAG:'magic', WILL:'willpower', TECH:'tech' };
  return map[String(code || '').toUpperCase()] || '';
}
function resolveMilestoneCodes(codes){
  const parts = [];
  let total = 0;
  (codes || []).forEach(code=>{
    const key = milestoneKeyFromCode(code);
    if (!key) return;
    const value = milestone(key);
    parts.push({ code, value });
    total += value;
  });
  return { total, parts };
}
function getWeaponUpgradeBonuses(it){
  let neutral = 0;
  let magic = 0;
  const nature = weaponLinkedNature(it);
  const upgrades = Array.isArray(it?.upgrades) ? it.upgrades : [];
  upgrades.forEach(u=>{
    const upgId = u?.id || u?.key || u;
    const meta = (window.UPGRADE_META || {})[upgId] || {};
    const token = [
      upgId, u?.key, u?.name, meta?.key, meta?.name
    ].map(v=> String(v || '').toLowerCase()).join(' ');
    if (token.includes('lethality')) neutral += 2;
    if (token.includes('benediction') || token.includes('blessing')){
      if (nature) magic += 2;
    }
  });
  return { neutral, magic };
}
function rollDie(sides){
  return Math.floor(Math.random() * sides) + 1;
}
function rollDamageDice(count, die){
  const raw = String(die || '').toLowerCase();
  const sides = raw == 'id' ? 6 : (Number(raw.replace('d','')) || 6);
  const rolls = [];
  for (let i=0; i<count; i++) rolls.push(rollDie(sides));
  const total = rolls.reduce((a,b)=>a+b,0);
  return { rolls, total, sides, label: raw == 'id' ? 'ID' : `d${sides}` };
}

function abilityHasActiveCost(a){
  const active = a?.active || {};
  if (!active.costs_active) return false;
  const costs = active.costs || {};
  const values = [
    costs.HP, costs.EN, costs.FO, costs.MO, costs.TX,
    costs.other_value
  ].map(v=> Number(v || 0));
  return values.some(v=> Number.isFinite(v) && v !== 0);
}
function spellHasActiveCost(sp){
  const direct = sp?.active_cost ?? sp?.active_costs ?? sp?.sustain_cost ?? sp?.sustain ?? sp?.upkeep;
  if (direct != null){
    if (direct === true) return true;
    return Number(direct || 0) !== 0;
  }
  const duration = String(sp?.duration || '').trim().toLowerCase();
  if (duration && !['--','—','instant','instantaneous','0','none'].includes(duration)) return true;
  return false;
}
let ATTACK_MODAL_CTX = null;
function renderAttackSpecialList(selected){
  if (!combatAttackSpecialsEl) return;
  const fallback = SPECIAL_ATTACKS[0]?.name || '';
  const current = SPECIAL_ATTACKS.some(s=> s.name === selected) ? selected : fallback;
  combatAttackSpecialsEl.innerHTML = '';
  SPECIAL_ATTACKS.forEach(atk=>{
    const row = document.createElement('label');
    row.className = 'combat-entry';
    row.title = atk.effect || '';
    row.innerHTML = `
      <input type="radio" name="combat-attack-special" value="${invEscapeHtml(atk.name)}"${atk.name === current ? ' checked' : ''}>
      <div class="grow">
        <div><strong>${invEscapeHtml(atk.name)}</strong></div>
        <div class="meta">Prereq: ${invEscapeHtml(atk.prereq || 'None')}</div>
      </div>
    `;
    combatAttackSpecialsEl.appendChild(row);
  });
}
function getSelectedAttackSpecial(){
  const chosen = combatAttackSpecialsEl?.querySelector('input[name="combat-attack-special"]:checked');
  return chosen ? chosen.value : (SPECIAL_ATTACKS[0]?.name || '');
}
function toggleAttackSpecialVisibility(){
  if (!combatAttackSpecialsEl) return;
  const isSpecial = (combatAttackTypeEl?.value || 'simple') === 'special';
  combatAttackSpecialsEl.style.display = isSpecial ? '' : 'none';
}
function openCombatAttackModal(it){
  if (!combatAttackModal || !combatAttackBackdrop) return;
  const name = it?.alt_name || it?.name || 'Weapon';
  const state = getWeaponState(it);
  ATTACK_MODAL_CTX = { item: it, name };
  if (combatAttackTitleEl) combatAttackTitleEl.textContent = `${name} Attack`;
  if (combatAttackTypeEl) combatAttackTypeEl.value = state.type || 'simple';
  if (combatAttackOffhandEl) combatAttackOffhandEl.checked = !!state.offhand;
  renderAttackSpecialList(state.special);
  toggleAttackSpecialVisibility();
  invToggleModal(combatAttackModal, combatAttackBackdrop, true);
}
function closeCombatAttackModal(){
  invToggleModal(combatAttackModal, combatAttackBackdrop, false);
}
function rollCombatAttack(){
  const ctx = ATTACK_MODAL_CTX;
  if (!ctx?.item) return;
  const it = ctx.item;
  const name = ctx.name || it?.alt_name || it?.name || 'Weapon';
  const state = getWeaponState(it);
  const attackType = combatAttackTypeEl?.value || 'simple';
  const specialName = attackType === 'special' ? getSelectedAttackSpecial() : '';
  const isOffhand = !!combatAttackOffhandEl?.checked;
  const isSpecial = attackType === 'special';
  state.type = attackType;
  state.special = specialName || state.special;
  state.offhand = isOffhand;
  queueSave();
  const skill = it.skill || 'Technicity';
  const charKey = charKeyForSkillName(skill);
  const base = charKey ? skillAdjTotal(charKey, skill).total : 0;
  const cond = getCombatRollModifiers('offense', skill);
  const acuity = weaponHasAttribute(it, 'Acuity') ? 1 : 0;
  const penalty = attackType === 'special'
    ? (isOffhand ? -4 : -2)
    : (isOffhand ? -2 : 0);
  const mod = cond.mod + acuity + penalty;
  const adv = isOffhand ? 'dis' : (cond.adv || 'normal');
  const special = SPECIAL_ATTACKS.find(s=> s.name === specialName);
  const desc = isSpecial ? (special?.effect || '') : SIMPLE_ATTACK_DESC;
  const details = [
    `Weapon: ${name}`,
    `Type: ${isSpecial ? 'Special' : 'Simple'}`,
    isSpecial ? `Special: ${specialName}` : '',
    special?.prereq ? `Prereq: ${special.prereq}` : '',
    acuity ? 'Acuity +1' : '',
    isOffhand ? 'Offhand penalty and disadvantage' : ''
  ].filter(Boolean);
  const detailLines = [
    `Skill: ${skill}`,
    `Weapon: ${name}`,
    `Type: ${isSpecial ? 'Special' : 'Simple'}`,
    isSpecial ? `Special: ${specialName}` : '',
    special?.prereq ? `Prereq: ${special.prereq}` : '',
    isSpecial && desc ? `Effect: ${desc}` : '',
    acuity ? 'Acuity +1' : '',
    isOffhand ? 'Offhand penalty and disadvantage' : ''
  ].filter(Boolean);
  openRollModal({
    title: `${name} Attack`,
    subtitle: `${skill} skill`,
    baseLabel: 'Skill value',
    base,
    mod,
    adv,
    autoConds: cond.conds,
    detailsText: details.join(' | '),
    descText: desc,
    detailLines,
    rollKind: 'skill'
  });
  closeCombatAttackModal();
}
function renderCombatWeapons(){
  if (!combatWeaponsEl) return;
  combatWeaponsEl.innerHTML = '';
  const items = (LINKED_INV?.items || []).filter(it=> String(it?.kind || it?.type || '').toLowerCase() === 'weapon' && it?.equipped !== false);
  if (!items.length){
    combatWeaponsEl.innerHTML = '<div class="muted">No equipped weapons.</div>';
    return;
  }
  const needsCatalog = items.some(it=>{
    const missingDamage = !weaponDamageValue(it);
    const hasAttrs = normalizeWeaponAttributeList(it?.attributes).length || normalizeWeaponAttributeList(it?.effects).length;
    return missingDamage || !hasAttrs;
  });
  if (needsCatalog && !WEAPON_CATALOG_READY && !WEAPON_CATALOG_PROMISE){
    ensureWeaponCatalog().then(()=> renderCombatWeapons());
  }else if (needsCatalog && WEAPON_CATALOG_PROMISE && !WEAPON_CATALOG_READY){
    WEAPON_CATALOG_PROMISE.then(()=> renderCombatWeapons());
  }
  items.forEach(it=>{
    const name = it.alt_name || it.name || 'Weapon';
    const skill = it.skill || 'Technicity';
    const dmg = weaponDamageValue(it) || '--';
    const attrList = getWeaponAttributes(it);
    const attrs = attrList.length ? attrList.join(', ') : 'No properties';
    const isAnimarma = weaponIsAnimarma(it);
    const natureRaw = weaponLinkedNature(it);
    const nature = natureRaw.toLowerCase();
    const natureLabel = formatNatureLabel(natureRaw);
    const subHidden = SUB_HIDDEN || {};
    const derivedNeutral = isAnimarma ? 0 : Number(DERIVED_CACHE?.weapon_neutral || 0);
    const subNeutral = !isAnimarma ? (subHidden.weaponNeutral || 0) : 0;
    const magicBucket = isAnimarma ? (PASSIVE.magic_damage.spell || {}) : (PASSIVE.magic_damage.weapon || {});
    let baseMagic = 0;
    if (nature && magicBucket[nature]){
      baseMagic = applyOps(0, magicBucket[nature]).value || 0;
    }
    const upgradeBonus = getWeaponUpgradeBonuses(it);
    const upgradeNeutral = isAnimarma ? 0 : (upgradeBonus.neutral || 0);
    const upgradeMagic = upgradeBonus.magic || 0;
    const subMagicNatureLabel = formatNatureLabel(subHidden.magicNature);
    const subMagicBonus = isAnimarma ? (subHidden.magicBonus || 0) : 0;
    const magicLabel = natureLabel || 'Magic';
    const mainMagicBonus = baseMagic + upgradeMagic;
    const extraMagicBonus = isAnimarma ? subMagicBonus : 0;
    const neutralBonusTotal = derivedNeutral + subNeutral + upgradeNeutral;
    const extra = [];
    if (neutralBonusTotal) extra.push(`Neutral ${neutralBonusTotal}`);
    if (mainMagicBonus) extra.push(`${magicLabel} ${mainMagicBonus}`);
    if (extraMagicBonus && subMagicNatureLabel) extra.push(`${subMagicNatureLabel} ${extraMagicBonus}`);
    const dmgDisplay = extra.length ? `${dmg} + ${extra.join(' + ')}` : dmg;
    const row = document.createElement('div');
    row.className = 'combat-entry';
    const range = it.range != null ? String(it.range) : '';
    const hands = it.hands != null ? String(it.hands) : '';
    row.innerHTML = `
      <div class="grow">
        <div><strong>${invEscapeHtml(name)}</strong></div>
        <div class="meta">Skill: ${invEscapeHtml(skill)} | Damage: ${invEscapeHtml(dmgDisplay)}${range ? ` | Range: ${invEscapeHtml(range)}` : ''}${hands ? ` | Hands: ${invEscapeHtml(hands)}` : ''}</div>
        <div class="muted">${invEscapeHtml(attrs)}</div>
      </div>
      <div class="combat-actions-row">
        <button class="btn small atk-roll">Attack Roll</button>
        <button class="btn small dmg-roll">Deal Damage</button>
      </div>
    `;
    row.querySelector('.atk-roll')?.addEventListener('click', ()=>{
      openCombatAttackModal(it);
    });
    row.querySelector('.dmg-roll')?.addEventListener('click', ()=>{
      const parts = weaponDamageParts(it);
      const state = getWeaponState(it);
      const offhand = !!state.offhand;
      if (!parts){
        const infoText = extra.length ? `Damage: ${dmg} + ${extra.join(' + ')}` : `Damage: ${dmg}`;
        openRollModal({ title: `${name} Damage`, infoOnly:true, descText: infoText });
        return;
      }
      const msCodes = isAnimarma ? ['MAG'] : parts.ms;
      const msInfo = resolveMilestoneCodes(msCodes);
      const msVal = msInfo.total;
      let die = parts.die;
      let dieLabelOverride = '';
      let magicTypeLabel = magicLabel;
      if (String(parts.die || '').toUpperCase() === 'ID'){
        const idInfo = intensityDieForNature(natureRaw || '');
        if (!idInfo){
          openRollModal({ title: `${name} Damage`, infoOnly:true, descText:'ID requires a linked nature intensity.' });
          return;
        }
        if (!idInfo.die){
          openRollModal({ title: `${name} Damage`, infoOnly:true, descText:`ID is -- for ${idInfo.name} (no intensity investment).` });
          return;
        }
        die = idInfo.die;
        dieLabelOverride = `ID(${idInfo.name}) ${idInfo.label}`;
        if (idInfo.name) magicTypeLabel = idInfo.name;
      }
      const diceRoll = rollDamageDice(parts.dice, die);
      if (dieLabelOverride) diceRoll.label = dieLabelOverride;
      const baseRollTotal = diceRoll.total + parts.flat + msVal;
      const neutralTotalRaw = isAnimarma ? neutralBonusTotal : (baseRollTotal + neutralBonusTotal);
      const mainMagicTotalRaw = isAnimarma ? (baseRollTotal + mainMagicBonus) : mainMagicBonus;
      const extraMagicTotalRaw = extraMagicBonus;
      let neutralTotal = neutralTotalRaw;
      let mainMagicTotal = mainMagicTotalRaw;
      let extraMagicTotal = extraMagicTotalRaw;
      if (offhand){
        neutralTotal = Math.floor(neutralTotal / 2);
        mainMagicTotal = Math.floor(mainMagicTotal / 2);
        extraMagicTotal = Math.floor(extraMagicTotal / 2);
      }
      const entry = document.createElement('div');
      entry.className = 'roll-entry';
      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = `${name} Damage`;
      entry.appendChild(title);
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = new Date().toLocaleTimeString();
      entry.appendChild(meta);
      const msBreak = msInfo.parts.length
        ? msInfo.parts.map(p=> `M(${p.code}) ${p.value >= 0 ? '+' : ''}${p.value}`).join(' + ')
        : '';
      const flatBreak = parts.flat ? `${parts.flat >= 0 ? '+' : ''}${parts.flat}` : '';
      const coreBreak = [
        `${parts.dice}${diceRoll.label} (${diceRoll.rolls.join(' + ')} = ${diceRoll.total})`,
        flatBreak,
        msBreak
      ].filter(Boolean).join(' + ');
      const neutralParts = [];
      if (derivedNeutral) neutralParts.push(`Neutral ${derivedNeutral}`);
      if (subNeutral) neutralParts.push(`Lethality (sub) ${subNeutral}`);
      if (upgradeNeutral) neutralParts.push(`Lethality (upg) ${upgradeNeutral}`);
      const neutralBreak = neutralParts.length ? (neutralParts.length > 1 ? neutralParts.join(' + ') : neutralParts[0]) : '';
      const mainMagicParts = [];
      if (baseMagic) mainMagicParts.push(`${magicTypeLabel} ${baseMagic}`);
      if (upgradeMagic) mainMagicParts.push(`Benediction (upg) ${upgradeMagic}`);
      const mainMagicBreak = mainMagicParts.length ? (mainMagicParts.length > 1 ? mainMagicParts.join(' + ') : mainMagicParts[0]) : '';
      const extraMagicBreak = (extraMagicBonus && subMagicNatureLabel) ? `Benediction (sub) ${extraMagicBonus}` : '';
      const neutralFormulaParts = [];
      const mainMagicFormulaParts = [];
      if (isAnimarma){
        if (coreBreak) mainMagicFormulaParts.push(coreBreak);
      }else{
        if (coreBreak) neutralFormulaParts.push(coreBreak);
      }
      if (neutralBreak) neutralFormulaParts.push(neutralBreak);
      if (mainMagicBreak) mainMagicFormulaParts.push(mainMagicBreak);
      const neutralFormula = neutralFormulaParts.join(' + ');
      const mainMagicFormula = mainMagicFormulaParts.join(' + ');
      const segments = [];
      if (neutralTotal){
        const neutralDetail = neutralFormula ? `${neutralFormula}${offhand ? '; halved' : ''}` : (offhand ? 'halved' : '');
        segments.push(`Neutral ${neutralTotal}${neutralDetail ? ` (${neutralDetail})` : ''}`);
      }
      if (mainMagicTotal){
        const magicDetail = mainMagicFormula ? `${mainMagicFormula}${offhand ? '; halved' : ''}` : (offhand ? 'halved' : '');
        segments.push(`${magicTypeLabel} ${mainMagicTotal}${magicDetail ? ` (${magicDetail})` : ''}`);
      }
      if (extraMagicTotal && subMagicNatureLabel){
        const extraDetail = extraMagicBreak ? `${extraMagicBreak}${offhand ? '; halved' : ''}` : (offhand ? 'halved' : '');
        segments.push(`${subMagicNatureLabel} ${extraMagicTotal}${extraDetail ? ` (${extraDetail})` : ''}`);
      }
      if (!segments.length){
        segments.push('Neutral 0');
      }
      const line = document.createElement('div');
      line.textContent = `Roll: ${segments.join(' | ')}`;
      entry.appendChild(line);
      appendRollLog(entry);
    });
    combatWeaponsEl.appendChild(row);
  });
}

function renderCombatAbilityList(){
  if (!combatAbilityListEl) return;
  const st = combatState();
  const activeSet = new Set((st.active_abilities || []).map(String));
  const search = String(combatAbilitySearchEl?.value || '').trim().toLowerCase();
  const list = (collectDisplayAbilities() || []).filter(a=> String(a?.type || '').toLowerCase() === 'active');
  const validIds = new Set(list.map(a=> String(a?.id || '')));
  const eligibleIds = new Set(list.filter(abilityHasActiveCost).map(a=> String(a?.id || '')));
  Array.from(activeSet).forEach(id=>{
    if (!validIds.has(id) || !eligibleIds.has(id)) activeSet.delete(id);
  });
  st.active_abilities = Array.from(activeSet);
  combatAbilityListEl.innerHTML = '';
  if (!list.length){
    combatAbilityListEl.innerHTML = '<div class="muted">No active abilities.</div>';
    return;
  }
  let rendered = 0;
  list.forEach(a=>{
    const name = a?.name || a?.id || 'Ability';
    if (search && !name.toLowerCase().includes(search)) return;
    rendered += 1;
    const cost = abilityCostText(a);
    const id = String(a?.id || '');
    const canStayActive = eligibleIds.has(id);
    const isActive = activeSet.has(id);
    const row = document.createElement('div');
    row.className = 'combat-entry';
    row.innerHTML = `
      <div class="grow">
        <div><strong>${invEscapeHtml(name)}</strong>${isActive ? ' <span class="tag">Active</span>' : ''}</div>
        ${cost ? `<div class="muted">Cost: ${invEscapeHtml(cost)}</div>` : ''}
      </div>
      <div class="combat-actions-row">
        ${isActive ? '<button class="btn btn-secondary small abi-deactivate">Deactivate</button>' : ''}
        <button class="btn small abi-use">Use</button>
      </div>
    `;
    row.querySelector('.abi-deactivate')?.addEventListener('click', ()=>{
      activeSet.delete(id);
      st.active_abilities = Array.from(activeSet);
      renderCombatEtUsage();
      renderCombatAbilityList();
      queueSave();
    });
    row.querySelector('.abi-use')?.addEventListener('click', ()=>{
      applyAbilityCosts(a);
      if (canStayActive && !activeSet.has(id)){
        activeSet.add(id);
        st.active_abilities = Array.from(activeSet);
      }
      renderCombatEtUsage();
      renderCombatAbilityList();
      queueSave();
      openCombatAbilityRoll(a, a?.source_category || '');
    });
    combatAbilityListEl.appendChild(row);
  });
  if (!rendered){
    combatAbilityListEl.innerHTML = '<div class="muted">No matching abilities.</div>';
  }
  renderCombatActiveAbilities();
}

function renderCombatSpellList(){
  if (!combatSpellListEl) return;
  const st = combatState();
  const activeSet = new Set((st.active_spells || []).map(String));
  const search = String(combatSpellSearchEl?.value || '').trim().toLowerCase();
  const metaMap = SPELLLIST_META.spell_meta || {};
  combatSpellListEl.innerHTML = '';
  if (!SPELLLIST_SPELLS.length){
    combatSpellListEl.innerHTML = '<div class="muted">No spells linked.</div>';
    return;
  }
  const validIds = new Set(SPELLLIST_SPELLS.map(sp=> String(sp?.id || '')));
  const eligibleIds = new Set(SPELLLIST_SPELLS.filter(spellHasActiveCost).map(sp=> String(sp?.id || '')));
  Array.from(activeSet).forEach(id=>{
    if (!validIds.has(id) || !eligibleIds.has(id)) activeSet.delete(id);
  });
  st.active_spells = Array.from(activeSet);
  let rendered = 0;
  SPELLLIST_SPELLS.forEach(sp=>{
    const meta = metaMap[String(sp?.id || '')] || {};
    const name = spellDisplayName(sp, metaMap);
    if (search && !String(name).toLowerCase().includes(search)) return;
    rendered += 1;
    const id = String(sp?.id || '');
    const costParts = [];
    if (sp.en_cost != null) costParts.push(`EN: ${sp.en_cost}`);
    const cost = costParts.join(' || ');
    const canStayActive = eligibleIds.has(id);
    const isActive = activeSet.has(id);
    const row = document.createElement('div');
    row.className = 'combat-entry';
    row.innerHTML = `
      <div class="grow">
        <div><strong>${invEscapeHtml(name)}</strong>${meta.status ? ` <span class="tag">${invEscapeHtml(meta.status)}</span>` : ''}${isActive ? ' <span class="tag">Active</span>' : ''}</div>
        ${cost ? `<div class="muted">Cost: ${invEscapeHtml(cost)}</div>` : ''}
      </div>
      <div class="combat-actions-row">
        ${isActive ? '<button class="btn btn-secondary small spell-deactivate">Deactivate</button>' : ''}
        <button class="btn small spell-use">Use</button>
      </div>
    `;
    row.querySelector('.spell-deactivate')?.addEventListener('click', ()=>{
      activeSet.delete(id);
      st.active_spells = Array.from(activeSet);
      renderCombatEtUsage();
      renderCombatSpellList();
      queueSave();
    });
    row.querySelector('.spell-use')?.addEventListener('click', ()=>{
      applySpellCosts(sp);
      if (canStayActive && !activeSet.has(id)){
        activeSet.add(id);
        st.active_spells = Array.from(activeSet);
      }
      renderCombatEtUsage();
      renderCombatSpellList();
      queueSave();
      openCombatSpellRoll(sp, metaMap[id] || {}, { cost, range: sp.range, aoe: sp.aoe, desc: sp.description_html || sp.description || '', effectsDesc: sp.effects_desc || '', nameDisplay: name, statusLabel: meta.status || '' });
    });
    combatSpellListEl.appendChild(row);
  });
  if (!rendered){
    combatSpellListEl.innerHTML = '<div class="muted">No matching spells.</div>';
  }
}

function renderCombatConditions(){
  if (!conditionsListEl) return;
  const st = combatState();
  const active = new Set((st.conditions || []).map(String));
  if (st.exhausted) active.add('exhausted');
  conditionsListEl.innerHTML = '';
  const activeDefs = CONDITION_DEFS.filter(cond=> active.has(cond.id));
  const unknownIds = Array.from(active).filter(id=> !activeDefs.some(cond=> cond.id === id));
  if (!activeDefs.length && !unknownIds.length){
    conditionsListEl.innerHTML = '<div class="muted">No active conditions.</div>';
    return;
  }
  const renderRow = (condId, name, kind, effect)=>{
    const row = document.createElement('div');
    row.className = 'combat-entry';
    row.title = effect || '';
    row.innerHTML = `
      <div class="grow">
        <div><strong>${invEscapeHtml(name)}</strong>${kind ? ` <span class="tag">${invEscapeHtml(kind)}</span>` : ''}</div>
        <div class="muted">${invEscapeHtml(effect || '')}</div>
      </div>
      <button class="btn small" data-cond="${invEscapeHtml(condId)}">Remove</button>
    `;
    row.querySelector('button')?.addEventListener('click', (e)=>{
      const id = e.target.getAttribute('data-cond');
      if (!id) return;
      active.delete(id);
      st.conditions = Array.from(active);
      if (id === 'exhausted'){
        st.exhausted = false;
        renderCombatTension();
      }
      renderCombatActions();
      renderCombatEtUsage();
      updateDerived();
      renderCombatConditions();
      queueSave();
    });
    conditionsListEl.appendChild(row);
  };
  activeDefs.forEach(cond=>{
    renderRow(cond.id, cond.name, cond.kind, cond.effect);
  });
  unknownIds.forEach(id=>{
    renderRow(id, id, '', '');
  });
  st.conditions = Array.from(active);
}

function renderCombatConditionModal(){
  if (!conditionsModalListEl) return;
  const st = combatState();
  const active = new Set((st.conditions || []).map(String));
  if (st.exhausted) active.add('exhausted');
  conditionsModalListEl.innerHTML = '';
  CONDITION_DEFS.forEach(cond=>{
    const row = document.createElement('div');
    row.className = 'combat-entry';
    row.title = cond.effect || '';
    const isActive = active.has(cond.id);
    row.innerHTML = `
      <div class="grow">
        <div><strong>${invEscapeHtml(cond.name)}</strong> <span class="tag">${invEscapeHtml(cond.kind)}</span></div>
        <div class="muted">${invEscapeHtml(cond.effect || '')}</div>
      </div>
      <button class="btn small" data-cond="${invEscapeHtml(cond.id)}">${isActive ? 'Remove' : 'Add'}</button>
    `;
    row.querySelector('button')?.addEventListener('click', (e)=>{
      const id = e.target.getAttribute('data-cond');
      if (!id) return;
      if (active.has(id)){
        active.delete(id);
      }else{
        active.add(id);
      }
      st.conditions = Array.from(active);
      if (id === 'exhausted'){
        st.exhausted = active.has('exhausted');
        renderCombatTension();
      }
      renderCombatActions();
      renderCombatEtUsage();
      updateDerived();
      renderCombatConditions();
      renderCombatConditionModal();
      queueSave();
    });
    conditionsModalListEl.appendChild(row);
  });
  st.conditions = Array.from(active);
}

function renderCombatCritList(){
  if (!critListEl) return;
  const st = combatState();
  const list = Array.isArray(st.critical_injuries) ? st.critical_injuries : [];
  critListEl.innerHTML = '';
  if (!list.length){
    critListEl.innerHTML = '<div class="muted">No critical injuries.</div>';
    return;
  }
  list.forEach((entry, idx)=>{
    const row = document.createElement('div');
    row.className = 'combat-entry';
    row.innerHTML = `
      <div class="grow">
        <div><strong>${invEscapeHtml(entry.type || 'Injury')}</strong></div>
        <div class="muted">HP loss: ${Number(entry.hp_loss || 0)} | True damage: ${Number(entry.true_damage || 0)}</div>
      </div>
      <div class="combat-actions-row">
        <label class="muted"><input type="checkbox" class="crit-stable" ${entry.stabilized ? 'checked' : ''}> Stabilized</label>
        <button class="btn small">Remove</button>
      </div>
    `;
    row.querySelector('.crit-stable')?.addEventListener('change', (e)=>{
      entry.stabilized = !!e.target.checked;
      queueSave();
    });
    row.querySelector('button')?.addEventListener('click', ()=>{
      st.critical_injuries = list.filter((_, i)=> i !== idx);
      st.max_hp_damage = Math.max(0, Number(st.max_hp_damage || 0) - Number(entry.hp_loss || 0));
      renderCombatCritList();
      if (maxHpDmgEl) safeSetValue(maxHpDmgEl, st.max_hp_damage);
      updateDerived();
      queueSave();
    });
    critListEl.appendChild(row);
  });
}

function renderCombatDeathSaves(){
  const st = combatState();
  const ds = ensureDeathSaves();
  if (deathSaveSuccessEl) deathSaveSuccessEl.textContent = String(ds.successes || 0);
  if (deathSaveFailEl) deathSaveFailEl.textContent = String(ds.failures || 0);
  if (deathStatusEl) deathStatusEl.textContent = ds.dead ? 'Dead' : 'Alive';
}

function renderCombatDerivedBadges(){
  const maxHpDamage = Math.max(0, Number(combatState().max_hp_damage || 0));
  const maxHp = Math.max(0, numOr(DERIVED_CACHE?.hp, 0) - maxHpDamage);
  if (combatMaxHpEl) combatMaxHpEl.textContent = maxHp;
  if (combatMaxEnEl) combatMaxEnEl.textContent = numOr(DERIVED_CACHE?.en, 0);
  if (combatMaxFoEl) combatMaxFoEl.textContent = numOr(DERIVED_CACHE?.fo, 0);
  if (combatMaxSpEl) combatMaxSpEl.textContent = numOr(DERIVED_CACHE?.spcap, 0);
  if (combatDerMoEl) combatDerMoEl.textContent = numOr(DERIVED_CACHE?.mo, 0);
  if (combatDerInitEl) combatDerInitEl.textContent = numOr(DERIVED_CACHE?.initiative, 0);
  if (combatDerEtEl) combatDerEtEl.textContent = numOr(DERIVED_CACHE?.et, 0);
  if (combatDerTxEl) combatDerTxEl.textContent = numOr(DERIVED_CACHE?.tx, 0);
  if (combatDerEncEl){
    const curEnc = Number(DERIVED_CACHE?.current_enc || 0).toFixed(1);
    const maxEnc = numOr(DERIVED_CACHE?.enc, 0);
    combatDerEncEl.textContent = `${curEnc}/${maxEnc}`;
  }
}

function renderCombatTab(){
  renderCombatDefenseSkills();
  renderCombatWeapons();
  renderCombatAbilityList();
  renderCombatSpellList();
  renderCombatActions();
  renderCombatConditions();
  renderCombatCritList();
  renderCombatDeathSaves();
  renderCombatTension();
  renderCombatEtUsage();
  renderCombatActiveAbilities();
  if (initBaseEl) initBaseEl.textContent = numOr(DERIVED_CACHE?.initiative, 0);
  if (maxHpDmgEl) safeSetValue(maxHpDmgEl, Math.max(0, Number(combatState().max_hp_damage || 0)));
  renderCombatDerivedBadges();
  if (initLastEl){
    const last = combatState().initiative_last;
    initLastEl.textContent = last ? `Last roll: ${last}` : '';
  }
}

function applyCurrentDelta(delta){
  const hp = numOr(CURRENT.hp ?? DERIVED_CACHE?.hp, 0);
  const en = numOr(CURRENT.en ?? DERIVED_CACHE?.en, 0);
  const fo = numOr(CURRENT.fo ?? DERIVED_CACHE?.fo, 0);
  const sp = numOr(CURRENT.sp ?? DERIVED_CACHE?.spcap, 0);
  CURRENT = {
    hp: hp + numOr(delta.hp, 0),
    en: en + numOr(delta.en, 0),
    fo: fo + numOr(delta.fo, 0),
    sp: sp + numOr(delta.sp, 0),
  };
  updateDerived();
  queueSave();
}

function applyDamageAmount(amount, trueDamage){
  let dmg = Math.max(0, Number(amount || 0));
  if (!dmg) return;
  const hp = numOr(CURRENT.hp ?? DERIVED_CACHE?.hp, 0);
  const sp = numOr(CURRENT.sp ?? DERIVED_CACHE?.spcap, 0);
  let newHp = hp;
  let newSp = sp;
  if (trueDamage){
    newHp = Math.max(0, hp - dmg);
  }else{
    const spLoss = Math.min(newSp, dmg);
    newSp -= spLoss;
    dmg -= spLoss;
    newHp = Math.max(0, newHp - dmg);
  }
  CURRENT = { ...CURRENT, hp: newHp, sp: newSp };
  updateDerived();
  queueSave();
  const entry = document.createElement('div');
  entry.className = 'roll-entry';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = trueDamage ? 'True Damage' : 'Damage Taken';
  entry.appendChild(title);
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = new Date().toLocaleTimeString();
  entry.appendChild(meta);
  const line = document.createElement('div');
  line.textContent = `Amount: ${Number(amount || 0)} | HP ${newHp} | SP ${newSp}`;
  entry.appendChild(line);
  appendRollLog(entry);
}

function applyHealAmount(amount){
  const heal = Math.max(0, Number(amount || 0));
  if (!heal) return;
  applyCurrentDelta({ hp: heal });
  const entry = document.createElement('div');
  entry.className = 'roll-entry';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = 'Heal';
  entry.appendChild(title);
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = new Date().toLocaleTimeString();
  entry.appendChild(meta);
  const line = document.createElement('div');
  line.textContent = `Healed: ${heal}`;
  entry.appendChild(line);
  appendRollLog(entry);
}

function applyAbilityCosts(a){
  const costs = a?.active?.costs || {};
  const delta = {
    hp: -Number(costs.HP || 0),
    en: -Number(costs.EN || 0),
    fo: -Number(costs.FO || 0),
  };
  applyCurrentDelta(delta);
  const missing = [];
  ['MO','TX'].forEach(k=>{
    const v = Number(costs[k] || 0);
    if (Number.isFinite(v) && v !== 0) missing.push(`${k}: ${v}`);
  });
  if (costs.other_label && costs.other_value != null){
    const v = Number(costs.other_value || 0);
    if (Number.isFinite(v) && v !== 0) missing.push(`${costs.other_label}: ${v}`);
  }
  if (missing.length){
    openRollModal({ title: 'Ability Cost', infoOnly:true, descText:`Untracked cost: ${missing.join(', ')}` });
  }
}

function applySpellCosts(sp){
  const en = Number(sp?.en_cost || 0);
  if (Number.isFinite(en) && en !== 0){
    applyCurrentDelta({ en: -en });
  }
}

function rollInitiativeSpecial(){
  const base = numOr(DERIVED_CACHE?.initiative, 0);
  const rolls = [];
  const first = rollD10();
  rolls.push({ v: first, sign:'+' });
  let total = first;
  if (first === 10){
    let cur = rollD10();
    rolls.push({ v: cur, sign:'+' });
    total += cur;
    while (cur === 10){
      cur = rollD10();
      rolls.push({ v: cur, sign:'+' });
      total += cur;
    }
  }else if (first === 1){
    const cur = rollD10();
    rolls.push({ v: cur, sign:'-' });
    total -= cur;
  }
  const result = base + total;
  const entry = document.createElement('div');
  entry.className = 'roll-entry';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = 'Initiative Roll';
  entry.appendChild(title);
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = new Date().toLocaleTimeString();
  entry.appendChild(meta);
  const skillLine = document.createElement('div');
  skillLine.className = 'muted';
  skillLine.textContent = 'Skill: Initiative';
  entry.appendChild(skillLine);
  const modeLine = document.createElement('div');
  modeLine.className = 'muted';
  modeLine.textContent = 'Roll type: Simple';
  entry.appendChild(modeLine);
  const line = document.createElement('div');
  line.textContent = `Result: ${result}`;
  entry.appendChild(line);
  const detail = document.createElement('div');
  detail.className = 'muted';
  detail.textContent = `Rolls: ${rolls.map(r=>`${r.sign}${r.v}`).join(' ')} | Base ${base} | Mod 0`;
  entry.appendChild(detail);
  appendRollLog(entry);
  if (initLastEl) initLastEl.textContent = `Last roll: ${result}`;
  const st = combatState();
  st.initiative_last = result;
  queueSave();
}

function ensureDeathSaves(){
  const st = combatState();
  if (!st.death_saves || typeof st.death_saves !== 'object'){
    st.death_saves = { ko:false, successes:0, failures:0, dead:false };
  }
  if (st.death_saves.dead == null) st.death_saves.dead = false;
  st.death_saves.successes = Number(st.death_saves.successes || 0);
  st.death_saves.failures = Number(st.death_saves.failures || 0);
  return st.death_saves;
}
function clampDeathSaves(ds){
  ds.successes = Math.max(0, Math.min(3, Number(ds.successes || 0)));
  ds.failures = Math.max(0, Math.min(3, Number(ds.failures || 0)));
  if (ds.failures >= 3) ds.dead = true;
}

function rollDeathSave(){
  const st = combatState();
  const ds = ensureDeathSaves();
  const penalty = (st.critical_injuries || []).filter(i=> !i.stabilized).length;
  const raw = rollD10();
  const result = raw - penalty;
  if (result <= 1){
    ds.failures = (ds.failures || 0) + 2;
  }else if (result <= 5){
    ds.failures = (ds.failures || 0) + 1;
  }else if (result <= 9){
    ds.successes = (ds.successes || 0) + 1;
  }else{
    ds.successes = 0;
    ds.failures = 0;
    ds.dead = false;
    ds.ko = false;
    CURRENT = { ...CURRENT, hp: Math.max(1, numOr(CURRENT.hp, 0)) };
    updateDerived();
  }
  clampDeathSaves(ds);
  renderCombatDeathSaves();
  const entry = document.createElement('div');
  entry.className = 'roll-entry';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = 'Death Save';
  entry.appendChild(title);
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = new Date().toLocaleTimeString();
  entry.appendChild(meta);
  const skillLine = document.createElement('div');
  skillLine.className = 'muted';
  skillLine.textContent = 'Skill: Death Save';
  entry.appendChild(skillLine);
  const modeLine = document.createElement('div');
  modeLine.className = 'muted';
  modeLine.textContent = 'Roll type: Simple';
  entry.appendChild(modeLine);
  const line = document.createElement('div');
  line.textContent = `Result: ${result}`;
  entry.appendChild(line);
  const detail = document.createElement('div');
  detail.className = 'muted';
  detail.textContent = `Roll: ${raw} | Base 0 | Mod ${penalty ? `-${penalty}` : '0'}`;
  entry.appendChild(detail);
  if (penalty){
    const condLine = document.createElement('div');
    condLine.className = 'muted';
    condLine.textContent = `Conditions: Injuries -${penalty}`;
    entry.appendChild(condLine);
  }
  const state = document.createElement('div');
  state.className = 'muted';
  state.textContent = `Effect: Successes: ${ds.successes} | Failures: ${ds.failures}${ds.dead ? ' | Dead' : ''}`;
  entry.appendChild(state);
  appendRollLog(entry);
  queueSave();
}

function addDeathSaveSuccess(){
  const ds = ensureDeathSaves();
  ds.successes = Number(ds.successes || 0) + 1;
  clampDeathSaves(ds);
  renderCombatDeathSaves();
  queueSave();
}
function addDeathSaveFailure(){
  const ds = ensureDeathSaves();
  ds.failures = Number(ds.failures || 0) + 1;
  clampDeathSaves(ds);
  renderCombatDeathSaves();
  queueSave();
}
function resetDeathSaves(){
  const ds = ensureDeathSaves();
  ds.successes = 0;
  ds.failures = 0;
  renderCombatDeathSaves();
  queueSave();
}
function resetDeathStatus(){
  const ds = ensureDeathSaves();
  ds.successes = 0;
  ds.failures = 0;
  ds.dead = false;
  renderCombatDeathSaves();
  queueSave();
}
function stabilizeDeathSaves(){
  const ds = ensureDeathSaves();
  ds.successes = 3;
  ds.dead = false;
  renderCombatDeathSaves();
  queueSave();
}

function applyRest(){
  const type = restTypeEl?.value || 'long';
  const quality = restQualityEl?.value || 'adequate';
  const mult = ({
    abysmal: 0.25,
    rudimentary: 0.5,
    adequate: 1,
    good: 2,
    luxurious: 4
  })[quality] || 1;
  const bod = totalFromInvest(investVal(CHAR.stats.body?.invest, 0));
  const wil = totalFromInvest(investVal(CHAR.stats.willpower?.invest, 0));
  let hpGain = 0;
  let enGain = 0;
  let foGain = 0;
  if (type === 'nap'){
    hpGain = rollD10() + bod;
    enGain = 1;
    foGain = 1;
  }else if (type === 'long'){
    hpGain = (rollD10() + bod) * 5;
    enGain = wil;
    foGain = wil;
  }else if (type === 'light'){
    hpGain = ((rollD10() + bod) * 5) * 0.5;
    enGain = wil * 0.5;
    foGain = wil * 0.5;
  }else if (type === 'total'){
    hpGain = ((rollD10() + bod) * 5) * 2;
    enGain = wil * 2;
    foGain = wil * 2;
  }else if (type === 'watch'){
    hpGain = ((rollD10() + bod) * 5) * 0.25;
    enGain = wil * 0.25;
    foGain = wil * 0.25;
  }
  hpGain = Math.floor(hpGain * mult);
  enGain = Math.floor(enGain * mult);
  foGain = Math.floor(foGain * mult);
  applyCurrentDelta({ hp: hpGain, en: enGain, fo: foGain });
  openRollModal({ title:'Rest', infoOnly:true, descText:`Recovered HP ${hpGain}, EN ${enGain}, FO ${foGain} (${type}, ${quality})` });
}

function applyEat(){
  const quality = eatQualityEl?.value || 'adequate';
  let note = '';
  if (quality === 'spoiled') note = 'Spoiled: Resistance check DC 12 or fall ill.';
  if (quality === 'mediocre') note = 'Mediocre: next rest quality -1 step.';
  if (quality === 'adequate') note = 'Adequate: no additional effect.';
  if (quality === 'good') note = 'Good: next rest quality +1 step.';
  if (quality === 'excellent') note = 'Excellent: reroll one roll within 24h and next rest quality +1 step.';
  openRollModal({ title:'Eat', infoOnly:true, descText: note || 'Food consumed.' });
}

function rollDefense(){
  const skill = defSkillSelectEl?.value || '';
  const modInput = Number(defModEl?.value || 0);
  const key = charKeyForSkillName(skill);
  const base = key ? skillAdjTotal(key, skill).total : 0;
  const cond = getCombatRollModifiers('defense', skill);
  openRollModal({
    title: `Defense: ${skill || 'Roll'}`,
    subtitle: 'Defense',
    baseLabel: 'Skill value',
    base,
    mod: modInput + cond.mod,
    adv: cond.adv || 'normal',
    autoConds: cond.conds,
    detailsText: `Defense skill: ${skill || 'None'}`,
    detailLines: [`Skill: ${skill || 'Defense'}`],
    rollKind: 'skill'
  });
}

function addCriticalInjury(type, stabilized){
  const st = combatState();
  const map = {
    severe: { label:'Severe', hp_loss: 20, true_damage: 10 },
    very: { label:'Very Severe', hp_loss: 40, true_damage: 20 },
    mortal: { label:'Mortal Injury', hp_loss: 80, true_damage: 60 }
  };
  const entry = map[type] || map.severe;
  st.critical_injuries = st.critical_injuries || [];
  st.critical_injuries.push({
    type: entry.label,
    hp_loss: entry.hp_loss,
    true_damage: entry.true_damage,
    stabilized: !!stabilized
  });
  st.max_hp_damage = Math.max(0, Number(st.max_hp_damage || 0) + entry.hp_loss);
  applyDamageAmount(entry.true_damage, true);
  renderCombatCritList();
  renderCombatDeathSaves();
  if (maxHpDmgEl) safeSetValue(maxHpDmgEl, st.max_hp_damage);
  updateDerived();
  queueSave();
}

function updateCritNote(){
  if (!critNoteEl || !critTypeEl) return;
  const type = critTypeEl.value;
  const map = {
    severe: 'Severe: 10 True damage and lose 20 max HP. Stabilization DC 10.',
    very: 'Very Severe: 20 True damage and lose 40 max HP. Stabilization DC 14.',
    mortal: 'Mortal Injury: 60 True damage and lose 80 max HP. Stabilization DC 16.'
  };
  critNoteEl.textContent = map[type] || '';
}
function toggleCritModal(open){
  if (!critModal || !critBackdrop) return;
  if (open){
    critModal.classList.remove('hidden');
    critModal.classList.add('open');
    critBackdrop.classList.add('open');
    updateCritNote();
  }else{
    critModal.classList.add('hidden');
    critModal.classList.remove('open');
    critBackdrop.classList.remove('open');
  }
}

let COMBAT_DAMAGE_MODE = 'damage';
function openCombatDamageModal(mode){
  COMBAT_DAMAGE_MODE = mode;
  if (combatDmgTitleEl){
    combatDmgTitleEl.textContent = mode === 'heal'
      ? 'Heal Damage'
      : (mode === 'true' ? 'Take True Damage' : 'Take Damage');
  }
  if (combatDmgInputEl){
    combatDmgInputEl.value = '';
    combatDmgInputEl.focus();
  }
  invToggleModal(combatDmgModal, combatDmgBackdrop, true);
}
function closeCombatDamageModal(){
  invToggleModal(combatDmgModal, combatDmgBackdrop, false);
}

/* --------- PASSIVE on DERIVED (existing behavior) ---------- */
function applyPassiveModifiersToDerived(base, currentEnc = 0){
  const out = { ...base };
  out.current_enc = Number(currentEnc || 0);
    const notes = {
      hp: [`Base = ${base.hp}`],
        en: [`Base = ${base.en}`],
        fo: [`Base = ${base.fo}`],
        mo: [`Base = ${base.mo}`],
        initiative: [`Base = ${base.initiative ?? 0}`],
        complex_schools: [`Base = ${base.complex_schools ?? 0}`],
        et: [`Base = ${base.et}`],
        tx: [`Base = ${base.tx}`],
        weapon_neutral:[`Base = ${base.weapon_neutral ?? 0}`],
        enc:[`Base = ${base.enc}`],
        spcap:[],
      talent_max:[`Base = ${base.talent_max ?? 0}`],
      max_expertise:[`Base = ${base.max_expertise ?? 0}`],
      max_divine_manifestation:[`Base = ${base.max_divine_manifestation ?? 0}`],
      craftomancy_max:[`Base = ${base.craftomancy_max ?? 0}`],
      skill_points:[`Base = ${base.skill_points ?? 0}`],
      stat_points:[`Base = ${base.stat_points ?? 0}`],
      sublimation_slots:[`Base = ${base.sublimation_slots ?? 0}`]
    };
  notes.enc.unshift(`Current enc = ${Number(currentEnc||0).toFixed(1)}`);
  if (base._notes){
    Object.entries(base._notes).forEach(([k, arr])=>{
      if (notes[k]) notes[k].push(...arr);
    });
  }

  const ops = { set:[], mul:[], add:[] };
    const assignedIds = new Set((ASSIGNED||[]).map(a=> String(a?.id || '')));
    const combined = (ASSIGNED||[])
      .concat((ARC_ASSIGNED||[]).filter(a=> !assignedIds.has(String(a?.id || ''))))
      .concat((EXP_ASSIGNED||[]).filter(a=> !assignedIds.has(String(a?.id || ''))))
      .concat((DIMA_ASSIGNED||[]).filter(a=> !assignedIds.has(String(a?.id || ''))));
    const passiveAbilities = combined.filter(a=>{
      const t = (a.type||'').toLowerCase();
      return t==='passive' || t==='mixed';
    });

  const allMods = [];
  for (const ab of passiveAbilities){
    const mods = resolvedPassiveMods(ab);
    for (const m of mods){
      allMods.push({
        target:(m.target || m.key || '').toLowerCase().trim(),
        mode:(m.mode||'add').toLowerCase(),
        val:modEffectiveValue(m),
        origin:`${ab.name}${m.note?` (${m.note})`:''}`
      });
    }
  }
  for (const m of getEquippedInventoryModifiers()){
    allMods.push({
      target:(m.target||'').toLowerCase(),
      mode:(m.mode||'add').toLowerCase(),
      val:modEffectiveValue(m),
      origin:m.origin
    });
  }
  for (const m of getSpellEffectModifiers()){
    allMods.push({
      target:(m.target||'').toLowerCase(),
      mode:(m.mode||'add').toLowerCase(),
      val:modEffectiveValue(m),
      origin:m.origin
    });
  }
  const { mods: subMods } = getSublimationEffects();
  for (const m of subMods){
    allMods.push({
      target:(m.target||'').toLowerCase(),
      mode:(m.mode||'add').toLowerCase(),
      val:modEffectiveValue(m),
      origin:m.origin
    });
  }

    const map = {
        'derived.hp':'hp','derived.en':'en','derived.fo':'fo','derived.mo':'mo','derived.initiative':'initiative',
      'derived.et':'et','derived.tx':'tx','derived.enc':'enc','derived.spcap':'spcap','derived.talent_max':'talent_max',
      'derived.max_expertise':'max_expertise','derived.max_divine_manifestation':'max_divine_manifestation',
      'derived.craftomancy_max':'craftomancy_max','derived.skill_points':'skill_points','derived.stat_points':'stat_points',
      'derived.sublimation_slots':'sublimation_slots','derived.complex_schools':'complex_schools','derived.weapon_neutral':'weapon_neutral'
    };
  for (const m of allMods){
    if (map[m.target]){
      ops[m.mode]?.push({ k: map[m.target], v: m.val, origin: m.origin });
    }
  }

  const condFlags = getCombatConditionFlags();
  if (condFlags.accelerated){
    ops.add.push({ k: 'mo', v: 2, origin: 'Accelerated' });
  }

  // set -> mul -> add
  for (const op of ops.set){ out[op.k] = op.v; notes[op.k].push(`Set to ${op.v} -> ${op.origin}`); }
  for (const op of ops.mul){ const before = out[op.k]; out[op.k] = Math.round(before * op.v); notes[op.k].push(`*${op.v} (from ${before}) -> ${op.origin}`); }
  for (const op of ops.add){ out[op.k] = out[op.k] + op.v; notes[op.k].push(`${op.v>=0?'+':''}${op.v} -> ${op.origin}`); }

  const maxHpDamage = Math.max(0, Number(CHAR?.stats?.combat?.max_hp_damage || 0));
  if (maxHpDamage){
    const before = out.hp;
    out.hp = Math.max(0, out.hp - maxHpDamage);
    notes.hp.push(`Max HP damage -${maxHpDamage} (from ${before})`);
  }

  // Recompute spcap off final HP, then apply any spcap-specific modifiers that were already added
  const baseSpcap = Math.floor(out.hp * 0.10);
  const spcapOps = {
    set: ops.set.filter(op=>op.k==='spcap'),
    mul: ops.mul.filter(op=>op.k==='spcap'),
    add: ops.add.filter(op=>op.k==='spcap'),
  };
  notes.spcap = [`Base = ${baseSpcap}`];
  out.spcap = baseSpcap;
  for (const op of spcapOps.set){ out.spcap = op.v; notes.spcap.push(`Set to ${op.v} -> ${op.origin}`); }
  for (const op of spcapOps.mul){ const before = out.spcap; out.spcap = Math.round(before * op.v); notes.spcap.push(`*${op.v} (from ${before}) -> ${op.origin}`); }
  for (const op of spcapOps.add){ out.spcap = out.spcap + op.v; notes.spcap.push(`${op.v>=0?'+':''}${op.v} -> ${op.origin}`); }
  if (condFlags.toughened){
    const bonus = Math.round(out.hp * 0.15);
    if (bonus){
      out.spcap += bonus;
      notes.spcap.push(`+${bonus} (15% HP) -> Toughened`);
    }
  }

  TALENT_MAX = out.talent_max ?? base.talent_max ?? TALENT_MAX;

  // Initiative tracks MO after modifiers (base + mods).
  out.initiative = out.mo;
  const moBreakdown = (notes.mo || []).filter(n=>!/^Base\s*=/.test(n));
  notes.initiative = [`Base = ${base.initiative ?? base.mo ?? 0}`, 'Synced to MO (modifiers included)', ...moBreakdown];

  // Tooltips with breakdown
  hpEl.title = notes.hp.join('\n');   setNotesList('mods-derived-hp', notes.hp);
  enEl.title = notes.en.join('\n');   setNotesList('mods-derived-en', notes.en);
  foEl.title = notes.fo.join('\n');   setNotesList('mods-derived-fo', notes.fo);
  moEl.title = notes.mo.join('\n');   setNotesList('mods-derived-mo', notes.mo);
  initEl.title = notes.initiative.join('\n'); setNotesList('mods-derived-initiative', notes.initiative);
  spcapEl.title = notes.spcap.join('\n'); setNotesList('mods-derived-spcap', notes.spcap);
  encEl.title = notes.enc.join('\n'); setNotesList('mods-derived-enc', notes.enc);
  etEl.title = notes.et.join('\n');   setNotesList('mods-derived-et', notes.et);
  txEl.title = notes.tx.join('\n');   setNotesList('mods-derived-tx', notes.tx);

  out.current_enc = Number(currentEnc || 0);
  out.enc_max = out.enc;
  return out;
}

/* Derived computations (use characteristic mods & skills that may be adjusted) */
function milestone(key){
  // milestone uses the **adjusted** characteristic mod, shifted to start at total 4
  return Math.max(0, charAdjMod(key).mod + 3);
}
function baseTalentMax(lvl){
  const levelVal = 1 + Math.floor(Math.max(1, lvl) / 10);
  return levelVal + milestone('tech') + milestone('wisdom');
}
function talentMax(){
  return TALENT_MAX || baseTalentMax(Math.max(1, Math.floor(Number(levelEl.value)||1)));
}
function talentCount(){
  return (ASSIGNED || []).filter(a=> (a.source_category || '').toLowerCase() === 'talent').length;
}
function updateTalentCounter(){
  if (!talentCounterEl) return;
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const base = 1 + Math.floor(lvl / 10);
  const msTec = milestone('tech');
  const msWis = milestone('wisdom');
  const max = talentMax();
  const count = talentCount();
  const over = count > max;
  talentCounterEl.textContent = `Talents: ${count} / ${max}`;
  talentCounterEl.style.color = over ? '#f66' : '';
  talentCounterEl.title = `Base ${base} + TEC milestone ${msTec} + WIS milestone ${msWis}`;
}
function expertiseMax(){
  return Math.max(0, Math.floor(numOr(DERIVED_CACHE?.max_expertise, 0)));
}
function divineManifestationMax(){
  return Math.max(0, Math.floor(numOr(DERIVED_CACHE?.max_divine_manifestation, 0)));
}
function updateExpertiseCounters(){
  if (expertiseCounterEl){
    const count = (CHAR?.expertise_ids || []).length;
    const max = expertiseMax();
    expertiseCounterEl.textContent = `Expertise: ${count} / ${max}`;
    expertiseCounterEl.style.color = (count > max) ? '#f66' : '';
  }
  if (dimaCounterEl){
    const count = (CHAR?.divine_manifestation_ids || []).length;
    const max = divineManifestationMax();
    dimaCounterEl.textContent = `Divine Manifestation: ${count} / ${max}`;
    dimaCounterEl.style.color = (count > max) ? '#f66' : '';
  }
}

async function loadExpertiseList(){
  try{
    const res = await api('/expertise');
    EXPERTISES = res.expertises || [];
  }catch(e){
    if (expSummaryEl) expSummaryEl.textContent = 'Load expertise failed: ' + e.message;
  }
}

async function loadDivineManifestationsList(){
  try{
    const res = await api('/divine_manifestations');
    DIVINE_MANIFESTATIONS = res.divine_manifestations || [];
  }catch(e){
    if (dimaSummaryEl) dimaSummaryEl.textContent = 'Load divine manifestations failed: ' + e.message;
  }
}
function skillTotalAdjustedFor(key, name){
  return skillAdjTotal(key, name).total;
}

function updateDerived(){
  const lvl = Math.max(1, Math.floor(Number(levelEl.value)||1));
  const msBOD = milestone('body');
  const msWIL = milestone('willpower');
  const msMAG = milestone('magic');
  const msPRE = milestone('presence');
  const msREF = milestone('reflex');
  const msDEX = milestone('dexterity');
  const msWIS = milestone('wisdom');
  const magTotal = totalFromInvest(investVal(CHAR.stats.magic?.invest, 0));

  // Base
  const base = {};
  const msTEC = milestone('tech');
  base.hp = 39 + lvl + 12*msBOD + 6*msWIL;
  base.en = 5 + Math.floor(lvl/5) + msWIL + 2*msMAG;
  base.fo = 2 + Math.floor(lvl/5) + msWIL + (2*msPRE) + msWIS;
    base.mo = 4 + msDEX + msREF;
    base.initiative = base.mo;
    base.spcap = Math.floor(base.hp * 0.10);
    const complexSchools = magTotal >= 10 ? (1 + Math.floor((magTotal - 10) / 2)) : 0;
    base.complex_schools = complexSchools;
  base.enc = 10 + (10 * msBOD) + (5 * msWIL);
  const invEnc = LINKED_INV?.enc_total || 0;
  base.et = 1 + Math.floor(lvl/10) + msMAG;
  const etTech = 1 + Math.floor(lvl/10) + msTEC;
  base._notes = Object.assign(base._notes || {}, {
    et: [`Alt (TEC): ${etTech}`],
    sublimation_slots: [`Base ${slotsForLevel(lvl)} + PRE milestone ${msPRE * 2}`],
    complex_schools: [`MAG total ${magTotal} -> ${complexSchools}`],
  });
  base.tx = 2 + msBOD + (2 * msTEC);
  base.talent_max = baseTalentMax(lvl);
  base.max_expertise = 0;
  base.max_divine_manifestation = 0;
  base.skill_points = skillPointPool(lvl);
    base.stat_points = statPointPool(lvl);
    base.sublimation_slots = slotsForLevel(lvl) + (2 * msPRE);
    base.weapon_neutral = msDEX;
    base.craftomancy_max = Math.floor(lvl / 9) + msTEC;
    base._notes = Object.assign(base._notes || {}, { weapon_neutral: [`DEX milestone ${msDEX}`] });
    base._notes = Object.assign(base._notes || {}, { craftomancy_max: [`Base ${Math.floor(lvl / 9)} + TEC milestone ${msTEC}`] });

    // Apply passive modifiers to derived
    const final = applyPassiveModifiersToDerived(base, invEnc);
    // Overrides
    const maxVals = { ...final };
    if (OVERRIDE_ENABLED){
      maxVals.hp = numOr(OVERRIDE_VALUES.hp ?? final.hp, final.hp);
      maxVals.en = numOr(OVERRIDE_VALUES.en ?? final.en, final.en);
      maxVals.fo = numOr(OVERRIDE_VALUES.fo ?? final.fo, final.fo);
      maxVals.mo = numOr(OVERRIDE_VALUES.mo ?? final.mo, final.mo);
      maxVals.initiative = numOr(OVERRIDE_VALUES.initiative ?? final.initiative, final.initiative);
      maxVals.spcap = numOr(OVERRIDE_VALUES.spcap ?? final.spcap, final.spcap);
      maxVals.enc = numOr(OVERRIDE_VALUES.enc ?? final.enc, final.enc);
      maxVals.et  = numOr(OVERRIDE_VALUES.et  ?? final.et, final.et);
      maxVals.tx  = numOr(OVERRIDE_VALUES.tx  ?? final.tx, final.tx);
      maxVals.talent_max = numOr(OVERRIDE_VALUES.talent_max ?? final.talent_max, final.talent_max);
      maxVals.skill_points = numOr(OVERRIDE_VALUES.skill_points ?? final.skill_points, final.skill_points);
      maxVals.stat_points = numOr(OVERRIDE_VALUES.stat_points ?? final.stat_points, final.stat_points);
      maxVals.sublimation_slots = numOr(OVERRIDE_VALUES.sublimation_slots ?? final.sublimation_slots, final.sublimation_slots);
      maxVals.complex_schools = numOr(OVERRIDE_VALUES.complex_schools ?? final.complex_schools, final.complex_schools);
    }else{
      // ensure all are finite
      Object.keys(maxVals).forEach(k=>{
        maxVals[k] = numOr(maxVals[k], 0);
      });
    }
    DERIVED_CACHE = { ...final, ...maxVals };
    const cur = OVERRIDE_ENABLED ? {
      hp: numOr(CURRENT.hp ?? maxVals.hp, maxVals.hp),
      en: numOr(CURRENT.en ?? maxVals.en, maxVals.en),
      fo: numOr(CURRENT.fo ?? maxVals.fo, maxVals.fo),
      sp: numOr(CURRENT.sp ?? maxVals.spcap, maxVals.spcap),
    } : {
      hp: Math.max(0, Math.min(numOr(CURRENT.hp ?? maxVals.hp, maxVals.hp), maxVals.hp)),
      en: Math.max(0, Math.min(numOr(CURRENT.en ?? maxVals.en, maxVals.en), maxVals.en)),
      fo: Math.max(0, Math.min(numOr(CURRENT.fo ?? maxVals.fo, maxVals.fo), maxVals.fo)),
      sp: Math.max(0, Math.min(numOr(CURRENT.sp ?? maxVals.spcap, maxVals.spcap), maxVals.spcap)),
    };
  if (CURRENT.hp == null) cur.hp = maxVals.hp;
  if (CURRENT.en == null) cur.en = maxVals.en;
  if (CURRENT.fo == null) cur.fo = maxVals.fo;
  if (CURRENT.sp == null) cur.sp = maxVals.spcap;
  CURRENT = cur;
  if (curHpEl) curHpEl.value = cur.hp;
  if (curEnEl) curEnEl.value = cur.en;
  if (curFoEl) curFoEl.value = cur.fo;
  if (curSpEl) curSpEl.value = cur.sp;
  if (maxHpDmgEl) safeSetValue(maxHpDmgEl, Math.max(0, Number(CHAR?.stats?.combat?.max_hp_damage || 0)));
    if (overrideInputsWrap) overrideInputsWrap.style.display = OVERRIDE_ENABLED ? 'grid' : 'none';
    [
      [ovHpEl, maxVals.hp], [ovEnEl, maxVals.en], [ovFoEl, maxVals.fo], [ovMoEl, maxVals.mo],
      [ovInitEl, maxVals.initiative], [ovSpEl, maxVals.spcap], [ovEncEl, maxVals.enc], [ovEtEl, maxVals.et],
      [ovTxEl, maxVals.tx], [ovTalentMaxEl, maxVals.talent_max], [ovSkillPointsEl, maxVals.skill_points],
      [ovStatPointsEl, maxVals.stat_points], [ovSubSlotsEl, maxVals.sublimation_slots], [ovComplexSchoolsEl, maxVals.complex_schools]
    ].forEach(([el,val])=>{
      if (!el) return;
      el.disabled = !OVERRIDE_ENABLED;
      if (OVERRIDE_ENABLED && (el.value==="" || Number.isNaN(Number(el.value)))) el.value = val;
      if (!OVERRIDE_ENABLED) el.value = '';
    });

  // Display
    hpEl.textContent = `${cur.hp} / ${maxVals.hp}`;
    enEl.textContent = `${cur.en} / ${maxVals.en}`;
    foEl.textContent = `${cur.fo} / ${maxVals.fo}`;
    moEl.textContent = maxVals.mo;
    initEl.textContent = maxVals.initiative ?? final.initiative;
    spcapEl.textContent = `${cur.sp} / ${maxVals.spcap}`;
  encEl.textContent = `${Number(final.current_enc || 0).toFixed(1)} / ${maxVals.enc ?? final.enc}`;
  const etDisplay = (()=> {
    const etVal = maxVals.et ?? final.et;
    const etTech = 1 + Math.floor(lvl/10) + milestone('tech');
    return `${etVal} (TEC ${etTech})`;
  })();
  etEl.textContent = etDisplay;
    txEl.textContent = maxVals.tx ?? final.tx;
    if (weaponNeutralEl) weaponNeutralEl.textContent = maxVals.weapon_neutral ?? final.weapon_neutral ?? 0;
    updatePointCounters();
    renderAddedSchools();
    updateTalentCounter();
    updateExpertiseCounters();
    updateCraftomancyCounter();
    renderCombatEtUsage();
    renderCombatTension();
    renderCombatDerivedBadges();
    if (initBaseEl) initBaseEl.textContent = numOr(DERIVED_CACHE?.initiative, 0);
    if (subSlotPill) renderSublimations();
  }

/* LOAD & SAVE */
async function loadCharacter(){
  INITIAL_LOAD = true;
  if (!CID){ statusEl.textContent = 'Missing id'; return; }
  const res = await api('/characters/' + encodeURIComponent(CID));
  CHAR = res.character || {};
  CHAR.public = !!CHAR.public;
  const owner = String(CHAR.owner || '');
  const role = (CURRENT_USER?.role || '').toLowerCase();
  const isOwner = !!(CURRENT_USER?.username && CURRENT_USER.username === owner);
  const isAdmin = role === 'admin';
  CAN_EDIT = !!(isOwner || isAdmin);
  READ_ONLY = !CAN_EDIT;
  if (VIEW_ONLY){
    CAN_EDIT = false;
    READ_ONLY = true;
  }
  CHAR.stats = normalizeStats(CHAR.stats || {});
  setAddedSchools(CHAR.stats.selected_schools || []);
  XP = numOr(CHAR.xp, 0);
  XP_LEDGER = Array.isArray(CHAR.xp_ledger) ? CHAR.xp_ledger.slice() : [];
  const storedLevel = numOr(CHAR.level ?? CHAR.stats?.level, 0);
  const levelFromData = storedLevel || levelFromXp(XP) || 1;
  CHAR.level = Math.max(1, Math.min(MAX_LEVEL, Math.floor(levelFromData)));
  CHAR.xp = XP;
  CHAR.stats.level = CHAR.level;
  if (!Array.isArray(CHAR.abilities)) CHAR.abilities = [];
  if (!Array.isArray(CHAR.expertise_ids)) CHAR.expertise_ids = [];
  if (!Array.isArray(CHAR.divine_manifestation_ids)) CHAR.divine_manifestation_ids = [];
  ensureSpeciesAbilityLinked();
  ensureBoonAbilityLinked();
  ABILITY_CHOICES = CHAR.ability_choices || {};
  ITEM_CHOICES = CHAR.item_choices || {};
  SUBLIMATIONS = normalizeSublimations(CHAR.sublimations || []);
  if (!CHAR.archetype_id) CHAR.archetype_id = '';
  SELECTED_SPELL_LIST_ID = CHAR.spell_list_id || '';
  SELECTED_INV_ID = CHAR.inventory_id || '';
   COMPUTED_ARC_ABILITIES = CHAR.computed_archetype_abilities || [];
  CURRENT = Object.assign({hp:null,en:null,fo:null,sp:null}, CHAR.current || {});
  OVERRIDE_ENABLED = !!CHAR.override_stats?.enabled;
  OVERRIDE_VALUES = Object.assign({hp:null,en:null,fo:null,mo:null,initiative:null,spcap:null,enc:null,et:null,tx:null,talent_max:null,skill_points:null,stat_points:null,sublimation_slots:null,complex_schools:null}, CHAR.override_stats?.values || {});
  if (overrideToggle) overrideToggle.checked = OVERRIDE_ENABLED;
  if (!CHAR.archetype_rank) CHAR.archetype_rank = _archetypeRankForLevel(CHAR.level);
  LINKED_SPELL_LIST = null;
  renderSpellListSummary();
  PERSONAL = CHAR.stats?.personal || {};
  fillPersonal();

  // Name
  titleEl.textContent = 'Edit: ' + (CHAR.name || '(unnamed)');
  nameEl.value = (CHAR.name || '').slice(0,22);
  nameEl.addEventListener('input', ()=>{
    if (nameEl.value.length > 22) nameEl.value = nameEl.value.slice(0,22);
    if (campaignChatSpeaker) campaignChatSpeaker.textContent = nameEl.value || 'Character';
    queueSave();
  });
  if (publicToggle){
    publicToggle.checked = !!CHAR.public;
    publicToggle.addEventListener('change', ()=>{
      CHAR.public = !!publicToggle.checked;
      queueSave();
    });
  }
  if (unlinkCampaignBtn) unlinkCampaignBtn.style.display = CAMPAIGN_ID ? '' : 'none';
  if (backLinkEl){
    if (CAMPAIGN_ID){
      backLinkEl.textContent = 'Back to Campaign';
      backLinkEl.href = `campaign_view.html?cid=${encodeURIComponent(CAMPAIGN_ID)}`;
    }else{
      backLinkEl.textContent = 'Back to My Characters';
      backLinkEl.href = 'characters.html';
    }
  }
  avatarPreview.src = `/characters/${encodeURIComponent(CID)}/avatar?ts=${Date.now()}`;

  // Level
  levelEl.value = Math.max(1, Number(CHAR.level)||1);
  levelEl.addEventListener('input', ()=>{
    const lvl = Math.max(1, Math.min(MAX_LEVEL, Math.floor(Number(levelEl.value)||1)));
    CHAR.level = lvl;
    if (XP < xpForLevel(lvl)) XP = xpForLevel(lvl);
    CHAR.xp = XP;
    CHAR.stats.level = CHAR.level;
  renderXpProgress();
  updateDerived();
  renderSublimations();
  refreshArchetypeAbilities();
  queueSave();
});
  renderXpProgress();

  // Render stats/skills
  renderStatistics();

  // Resolve abilities → recalc passive agg → render abilities → derived
  await resolveAssignedAbilities();
  recomputePassiveAgg();
  renderAbilitiesTab();
  // refresh visuals that depend on passive agg
  renderStatistics();
  updateDerived();
  renderSublimations();
  await loadArchetypesList();
  await loadSpeciesList();
  await loadBoonList();
  await loadExpertiseList();
  await loadDivineManifestationsList();
  renderArchetypePanel();
  await refreshExpertiseAbilities();
  await refreshDivineManifestationAbilities();
  if (CAN_EDIT) await loadSpellListsList();
  if (SELECTED_SPELL_LIST_ID) await loadSpellListById(SELECTED_SPELL_LIST_ID);
  if (CAN_EDIT) await loadInventoriesList();
  if (SELECTED_INV_ID) await loadInventoryById(SELECTED_INV_ID);
  wirePersonal();
  renderCombatTab();
  INITIAL_LOAD = false;
  applyReadOnlyState();
}

function queueSave(){
  if (READ_ONLY){
    if (statusEl) statusEl.textContent = 'Read-only (public link)';
    return;
  }
  statusEl.textContent = 'Saving...';
  if (SAVE_TIMER) clearTimeout(SAVE_TIMER);
  SAVE_TIMER = setTimeout(saveNow, 350);
}

async function deleteCharacter(){
  if (!CID) { alert('Missing character id.'); return; }
  const typed = prompt('Type "I CONFIRM" to delete this character. This cannot be undone.');
  if ((typed || '').trim() !== 'I CONFIRM') return;
  try{
    statusEl.textContent = 'Deleting...';
    const res = await fetch('/characters/' + encodeURIComponent(CID), {
      method:'DELETE',
      headers: authHeaders()
    });
    const j = await res.json().catch(()=>({}));
    if (j.status !== 'success') throw new Error(j.message || 'Delete failed');
    statusEl.textContent = 'Character deleted.';
    location.href = 'characters.html';
  }catch(e){
    statusEl.textContent = 'Delete failed: ' + e.message;
    alert(e.message);
  }
}

async function unlinkFromCampaign(){
  if (!CAMPAIGN_ID || !CID) return;
  const confirmed = confirm('Unlink this character from the campaign?');
  if (!confirmed) return;
  try{
    statusEl.textContent = 'Unlinking...';
    await api(`/campaigns/${encodeURIComponent(CAMPAIGN_ID)}/characters/${encodeURIComponent(CID)}`, { method:'DELETE' });
    statusEl.textContent = 'Unlinked.';
    location.href = `campaign_view.html?cid=${encodeURIComponent(CAMPAIGN_ID)}`;
  }catch(e){
    statusEl.textContent = 'Unlink failed: ' + e.message;
    alert(e.message);
  }
}

async function saveNow(){
  try{
    const payload = {
      name: nameEl.value || '',
      public: !!CHAR.public,
      level: CHAR.level || 1,
      xp: Math.max(0, Math.floor(XP||0)),
      stats: { ...CHAR.stats, level: CHAR.level, selected_schools: Array.from(ADDED_SCHOOLS) },
      selected_schools: Array.from(ADDED_SCHOOLS),
      abilities: CHAR.abilities || [],
      expertise_ids: CHAR.expertise_ids || [],
      divine_manifestation_ids: CHAR.divine_manifestation_ids || [],
      ability_choices: ABILITY_CHOICES || {},
      item_choices: ITEM_CHOICES || {},
      xp_ledger: XP_LEDGER || [],
      inventory_id: SELECTED_INV_ID || '',
      spell_list_id: SELECTED_SPELL_LIST_ID || '',
      archetype_id: CHAR.archetype_id || '',
      sublimations: SUBLIMATIONS,
      current: CURRENT,
      override_stats: { enabled: OVERRIDE_ENABLED, values: OVERRIDE_VALUES }
    };
    const res = await api('/characters/' + encodeURIComponent(CID), {
      method:'PUT', headers:{ 'content-type':'application/json' }, body: JSON.stringify(payload)
    });
    titleEl.textContent = 'Edit: ' + (res.character?.name || '(unnamed)');
    statusEl.textContent = 'Saved at ' + new Date().toLocaleTimeString();
  }catch(err){
    statusEl.textContent = 'Save failed: ' + err.message;
  }
}

/* ------- Abilities: search/add/remove/render ------- */
function openAbilityAddModal(){
  if (!abiAddModal || !abiAddBackdrop) return;
  abiAddModal.classList.remove('hidden');
  abiAddModal.classList.add('open');
  abiAddBackdrop.classList.add('open');
  abiSearchEl?.focus();
}
function closeAbilityAddModal(){
  if (!abiAddModal || !abiAddBackdrop) return;
  abiAddModal.classList.add('hidden');
  abiAddModal.classList.remove('open');
  abiAddBackdrop.classList.remove('open');
}
let SOURCE_ADD_KIND = 'expertise';
function openSourceAddModal(kind){
  if (!sourceAddModal || !sourceAddBackdrop) return;
  SOURCE_ADD_KIND = kind === 'dima' ? 'dima' : 'expertise';
  if (sourceAddTitle) sourceAddTitle.textContent = SOURCE_ADD_KIND === 'dima' ? 'Add Divine Manifestation' : 'Add Expertise';
  sourceAddModal.classList.remove('hidden');
  sourceAddModal.classList.add('open');
  sourceAddBackdrop.classList.add('open');
  sourceSearchEl.value = '';
  searchSourceEntries();
  sourceSearchEl?.focus();
}
function closeSourceAddModal(){
  if (!sourceAddModal || !sourceAddBackdrop) return;
  sourceAddModal.classList.add('hidden');
  sourceAddModal.classList.remove('open');
  sourceAddBackdrop.classList.remove('open');
}
function getSourceListForModal(){
  return SOURCE_ADD_KIND === 'dima' ? (DIVINE_MANIFESTATIONS || []) : (EXPERTISES || []);
}
function renderSourceResults(list){
  if (!sourceResultsEl) return;
  if (!list.length){
    sourceResultsEl.innerHTML = '<div class="muted">No results.</div>';
    return;
  }
  sourceResultsEl.innerHTML = '';
  list.forEach(entry=>{
    const div = document.createElement('div');
    div.className = 'abi-item';
    const linked = (entry.linked_skills || []).join(', ');
    div.innerHTML = `
      <div class="grow">
        <div><strong>${entry.name || entry.id}</strong></div>
        ${linked ? `<div class="muted" style="font-size:.85rem">Linked skills: ${linked}</div>` : ''}
      </div>
      <div class="row" style="gap:6px; flex-wrap:wrap;">
        <button class="btn small" data-id="${entry.id}">Add</button>
      </div>
    `;
    div.querySelector('button')?.addEventListener('click', ()=> addSourceEntry(entry));
    sourceResultsEl.appendChild(div);
  });
}
function searchSourceEntries(){
  const term = (sourceSearchEl.value || '').trim().toLowerCase();
  const list = getSourceListForModal();
  const filtered = term ? list.filter(e=> String(e.name||'').toLowerCase().includes(term)) : list.slice();
  renderSourceResults(filtered);
}
function addSourceEntry(entry){
  const id = String(entry?.id || '').trim();
  if (!id || !CHAR) return;
  if (SOURCE_ADD_KIND === 'dima'){
    const max = divineManifestationMax();
    const curr = (CHAR.divine_manifestation_ids || []).length;
    if (curr >= max){
      alert(`Divine Manifestation limit reached (${max}).`);
      return;
    }
    const arr = new Set((CHAR.divine_manifestation_ids || []).map(String));
    arr.add(id);
    CHAR.divine_manifestation_ids = Array.from(arr);
    updateExpertiseCounters();
    refreshDivineManifestationAbilities();
  }else{
    const max = expertiseMax();
    const curr = (CHAR.expertise_ids || []).length;
    if (curr >= max){
      alert(`Expertise limit reached (${max}).`);
      return;
    }
    const arr = new Set((CHAR.expertise_ids || []).map(String));
    arr.add(id);
    CHAR.expertise_ids = Array.from(arr);
    updateExpertiseCounters();
    refreshExpertiseAbilities();
  }
  queueSave();
}
async function searchAbilities(){
  try{
    const params = [];
    if (abiSearchEl.value) params.push('name='+encodeURIComponent(abiSearchEl.value));
    if (abiFilterTypeEl.value) params.push('typ='+encodeURIComponent(abiFilterTypeEl.value));
    if (abiFilterSrcEl.value) params.push('source='+encodeURIComponent(abiFilterSrcEl.value));
    if (abiFilterTagEl?.value) params.push('tags='+encodeURIComponent(abiFilterTagEl.value));
    const qs = params.length ? '?'+params.join('&') : '';
    const res = await api('/abilities'+qs);
    const arr = res.abilities || [];
    renderSearchResults(arr);
  }catch(e){
    abiResultsEl.innerHTML = `<div class="muted">Error: ${e.message}</div>`;
  }
}
abiSearchBtn.addEventListener('click', searchAbilities);
abiSearchEl.addEventListener('keydown', (e)=>{ if (e.key==='Enter') searchAbilities(); });
abiFilterTagEl?.addEventListener('keydown', (e)=>{ if (e.key==='Enter') searchAbilities(); });
abiPassiveSortBtn?.addEventListener('click', ()=>{
  ABI_SORT_PASSIVE = abiPassiveOrderEl?.value || 'manual';
  renderAbilitiesTab();
});
abiActiveSortBtn?.addEventListener('click', ()=>{
  ABI_SORT_ACTIVE = abiActiveOrderEl?.value || 'manual';
  renderAbilitiesTab();
});
abiSpellSortBtn?.addEventListener('click', ()=>{
  ABI_SORT_SPELLS = abiSpellOrderEl?.value || 'manual';
  renderAbilitySpellsBucket();
});
speciesSelectEl?.addEventListener('change', ()=> applySpeciesSelection(speciesSelectEl.value));
boonSelectEl?.addEventListener('change', ()=> applyBoonSelection(boonSelectEl.value));
abiOpenAddBtn?.addEventListener('click', openAbilityAddModal);
expOpenAddBtn?.addEventListener('click', ()=> openSourceAddModal('expertise'));
dimaOpenAddBtn?.addEventListener('click', ()=> openSourceAddModal('dima'));
abiAddClose?.addEventListener('click', closeAbilityAddModal);
abiAddCancel?.addEventListener('click', closeAbilityAddModal);
sourceAddClose?.addEventListener('click', closeSourceAddModal);
sourceAddCancel?.addEventListener('click', closeSourceAddModal);
sourceSearchBtn?.addEventListener('click', searchSourceEntries);
sourceSearchEl?.addEventListener('keydown', (e)=>{ if (e.key==='Enter') searchSourceEntries(); });
abiAddBackdrop?.addEventListener('click', (e)=>{ if (e.target===abiAddBackdrop) closeAbilityAddModal(); });
deleteBtn?.addEventListener('click', deleteCharacter);
unlinkCampaignBtn?.addEventListener('click', unlinkFromCampaign);

invLoadBtn.addEventListener('click', ()=> loadInventoryById(invSelectEl.value));
invSelectEl.addEventListener('change', ()=> loadInventoryById(invSelectEl.value));
invCreateBtn?.addEventListener('click', createInventoryAndLink);
invDupLinkBtn?.addEventListener('click', duplicateAndLinkInventory);
invAddContBtn.addEventListener('click', invAddContainer);
invFundOpenBtn?.addEventListener('click', ()=>{ invFundStatus.textContent=''; invToggleModal(invFundModal, invFundBackdrop, true); });
invFundClose?.addEventListener('click', ()=> invToggleModal(invFundModal, invFundBackdrop, false));
invFundCancel?.addEventListener('click', ()=> invToggleModal(invFundModal, invFundBackdrop, false));
invFundBackdrop?.addEventListener('click', (e)=>{ if (e.target===invFundBackdrop) invToggleModal(invFundModal, invFundBackdrop, false); });
invFundSave?.addEventListener('click', invAddFunds);
invCatalogOpenBtn?.addEventListener('click', ()=> invToggleModal(invCatalogModal, invCatalogBackdrop, true));
invCatalogClose?.addEventListener('click', ()=> invToggleModal(invCatalogModal, invCatalogBackdrop, false));
invCatalogBackdrop?.addEventListener('click', (e)=>{ if (e.target===invCatalogBackdrop) invToggleModal(invCatalogModal, invCatalogBackdrop, false); });
invSearchBtn.addEventListener('click', invDoSearch);
invClearBtn.addEventListener('click', invClearSearch);
invCatEl.addEventListener('change', ()=>{
  const val = invCatEl.value;
  INV_FILTERED = val && val !== "__all" ? INV_LAST_RESULTS.filter(r=>invGetRowCategory(r)===val) : INV_LAST_RESULTS.slice();
  invRenderResults();
});
invKindEl.addEventListener('change', invClearSearch);
document.getElementById('inv-item-close').addEventListener('click', closeInvItemModal);
invItemBackdrop.addEventListener('click', (e)=>{ if (e.target===invItemBackdrop) closeInvItemModal(); });

arcApplyBtn.addEventListener('click', async ()=>{
  const arcId = arcSelectEl.value || '';
  try{
    arcStatusEl.textContent = 'Saving archetype...';
    const res = await api('/characters/' + encodeURIComponent(CID), {
      method:'PUT',
      headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ archetype_id: arcId, stats: CHAR.stats })
    });
    CHAR.archetype_id = arcId;
    CHAR.archetype_rank = _archetypeRankForLevel(CHAR.level);
    CHAR.computed_archetype_abilities = res.character?.computed_archetype_abilities || [];
    COMPUTED_ARC_ABILITIES = CHAR.computed_archetype_abilities;
    renderArchetypePanel();
    arcStatusEl.textContent = 'Archetype saved.';
  }catch(e){
    arcStatusEl.textContent = 'Save failed: ' + e.message;
  }
});

slLoadBtn.addEventListener('click', ()=> loadSpellListById(slSelectEl.value));
slSelectEl.addEventListener('change', ()=> loadSpellListById(slSelectEl.value));
slCreateBtn?.addEventListener('click', createAndLinkSpellList);
slDupBtn.addEventListener('click', duplicateAndLinkSpellList);
slOpenAddBtn.addEventListener('click', openSpellAddModal);
slAddClose.addEventListener('click', closeSpellAddModal);
slAddCancel.addEventListener('click', closeSpellAddModal);
slAddBackdrop.addEventListener('click', (e)=>{ if (e.target===slAddBackdrop) closeSpellAddModal(); });
slAddMenuBtn?.addEventListener('click', ()=>{
  if (!slAddMenu) return;
  const shown = slAddMenu.style.display !== 'none';
  slAddMenu.style.display = shown ? 'none' : 'flex';
});
slQuickAddBtn?.addEventListener('click', ()=>{ if (slAddMenu) slAddMenu.style.display = 'none'; quickAddSchools(); });
slManualAddBtn?.addEventListener('click', ()=>{ if (slAddMenu) slAddMenu.style.display = 'none'; openManualAddModal(); });
slSchSortBtn?.addEventListener('click', async ()=>{
  const mode = slSchOrderEl ? slSchOrderEl.value : 'manual';
  const sorted = await applyAddedSchoolSort(mode);
  if (!sorted) await renderAddedSchools();
});
slSchOrderEl?.addEventListener('change', ()=>{ if (slSchOrderEl.value === 'manual') setSchoolOrderStatus(''); });
slSchApply?.addEventListener('click', applyManualAdd);
slSchCancel?.addEventListener('click', ()=> toggleSchoolModal(false));
slSchClose?.addEventListener('click', ()=> toggleSchoolModal(false));
slSchBackdrop?.addEventListener('click', (e)=>{ if (e.target===slSchBackdrop) toggleSchoolModal(false); });
xpAddBtn?.addEventListener('click', ()=>{
  const raw = prompt('Add how much XP?', '100');
  if (raw === null) return;
  const val = Math.floor(Number(raw)||0);
  if (val > 0) addXp(val);
});
levelSetBtn?.addEventListener('click', ()=>{
  const raw = prompt('Set level (1-100)', String(CHAR.level||1));
  if (raw === null) return;
  const val = Math.max(1, Math.min(MAX_LEVEL, Math.floor(Number(raw)||1)));
  setLevelManual(val);
});
xpLedgerBtn?.addEventListener('click', ()=> toggleXpLedger(true));
xpLedgerClose?.addEventListener('click', ()=> toggleXpLedger(false));
xpLedgerBackdrop?.addEventListener('click', (e)=>{ if (e.target===xpLedgerBackdrop) toggleXpLedger(false); });
slSearchBtn.addEventListener('click', renderSpellSearch);
slSearchQ.addEventListener('keydown', (e)=>{ if (e.key==='Enter') renderSpellSearch(); });
craftSearchBtn?.addEventListener('click', searchCraftomancySpells);
craftSearchQ?.addEventListener('keydown', (e)=>{ if (e.key==='Enter') searchCraftomancySpells(); });
craftSupremeEl?.addEventListener('change', renderCraftSearchResults);
craftAddClose?.addEventListener('click', closeCraftomancyModal);
craftAddCancel?.addEventListener('click', closeCraftomancyModal);
craftAddBackdrop?.addEventListener('click', (e)=>{ if (e.target===craftAddBackdrop) closeCraftomancyModal(); });

function renderSearchResults(arr){
  abiResultsEl.innerHTML = '';
  if (!arr.length){ abiResultsEl.innerHTML = '<div class="muted">No results.</div>'; return; }
  for (const a of arr){
    const div = document.createElement('div');
    div.className = 'abi-item';
    const costText = abilityCostText(a);
    div.innerHTML = `
      <div class="grow">
        <div><strong>${a.name}</strong></div>
        <div class="muted" style="font-size:.85rem">${a.description_html || a.description || ''}</div>
        ${costText ? `<div class="muted" style="font-size:.8rem">Cost: ${costText}</div>` : ''}
      </div>
      <span class="tag">${a.type||''}</span>
      <span class="tag">${a.source_category||''}</span>
      <button>Add</button>
    `;
    div.querySelector('button').addEventListener('click', ()=> addAbilityToChar(a.id));
    abiResultsEl.appendChild(div);
  }
}

async function resolveAssignedAbilities(){
  // Normalize ability ids and drop empties so we don't hit the bulk endpoint with invalid ids.
  const ids = (CHAR.abilities||[]).map(id=> String(id||'').trim()).filter(Boolean);
  CHAR.abilities = ids;
  Object.keys(ABILITY_CHOICES).forEach(id=>{ if (!ids.includes(String(id))) delete ABILITY_CHOICES[id]; });
  if (!ids.length){ ASSIGNED = []; return; }
  const uniqueIds = Array.from(new Set(ids));
  const qs = '?ids=' + encodeURIComponent(uniqueIds.join(','));
  const bulk = await api('/abilities/bulk'+qs);
  const byId = {};
  (bulk.abilities||[]).forEach(a=>{ if (a && a.id) byId[a.id] = a; });
  let assigned = ids.map(id=> byId[id]).filter(Boolean); // preserve order and duplicates
  assigned = collapseAbilityReplacements(assigned);
  ASSIGNED = assigned;
  trackUpdatedAt("abilities", ASSIGNED, "Abilities");
}
function abilityHasChoice(ab){
  return !!((ab?.passive?.modifiers||[]).find(m=> String(m.target||'').startsWith('choice:') || (m.group || '').trim()));
}
function skillOptionsList(){
  const out = [];
  for (const c of CHARACS){
    for (const s of c.skills){
      out.push({ key:`skills.${c.key}.${s}`, label:`${s} (${c.name})`, charKey:c.key });
    }
  }
  return out;
}
function charKeyForSkillName(name){
  const norm = normSkillKey(name);
  if (SKILL_TO_CHAR[norm]) return SKILL_TO_CHAR[norm];
  const lcName = String(name||'').toLowerCase();
  const hit = CHARACS.find(c=> (c.skills||[]).some(s=> String(s||'').toLowerCase() === lcName));
  return hit ? hit.key : '';
}
async function choiceItemsForKind(kind, restrict, allowed){
  const rset = new Set((restrict||[]).map(x=> String(x).trim().toLowerCase()));
  const aset = new Set((allowed||[]).map(x=> String(x).trim().toLowerCase()));
  const useAllow = aset.size > 0;
  const isRestricted = (...cands)=>{
    for (const c of cands){
      if (c == null) continue;
      const base = String(c).trim().toLowerCase();
      if (!base) continue;
      if (rset.has(base)) return true;
      const noPrefix = base.replace(/^(skills|schools|intensities)\./,'');
      if (rset.has(noPrefix)) return true;
      const beforeParen = base.split('(')[0].trim();
      if (beforeParen && rset.has(beforeParen)) return true;
      const noDots = noPrefix.replace(/[\\.\\s]+/g,'');
      if (noDots && rset.has(noDots)) return true;
    }
    return false;
  };
  const isAllowed = (...cands)=>{
    if (!useAllow) return true;
    for (const c of cands){
      if (c == null) continue;
      const base = String(c).trim().toLowerCase();
      if (!base) continue;
      if (aset.has(base)) return true;
      const noPrefix = base.replace(/^(skills|schools|intensities)\./,'');
      if (aset.has(noPrefix)) return true;
    }
    return false;
  };
  if (kind === 'skill_ms'){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const skillsWithSchools = new Set(
      (SCHOOLS || [])
        .filter(s=> s.linked_skill)
        .map(s=> normSkillKey(s.linked_skill))
    );
    if (!skillsWithSchools.size) return [];
    return skillOptionsList().filter(o=>{
      const skillName = (o.label || '').split('(')[0].trim();
      const norm = normSkillKey(skillName);
      if (skillsWithSchools.size && !skillsWithSchools.has(norm)) return false;
      return !isRestricted(o.key, o.label, o.charKey, norm, skillName);
    });
  }
  if (kind === 'char_skill'){
    return skillOptionsList().filter(o=>{
      const skillName = (o.label || '').split('(')[0].trim();
      const norm = normSkillKey(skillName);
      if (!isAllowed(o.key, o.label, o.charKey, norm, skillName)) return false;
      return !isRestricted(o.charKey, skillName, norm, o.key, o.label);
    });
  }
  const charGroup = kind.match(/^skills\.by_char\.(.+)$/i);
  if (charGroup){
    const key = charGroup[1].toLowerCase();
    const hit = CHARACS.find(c=> c.key === key);
    if (!hit) return [];
    return (hit.skills || []).map(sk=>({ key:`skills.${key}.${sk}`, label:`${sk} (${hit.name||hit.label||key})` })).filter(o=>{
      const skillName = (o.label || '').split('(')[0].trim();
      const norm = normSkillKey(skillName);
      if (!isAllowed(o.key, o.label, key, norm, skillName)) return false;
      return !isRestricted(o.key, o.label, key, norm, skillName);
    });
  }
  if (kind === 'nature_ms' || kind === 'magic_weapon' || kind === 'magic_spell'){
    if (kind === 'nature_ms' && !SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const linkedNatures = new Set();
    if (kind === 'nature_ms' && SCHOOLS.length){
      (SCHOOLS||[]).forEach(s=> (s.linked_intensities||[]).forEach(n=> linkedNatures.add(lc(n))));
    }
    return INTENSITIES.map(n=>({ key:`intensities.${n}`, label:n })).filter(o=>{
      const base = lc(o.label);
      if (kind === 'nature_ms' && linkedNatures.size && !linkedNatures.has(base)) return false;
      if (!isAllowed(o.key, o.label, base)) return false;
      return !isRestricted(o.label, o.key, base);
    });
  }
  if (kind === 'intensity_any'){
    return INTENSITIES.map(n=>({ key:`intensities.${n}`, label:n })).filter(o=> !isRestricted(o.key, o.label));
  }
  const schoolSkill = kind.match(/^schools\.by_skill\.(.+)$/i);
  if (schoolSkill){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const skillName = schoolSkill[1];
    return (SCHOOLS||[]).filter(s=> String(s.linked_skill || '').toLowerCase() === String(skillName).toLowerCase())
      .map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||'simple'})` }))
      .filter(o=>{
        const baseLabel = (o.label || '').split('(')[0].trim().toLowerCase();
        const rawId = String(o.key||'').replace(/^schools\./i,'');
        if (!isAllowed(o.key, baseLabel, rawId)) return false;
        return !isRestricted(o.label, o.key, baseLabel, rawId);
      });
  }
  const schoolNature = kind.match(/^schools\.by_nature\.(.+)$/i);
  if (schoolNature){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    const nature = schoolNature[1];
    return (SCHOOLS||[]).filter(s=> (s.linked_intensities || []).some(n=> String(n).toLowerCase() === String(nature).toLowerCase()))
      .map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||'simple'})` }))
      .filter(o=>{
        const baseLabel = (o.label || '').split('(')[0].trim().toLowerCase();
        const rawId = String(o.key||'').replace(/^schools\./i,'');
        if (!isAllowed(o.key, baseLabel, rawId)) return false;
        return !isRestricted(o.label, o.key, baseLabel, rawId);
      });
  }
  if (kind === 'school_ms' || kind === 'school_any'){
    if (!SCHOOLS.length){ try{ await fetchSchools(); }catch{} }
    return (SCHOOLS||[]).map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||'simple'})` })).filter(o=>{
      const baseLabel = (o.label || '').split('(')[0].trim().toLowerCase();
      const rawId = String(o.key||'').replace(/^schools\./i,'');
      if (!isAllowed(o.key, baseLabel, rawId)) return false;
      return !isRestricted(o.label, o.key, baseLabel, rawId);
    });
  }
  return [];
}

async function openGroupModal(ab){
  const groups = abilityGroups(ab);
  if (!groups.length) return false;
  try{ if (!SCHOOLS.length) await fetchSchools(); }catch{}
  const stored = abilityGroupSelections(ab);

  choiceTitle.textContent = `Configure: ${ab.name || 'Ability'}`;
  choiceBody.innerHTML = '';
  choiceModal.classList.remove('hidden'); choiceModal.classList.add('open'); choiceBackdrop.classList.add('open');

  const blocks = [];
  groups.forEach(g=>{
    const allowedIdx = g.options.map(o=> o.idx);
    const max = g.max || 1;
    const block = document.createElement('div');
    block.className = 'panel';
    const maxLabel = max > 0 ? `max ${max}` : 'no limit';
    block.innerHTML = `<strong>${g.name}</strong> <span class=\"muted\">(${maxLabel})</span>`;
    const list = document.createElement('div');
    list.style.display = 'grid';
    list.style.gridTemplateColumns = 'repeat(auto-fit,minmax(240px,1fr))';
    list.style.gap = '6px';
    const counter = document.createElement('div');
    counter.className = 'muted';
    counter.style.marginTop = '6px';

    const savedArr = Array.isArray(stored[g.name]) ? stored[g.name] : [];
    let selected = new Set(savedArr.map(x=> Number(x)).filter(i=> allowedIdx.includes(i)));
    if (!selected.size){
      const limit = max > 0 ? max : allowedIdx.length;
      allowedIdx.slice(0, limit).forEach(i=> selected.add(i));
    }

    const updateCounter = ()=>{
      const checked = list.querySelectorAll(`input[data-group=\"${g.name}\"]:checked`).length;
      counter.textContent = `Selected ${checked}${max>0?` / ${max}`:''}`;
    };

    g.options.forEach(opt=>{
      const row = document.createElement('label');
      row.style.display = 'flex';
      row.style.gap = '8px';
      row.style.alignItems = 'center';
      row.style.margin = '2px 0';
      const input = document.createElement('input');
      input.type = max === 1 ? 'radio' : 'checkbox';
      input.name = `group-${g.name}`;
      input.dataset.group = g.name;
      input.value = String(opt.idx);
      input.checked = selected.has(opt.idx);
      input.addEventListener('change', ()=>{
        const checked = list.querySelectorAll(`input[data-group=\"${g.name}\"]:checked`);
        if (max === 1){
          checked.forEach(cb=>{ if (cb !== input) cb.checked = false; });
        }else if (max > 0 && checked.length > max){
          input.checked = false;
        }
        updateCounter();
      });
      row.appendChild(input);
      const span = document.createElement('span');
      span.textContent = `${prettyTargetLabel(opt.mod.target)} (${(opt.mod.mode||'add')} ${opt.mod.value>=0?'+':''}${opt.mod.value})`;
      row.appendChild(span);
      list.appendChild(row);
    });

    block.appendChild(list);
    block.appendChild(counter);
    updateCounter();
    blocks.push({ group:g.name, max, node:list, counter });
    choiceBody.appendChild(block);
  });

  return new Promise(resolve=>{
    const close = ()=>{
      choiceModal.classList.add('hidden'); choiceModal.classList.remove('open'); choiceBackdrop.classList.remove('open');
      resolve(false);
    };
    const save = ()=>{
      const selections = {};
      for (const b of blocks){
        const picks = Array.from(b.node.querySelectorAll('input[data-group]')).filter(cb=> cb.checked).map(cb=> Number(cb.value));
        if (!picks.length){
          alert(`Select at least one option for ${b.group}.`);
          return;
        }
        if (b.max > 0 && picks.length > b.max){
          alert(`Select at most ${b.max} option(s) for ${b.group}.`);
          return;
        }
        selections[b.group] = picks;
      }
      setAbilityGroupSelections(ab.id, selections);
      queueSave();
      recomputePassiveAgg(); renderStatistics(); updateDerived();
      choiceModal.classList.add('hidden'); choiceModal.classList.remove('open'); choiceBackdrop.classList.remove('open');
      resolve(true);
    };
    choiceClose.onclick = close;
    choiceCancel.onclick = close;
    choiceBackdrop.onclick = (e)=>{ if (e.target===choiceBackdrop) close(); };
    choiceSave.onclick = save;
  });
}

async function openChoiceModalGeneric(mods, existingMap = {}, saveHandler = ()=>{}, { titleText = 'Configure choices', entityLabel = '' } = {}){
  if (!mods.length) return false;
  try{ if (!SCHOOLS.length) await fetchSchools(); }catch{}
  choiceTitle.textContent = titleText || 'Configure choices';
  choiceBody.innerHTML = '<div class="muted">Loading choices...</div>';
  choiceModal.classList.remove('hidden'); choiceModal.classList.add('open'); choiceBackdrop.classList.add('open');

  const blocks = [];
  choiceBody.innerHTML = '';

  const normalizeMsBase = (kind, picks)=>{
    if (!picks || !picks.length || !SCHOOLS.length) return '';
    const first = String(picks[0]||'').replace(/^schools\./i, '');
    const school = (SCHOOLS||[]).find(s=> String(s.id||'').toLowerCase() === first.toLowerCase() || String(s.name||'').toLowerCase() === first.toLowerCase());
    if (!school) return '';
    if (kind === 'skill_ms' && school.linked_skill){
      const ck = charKeyForSkillName(school.linked_skill);
      return ck ? `skills.${ck}.${school.linked_skill}` : '';
    }
    if (kind === 'nature_ms'){
      const n = (school.linked_intensities || [])[0];
      return n ? `intensities.${n}` : '';
    }
    return '';
  };
  const buildMsBaseOptions = (kind, restrict=[])=>{
    const rset = new Set((restrict||[]).map(x=> String(x).toLowerCase()));
    if (kind === 'skill_ms'){
      const map = new Map();
      (SCHOOLS||[]).forEach(s=>{
        if (!s.linked_skill) return;
        const ck = charKeyForSkillName(s.linked_skill);
        if (!ck) return;
        const norm = normSkillKey(s.linked_skill);
        if (rset.has(norm) || rset.has(lc(s.linked_skill)) || rset.has(ck.toLowerCase())) return;
        const key = `skills.${ck}.${s.linked_skill}`;
        const list = map.get(key) || [];
        list.push(s.name || s.id);
        map.set(key, list);
      });
      return Array.from(map.entries()).map(([key, schools])=>{
        const parts = key.split('.');
        const skillName = parts.slice(2).join('.');
        const ck = parts[1] || '';
        const label = `${skillName} (${title(ck)}) - Schools: ${Array.from(new Set(schools)).join(', ')}`;
        return { key, label };
      }).sort((a,b)=> a.label.localeCompare(b.label));
    }
    if (kind === 'nature_ms'){
      const map = new Map();
      (SCHOOLS||[]).forEach(s=>{
        (s.linked_intensities || []).forEach(n=>{
          const norm = lc(n);
          if (rset.has(norm) || rset.has(`intensities.${norm}`)) return;
          const key = `intensities.${n}`;
          const list = map.get(key) || [];
          list.push(s.name || s.id);
          map.set(key, list);
        });
      });
      return Array.from(map.entries()).map(([key, schools])=>{
        const label = `${key.replace(/^intensities\./i,'')} - Schools: ${Array.from(new Set(schools)).join(', ')}`;
        return { key, label };
      }).sort((a,b)=> a.label.localeCompare(b.label));
    }
    return [];
  };
  const schoolsForMsBase = (kind, baseKey, restrict=[])=>{
    if (!baseKey) return [];
    const rset = new Set((restrict||[]).map(x=> String(x).toLowerCase()));
    const matches = (SCHOOLS||[]).filter(s=>{
      if (kind === 'skill_ms'){
        const skillName = baseKey.split('.').slice(2).join('.');
        return lc(s.linked_skill) === lc(skillName);
      }
      if (kind === 'nature_ms'){
        const nature = baseKey.replace(/^intensities\./i,'');
        return (s.linked_intensities || []).some(n=> lc(n) === lc(nature));
      }
      return false;
    });
    return matches.map(s=>({ key:`schools.${s.id}`, label:`${s.name} (${s.school_type||'simple'})` })).filter(opt=>{
      const base = (opt.label || '').split('(')[0].trim().toLowerCase();
      const key = String(opt.key||'').toLowerCase();
      const plain = key.replace(/^schools\./i,'');
      return !(rset.has(base) || rset.has(key) || rset.has(plain));
    });
  };

  for (const m of mods){
    const kind = String(m.target||'').replace('choice:','');
    const restrict = normalizeRestrict(m);
    const allowed = normalizeChoiceAllowed(m);
    const max = Number(m.choice?.max_choices||0);
    const block = document.createElement('div');
    block.className = 'panel';
    const title = document.createElement('div');
    const srcNote = m.__source ? `<div class="muted" style="font-size:0.85rem;">${m.__source}</div>` : '';
    title.innerHTML = `<strong>${kind.replace(/_/g,' ')}</strong> <span class="muted">(max ${max||'no limit'})</span>${srcNote}`;
    block.appendChild(title);

    if (kind === 'skill_ms' || kind === 'nature_ms'){
      const state = normalizeChoiceEntry(existingMap[kind]);
      const baseOpts = buildMsBaseOptions(kind, restrict);
      const baseWrap = document.createElement('div');
      baseWrap.className = 'row';
      const baseLabel = document.createElement('label');
      baseLabel.className = 'muted';
      baseLabel.textContent = kind === 'skill_ms' ? 'Select skill' : 'Select nature';
      const baseSelect = document.createElement('select');
      baseSelect.innerHTML = '<option value="">-- choose --</option>';
      baseOpts.forEach(opt=>{
        const o = document.createElement('option');
        o.value = opt.key; o.textContent = opt.label;
        baseSelect.appendChild(o);
      });
      const inferredBase = state.base || normalizeMsBase(kind, state.picks);
      if (inferredBase && baseOpts.some(o=> o.key === inferredBase)){
        baseSelect.value = inferredBase;
      }
      baseWrap.appendChild(baseLabel);
      baseWrap.appendChild(baseSelect);

      const schoolsWrap = document.createElement('div');
      schoolsWrap.className = 'choice-wrap';
      schoolsWrap.style.display = 'grid';
      schoolsWrap.style.gridTemplateColumns = 'repeat(auto-fit,minmax(220px,1fr))';
      schoolsWrap.style.gap = '8px';

      const counter = document.createElement('div');
      counter.className = 'muted';
      counter.style.marginTop = '4px';

      const renderSchools = ()=>{
        schoolsWrap.innerHTML = '';
        const baseVal = baseSelect.value;
        if (!baseVal){
          const hint = document.createElement('div'); hint.className='muted'; hint.textContent='Choose a base option to see linked schools.'; schoolsWrap.appendChild(hint); counter.textContent='Selected 0'; return;
        }
        const schools = schoolsForMsBase(kind, baseVal, restrict);
        if (!schools.length){
          const empty = document.createElement('div'); empty.className='muted'; empty.textContent='No schools linked to that choice.'; schoolsWrap.appendChild(empty); counter.textContent='Selected 0'; return;
        }
        const picked = new Set(state.picks || []);
        schools.forEach(opt=>{
          const row = document.createElement('label');
          row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.margin='2px 0';
          const cb = document.createElement('input');
          cb.type='checkbox'; cb.dataset.kind = kind; cb.value = opt.key;
          cb.checked = picked.has(opt.key);
          row.appendChild(cb);
          const span = document.createElement('span'); span.textContent = opt.label; row.appendChild(span);
          cb.addEventListener('change', ()=>{
            const checked = schoolsWrap.querySelectorAll('input[type="checkbox"][data-kind]:checked').length;
            counter.textContent = `Selected ${checked}${max>0?` / ${max}`:''}`;
          });
          schoolsWrap.appendChild(row);
        });
        const hint = document.createElement('div'); hint.className='muted'; hint.textContent = max > 0 ? `Select up to ${max} school(s).` : 'Select any number of schools.'; schoolsWrap.appendChild(hint);
        const checked = schoolsWrap.querySelectorAll('input[type="checkbox"][data-kind]:checked').length;
        counter.textContent = `Selected ${checked}${max>0?` / ${max}`:''}`;
      };
      baseSelect.addEventListener('change', ()=>{ state.picks = []; renderSchools(); });
      renderSchools();

      block.appendChild(baseWrap);
      block.appendChild(schoolsWrap);
      block.appendChild(counter);

      blocks.push({
        kind,
        type:'ms',
        getValue: ()=>{
          const baseVal = baseSelect.value;
          if (!baseVal){
            alert('Select a base option first.');
            return { ok:false };
          }
          const checks = Array.from(schoolsWrap.querySelectorAll('input[type="checkbox"][data-kind]'));
          const selected = checks.filter(cb=>cb.checked).map(cb=>cb.value);
          if (!selected.length){
            alert('Select at least one school.');
            return { ok:false };
          }
          if (max > 0 && selected.length > max){
            alert(`Select at most ${max} option(s) for ${kind.replace(/_/g,' ')}.`);
            return { ok:false };
          }
          return { ok:true, value:{ base: baseVal, picks: selected } };
        }
      });
      choiceBody.appendChild(block);
      continue;
    }

    const items = await choiceItemsForKind(kind, restrict, allowed);
    if (!items.length){
      const empty = document.createElement('div'); empty.className='muted'; empty.textContent='No options available.'; block.appendChild(empty);
    }else{
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(auto-fit,minmax(240px,1fr))';
      grid.style.gap = '6px';
      const counter = document.createElement('div'); counter.className='muted'; counter.style.marginTop='6px';
      const updateCounter = ()=>{
        const checked = block.querySelectorAll('input[type="checkbox"][data-kind]:checked').length;
        counter.textContent = `Selected ${checked}${max>0?` / ${max}`:''}`;
      };
      items.forEach(opt=>{
        const row = document.createElement('label');
        row.style.display='flex'; row.style.gap='8px'; row.style.alignItems='center'; row.style.margin='2px 0';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.dataset.kind = kind; cb.value = opt.key;
        if (normalizeChoiceEntry(existingMap[kind]).picks.includes(opt.key)) cb.checked = true;
        cb.addEventListener('change', updateCounter);
        row.appendChild(cb);
        const span = document.createElement('span'); span.textContent = opt.label; row.appendChild(span);
        grid.appendChild(row);
      });
      block.appendChild(grid);
      block.appendChild(counter);
      updateCounter();
    }
    blocks.push({ kind, type:'simple', node: block, max });
    choiceBody.appendChild(block);
  }

  return new Promise(resolve=>{
    const close = ()=>{
      choiceModal.classList.add('hidden'); choiceModal.classList.remove('open'); choiceBackdrop.classList.remove('open');
      resolve(false);
    };
    const save = ()=>{
      const selections = {};
      for (const b of blocks){
        if (b.type === 'ms'){
          const res = b.getValue();
          if (!res.ok) return;
          selections[b.kind] = res.value;
          continue;
        }
        const boxes = b.node.querySelectorAll('input[type="checkbox"][data-kind]');
        const arr = [];
        boxes.forEach(box=>{ if (box.checked) arr.push(box.value); });
        if (b.max > 0 && arr.length > b.max){
          alert(`Select at most ${b.max} option(s) for ${b.kind.replace(/_/g,' ')}.`);
          return;
        }
        selections[b.kind] = arr;
      }
      saveHandler(selections);
      choiceModal.classList.add('hidden'); choiceModal.classList.remove('open'); choiceBackdrop.classList.remove('open');
      resolve(true);
    };
    choiceClose.onclick = close;
    choiceCancel.onclick = close;
    choiceBackdrop.onclick = (e)=>{ if (e.target===choiceBackdrop) close(); };
    choiceSave.onclick = save;
  });
}

// Ability choice modal wrapper
async function openChoiceModal(ab){
  const hasGroups = abilityGroups(ab).length > 0;
  let opened = false;
  if (hasGroups){
    const res = await openGroupModal(ab);
    opened = opened || res;
  }
  const { active: activeGroups } = resolveGroupSelections(ab);
  const choiceMods = (ab.passive?.modifiers||[]).map((m, idx)=>({ ...m, __idx: idx }))
    .filter(m=> {
      if (!String(m.target||'').startsWith('choice:')) return false;
      const grouped = (m.group || '').trim();
      if (!grouped) return true;
      return activeGroups.has(m.__idx);
    });
  if (choiceMods.length){
    const res = await openChoiceModalGeneric(choiceMods, ABILITY_CHOICES[ab.id] || {}, (selections)=>{
      const existing = ABILITY_CHOICES[ab.id] || {};
      ABILITY_CHOICES[ab.id] = { ...existing, ...selections, _groups: existing._groups || {} };
      queueSave();
      recomputePassiveAgg(); renderStatistics(); updateDerived();
    }, { titleText: `Configure: ${ab.name || 'Ability'}` });
    opened = opened || res;
  }
  return opened;
}

// Inventory item choice modal wrapper
async function openItemChoiceModal(it){
  const mods = itemChoiceMods(it);
  if (!mods.length) return false;
  const key = itemChoiceKey(it);
  return openChoiceModalGeneric(mods, ITEM_CHOICES[key] || {}, (selections)=>{
    if (!key) return;
    ITEM_CHOICES[key] = selections;
    queueSave();
    recomputePassiveAgg(); renderStatistics(); updateDerived();
  }, { titleText: `Configure: ${it.alt_name || it.name || 'Item'}` });
}

  async function openUpgradeChoiceModal(it, upgrade, idx){
    const upgId = upgrade?.id || upgrade?.key || upgrade;
    const meta = (window.UPGRADE_META || {})[upgId] || {};
    const choiceKey = upgradeChoiceKey(it, upgrade, idx);
    const mods = upgradeChoiceMods(upgrade, meta, choiceKey);
    if (!mods.length) return false;
    if (!choiceKey) return false;
    return openChoiceModalGeneric(mods, ITEM_CHOICES[choiceKey] || {}, (selections)=>{
      ITEM_CHOICES[choiceKey] = selections;
      queueSave();
      recomputePassiveAgg(); renderStatistics(); updateDerived();
    }, { titleText: `Configure: ${meta.name || upgrade?.name || 'Upgrade'}` });
  }

async function addAbilityToChar(aid){
  if (!Array.isArray(CHAR.abilities)) CHAR.abilities = [];
  const key = String(aid);
  CHAR.abilities.push(key);
  queueSave();
  await resolveAssignedAbilities();
  const ab = ASSIGNED.find(x=> String(x.id) === key);
  if (ab && abilityHasChoice(ab)){
    await openChoiceModal(ab);
  }
  recomputePassiveAgg();
  renderAbilitiesTab();
  renderStatistics();
  updateDerived();
}

async function removeAbilityFromChar(aid){
  const target = String(aid||'').trim();
  const arr = (CHAR.abilities || []).map(id=> String(id||'').trim()).filter(Boolean);
  const idx = arr.indexOf(target);
  if (idx >= 0) arr.splice(idx, 1);
  CHAR.abilities = arr;
  if (getSpeciesAbilityId() === target){
    setSpeciesAbilityId('');
    if (speciesSelectEl) speciesSelectEl.value = '';
    if (speciesStatusEl) speciesStatusEl.textContent = 'Species cleared.';
    updateSpeciesDesc('');
  }
  if (getBoonAbilityId() === target){
    setBoonAbilityId('');
    if (boonSelectEl) boonSelectEl.value = '';
    if (boonStatusEl) boonStatusEl.textContent = 'Boon cleared.';
    updateBoonDesc('');
  }
  if (ABILITY_CHOICES[target]) delete ABILITY_CHOICES[target];
  queueSave();
  await resolveAssignedAbilities();
  recomputePassiveAgg();
  renderAbilitiesTab();
  renderStatistics();
  updateDerived();
}

function abilityCostText(ab){
  const active = ab?.active || {};
  const costs = active.costs || {};
  const suffix = active.costs_active ? " (A)" : "";
  const parts = [];
  const push = (val, label)=>{
    const num = Number(val);
    if (!Number.isFinite(num) || num === 0) return;
    parts.push(`${num} ${label}${suffix}`);
  };
  push(costs.HP, "HP");
  push(costs.EN, "EN");
  push(costs.FO, "FO");
  push(costs.MO, "MO");
  push(costs.TX, "TX");
  if (costs.other_label && costs.other_value != null){
    push(costs.other_value, costs.other_label);
  }
  return parts.join(" || ");
}

function collectDisplayAbilities(){
  const combined = (ASSIGNED || []).slice();
  const seen = new Set((ASSIGNED || []).map(a=> String(a?.id || '')));
  const addUnique = (list)=>{
    (list || []).forEach(a=>{
      const id = String(a?.id || '');
      if (!id || seen.has(id)) return;
      seen.add(id);
      combined.push(a);
    });
  };
  addUnique(ARC_ASSIGNED);
  addUnique(EXP_ASSIGNED);
  addUnique(DIMA_ASSIGNED);
  return combined;
}

function moveSubsetOrder(orderIds, subsetIds, targetId, direction){
  const order = (orderIds || []).map(String);
  const subset = (subsetIds || []).map(String);
  if (!order.length || subset.length < 2) return orderIds;
  const idx = subset.indexOf(String(targetId));
  if (idx < 0) return orderIds;
  const next = direction === 'up' ? idx - 1 : idx + 1;
  if (next < 0 || next >= subset.length) return orderIds;
  const updatedSubset = subset.slice();
  updatedSubset[idx] = subset[next];
  updatedSubset[next] = subset[idx];
  const subsetSet = new Set(subset);
  const updatedOrder = order.slice();
  let cursor = 0;
  updatedOrder.forEach((id, i)=>{
    if (subsetSet.has(id)){
      updatedOrder[i] = updatedSubset[cursor++];
    }
  });
  return updatedOrder;
}

function assignedAbilityTypeMap(){
  const map = {};
  (ASSIGNED || []).forEach(a=>{
    const id = String(a?.id || '').trim();
    if (!id) return;
    map[id] = String(a?.type || '').toLowerCase() === 'active' ? 'active' : 'passive';
  });
  return map;
}

function spellDisplayName(sp, metaMap){
  const meta = metaMap[String(sp?.id || '')] || {};
  return meta.alt_name || sp?.name || sp?.id || 'Spell';
}

function abilityOrderKey(bucket){
  return `${ABI_ORDER_STORAGE_PREFIX}${CID || 'unknown'}:${bucket || 'unknown'}`;
}
function loadAbilityOrder(bucket){
  try{
    const raw = localStorage.getItem(abilityOrderKey(bucket));
    const parsed = raw ? JSON.parse(raw) : [];
    return Array.isArray(parsed) ? parsed.map(String) : [];
  }catch{
    return [];
  }
}
function saveAbilityOrder(bucket, order){
  try{ localStorage.setItem(abilityOrderKey(bucket), JSON.stringify(order || [])); }catch{}
}
function applyAbilityManualOrder(list, bucket){
  const order = loadAbilityOrder(bucket);
  if (!order.length) return list;
  const remaining = (list || []).slice();
  const out = [];
  order.forEach(id=>{
    const idx = remaining.findIndex(a=> String(a?.id || '') === String(id));
    if (idx >= 0){
      out.push(remaining[idx]);
      remaining.splice(idx, 1);
    }
  });
  return out.concat(remaining);
}
function updateAssignedOrderFromBucket(bucketType, orderedIds){
  if (!CHAR || !Array.isArray(CHAR.abilities)) return;
  const current = (CHAR.abilities || []).map(String).filter(Boolean);
  if (!current.length) return;
  const typeMap = assignedAbilityTypeMap();
  const orderedSubset = (orderedIds || []).filter(id => typeMap[id] === bucketType);
  if (!orderedSubset.length) return;
  let cursor = 0;
  const updated = current.map(id=>{
    if (typeMap[id] !== bucketType) return id;
    const next = orderedSubset[cursor++];
    return next || id;
  });
  CHAR.abilities = updated;
  queueSave();
}
function moveAbilityInBucket(index, direction, bucketType, list){
  const orderIds = (list || []).map(a=> String(a?.id || '')).filter(Boolean);
  const idx = Number(index);
  if (!Number.isFinite(idx) || idx < 0 || idx >= orderIds.length) return;
  const next = direction === 'up' ? idx - 1 : idx + 1;
  if (next < 0 || next >= orderIds.length) return;
  const updated = orderIds.slice();
  updated.splice(next, 0, updated.splice(idx, 1)[0]);
  saveAbilityOrder(bucketType, updated);
  updateAssignedOrderFromBucket(bucketType, updated);
  if (bucketType === 'active'){
    ABI_SORT_ACTIVE = 'manual';
    if (abiActiveOrderEl) abiActiveOrderEl.value = 'manual';
  }else{
    ABI_SORT_PASSIVE = 'manual';
    if (abiPassiveOrderEl) abiPassiveOrderEl.value = 'manual';
  }
  renderAbilitiesTab();
}

function getSpellOrderIds(list, metaMap){
  const withOrder = [];
  const withoutOrder = [];
  (list || []).forEach((sp, idx)=>{
    const id = String(sp?.id || '').trim();
    if (!id) return;
    const rawOrder = metaMap[id]?.order;
    const order = Number(rawOrder);
    if (Number.isFinite(order)){
      withOrder.push({ id, order, idx });
    }else{
      withoutOrder.push({ id, idx });
    }
  });
  if (!withOrder.length){
    return (list || []).map(sp=> String(sp?.id || '')).filter(Boolean);
  }
  withOrder.sort((a,b)=> (a.order - b.order) || (a.idx - b.idx));
  return withOrder.map(x=> x.id).concat(withoutOrder.map(x=> x.id));
}

function applySpellSort(list, mode, metaMap){
  const sortMode = String(mode || '').toLowerCase();
  if (sortMode === 'az' || sortMode === 'za'){
    const sorted = (list || []).slice().sort((a,b)=>{
      const aName = spellDisplayName(a, metaMap);
      const bName = spellDisplayName(b, metaMap);
      return String(aName).localeCompare(String(bName), undefined, { sensitivity: 'base' });
    });
    if (sortMode === 'za') sorted.reverse();
    return sorted;
  }
  if (sortMode !== 'manual') return list;
  const orderIds = getSpellOrderIds(list, metaMap);
  const byId = {};
  (list || []).forEach(sp=>{
    const id = String(sp?.id || '').trim();
    if (id) byId[id] = sp;
  });
  return orderIds.map(id => byId[id]).filter(Boolean);
}

function setSpellOrder(orderIds){
  if (!Array.isArray(orderIds) || !orderIds.length) return;
  const metaMap = SPELLLIST_META.spell_meta || {};
  const updated = { ...metaMap };
  orderIds.forEach((id, idx)=>{
    const key = String(id || '').trim();
    if (!key) return;
    const cur = metaMap[key] || {};
    updated[key] = { ...cur, order: idx };
  });
  SPELLLIST_META.spell_meta = updated;
  saveSpellListMeta({ spell_meta: updated }).catch(()=>{});
}

function moveSpellOrder(id, direction, { onlyLearned = false } = {}){
  if (!SPELLLIST_SPELLS.length) return;
  const metaMap = SPELLLIST_META.spell_meta || {};
  const orderIds = getSpellOrderIds(SPELLLIST_SPELLS, metaMap);
  const subsetIds = orderIds.filter(spId => {
    if (!onlyLearned) return true;
    return (metaMap[spId]?.status || 'known') === 'learnt';
  });
  const updated = moveSubsetOrder(orderIds, subsetIds, id, direction);
  if (!updated || updated === orderIds) return;
  ABI_SORT_SPELLS = 'manual';
  if (abiSpellOrderEl) abiSpellOrderEl.value = 'manual';
  setSpellOrder(updated);
  renderAbilitySpellsBucket();
}

function applyAbilitySort(list, mode){
  const sortMode = String(mode || '').toLowerCase();
  if (sortMode !== 'az' && sortMode !== 'za') return list;
  const sorted = list.slice().sort((a,b)=>{
    const aName = String(a?.name || a?.id || '');
    const bName = String(b?.name || b?.id || '');
    return aName.localeCompare(bName, undefined, { sensitivity: 'base' });
  });
  if (sortMode === 'za') sorted.reverse();
  return sorted;
}

function renderAbilitiesBucket(el, list, { assignedIds, bucketType, sortMode } = {}){
  if (!el) return;
  el.innerHTML = '';
  if (!list.length){ el.innerHTML = '<div class="muted">--</div>'; return; }
  const manualMode = String(sortMode || '').toLowerCase() === 'manual';
  for (let idx = 0; idx < list.length; idx++){
    const a = list[idx];
    const id = String(a?.id || '');
    const canRemove = assignedIds ? assignedIds.has(id) : true;
    const canMove = !!bucketType;
    const isFirst = idx === 0;
    const isLast = idx === list.length - 1;
    const disableMove = !manualMode;
    const div = document.createElement('div');
    div.className = 'abi-item';
    const isPassive = (a.type||'').toLowerCase()!=='active';
    const hasChoice = abilityHasChoice(a);
    const desc = isPassive ? (a.passive?.description_html||a.passive?.description||a.description_html||a.description||'') : (a.description_html||a.description||'');
    const costText = abilityCostText(a);
    const titleKey = abilityColorKey(a);
    const titleText = a.name || a.id || 'Ability';
    div.innerHTML = `
      <div class="grow">
        <div><strong class="title-color-target">${titleText}</strong></div>
        <div class="muted" style="font-size:.85rem">${desc}</div>
        ${costText ? `<div class="muted" style="font-size:.8rem">Cost: ${costText}</div>` : ''}
      </div>
      <span class="tag">${a.type||''}</span>
      <span class="tag">${a.source_category||''}</span>
      <div class="row" style="gap:6px; flex-wrap:wrap;">
        ${canMove ? `
        <button class="btn small" data-move="up" data-id="${id}" title="${manualMode ? 'Move up' : 'Switch order to Manual to move'}" ${disableMove || isFirst ? 'disabled' : ''}>&#8593;</button>
        <button class="btn small" data-move="down" data-id="${id}" title="${manualMode ? 'Move down' : 'Switch order to Manual to move'}" ${disableMove || isLast ? 'disabled' : ''}>&#8595;</button>
        ` : ''}
        ${hasChoice ? '<button class="btn small mod-config" title="Configure choices">Configure</button>' : ''}
        ${canRemove ? '<button class="btn small mod-remove" title="Remove">X</button>' : ''}
      </div>
    `;
    registerTitleColorTarget(div.querySelector('.title-color-target'), titleKey, titleText);
    div.addEventListener('click', (e)=> handleInfoClick(e, ()=> openAbilityRoll(a, a.source_category || 'Ability')));
    if (canRemove){
      div.querySelector('.mod-remove')?.addEventListener('click', ()=> removeAbilityFromChar(a.id));
    }
    if (hasChoice){
      div.querySelector('.mod-config')?.addEventListener('click', ()=> openChoiceModal(a));
    }
    if (canMove && bucketType){
      div.querySelector('button[data-move="up"]')?.addEventListener('click', ()=> moveAbilityInBucket(idx, 'up', bucketType, list));
      div.querySelector('button[data-move="down"]')?.addEventListener('click', ()=> moveAbilityInBucket(idx, 'down', bucketType, list));
    }
    el.appendChild(div);
  }
}

function renderAbilitiesTab(){
  const docs = collectDisplayAbilities();
  const assignedIds = new Set((ASSIGNED||[]).map(a=> String(a?.id || '')));
  const passive   = docs.filter(a=> ((a.type||'').toLowerCase()!=='active'));
  const active    = docs.filter(a=> ((a.type||'').toLowerCase()==='active'));
  const sortedPassive = applyAbilitySort(passive, ABI_SORT_PASSIVE);
  const sortedActive = applyAbilitySort(active, ABI_SORT_ACTIVE);
  const orderedPassive = String(ABI_SORT_PASSIVE || '').toLowerCase() === 'manual'
    ? applyAbilityManualOrder(sortedPassive, 'passive')
    : sortedPassive;
  const orderedActive = String(ABI_SORT_ACTIVE || '').toLowerCase() === 'manual'
    ? applyAbilityManualOrder(sortedActive, 'active')
    : sortedActive;

  renderAbilitiesBucket(listPassiveEl,   orderedPassive, { assignedIds, bucketType: 'passive', sortMode: ABI_SORT_PASSIVE });
  renderAbilitiesBucket(listActiveEl,    orderedActive, { assignedIds, bucketType: 'active', sortMode: ABI_SORT_ACTIVE });
  renderAbilitySpellsBucket();
  updateTalentCounter();
  updateExpertiseCounters();
  updateCraftomancyCounter();
  renderCombatAbilityList();
  renderCombatEtUsage();
}

function fillPersonal(){
  const p = CHAR.stats.personal || {};
  pNickEl.value = p.nicknames || '';
  pHeightEl.value = p.height || '';
  pWeightEl.value = p.weight || '';
  pEloEl.value = p.elo || '';
  pRankEl.value = p.rank || '';
  pFriendsEl.innerHTML = p.friends || '';
  pEnemiesEl.innerHTML = p.enemies || '';
  pNotesEl.innerHTML = p.notes || '';
  pBackstoryEl.innerHTML = p.backstory || '';
}

function wirePersonal(){
  const bind = (el, key, { rich=false } = {}) => {
    el.addEventListener('input', ()=>{
      CHAR.stats.personal[key] = rich ? el.innerHTML : el.value;
      queueSave();
    });
  };
  bind(pNickEl, 'nicknames');
  bind(pHeightEl, 'height');
  bind(pWeightEl, 'weight');
  bind(pEloEl, 'elo');
  bind(pRankEl, 'rank');
  bind(pFriendsEl, 'friends', { rich:true });
  bind(pEnemiesEl, 'enemies', { rich:true });
  bind(pNotesEl, 'notes', { rich:true });
  bind(pBackstoryEl, 'backstory', { rich:true });
}

/* boot */
checkMe().then(async ()=>{
  await loadCharacter();
  await initCampaignChat();
}).catch((e)=>{ statusEl.textContent = 'Load failed: ' + (e?.message || e); });
wireRichTextPaste();
</script>










