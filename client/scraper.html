<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Import Effects (Admin/Moderator)</title>
  <link rel="stylesheet" href="/static/style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    .rich-editor { border:1px solid #333; border-radius:12px; background:#0f0f0f; }
    .rich-toolbar { display:flex; flex-wrap:wrap; gap:6px; padding:6px 8px; border-bottom:1px solid #1f1f1f; }
    .rich-toolbar button { padding:6px 8px; font-size:.9rem; border-radius:8px; border:1px solid #2d2d2d; background:#161616; color:#f3f3f3; cursor:pointer; }
    .rich-toolbar button:hover { background:#1f1f1f; }
    .rich-toolbar button:active { background:#222; }
    .rich-area { min-height:130px; padding:10px; outline:none; }
    .rich-area:empty:before { content: attr(data-placeholder); color:#777; }
    .rich-area table { width:100%; border-collapse:collapse; margin-top:6px; }
    .rich-area th, .rich-area td { border:1px solid #333; padding:6px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Import Effects</h1>

    <div class="home-card">
      <div style="display:grid; gap:10px; grid-template-columns: repeat(auto-fit,minmax(180px,1fr));">
        <div>
          <label for="school-name">School Name</label>
          <input id="school-name" type="text" placeholder="e.g. Destruction" />
        </div>
        <div>
          <label for="school-type">School Type</label>
          <select id="school-type">
            <option value="Complex">Complex</option>
            <option value="Simple">Simple</option>
          </select>
        </div>
        <div>
          <label for="range-type">Range Type</label>
          <select id="range-type">
            <option value="C">C</option><option value="B">B</option><option value="A">A</option>
          </select>
        </div>
        <div>
          <label for="aoe-type">AoE Type</label>
          <select id="aoe-type">
            <option value="C">C</option><option value="B">B</option><option value="A">A</option>
          </select>
        </div>
        <div style="display:flex;align-items:flex-end;gap:8px;">
          <input id="upgrade" type="checkbox" />
          <label for="upgrade" style="margin:0;">Upgrade?</label>
        </div>
        <div style="display:flex;align-items:flex-end;gap:8px;">
          <input id="replace-duplicates" type="checkbox" />
          <label for="replace-duplicates" style="margin:0;">Replace duplicates</label>
        </div>
        <div>
          <label for="effect-tags">Effect Tags</label>
          <input id="effect-tags" placeholder="Comma-separated tags" />
        </div>
      </div>

      <label style="margin-top:14px;">Paste Effects (rich text supported; pasted formatting kept)</label>
      <div id="raw-editor" class="rich-editor">
        <div class="rich-toolbar">
          <button type="button" data-cmd="bold" title="Bold">Bold</button>
          <button type="button" data-cmd="italic" title="Italic">Italic</button>
          <button type="button" data-cmd="underline" title="Underline">Underline</button>
          <button type="button" data-cmd="table" title="Insert 2x2 table">Table</button>
          <button type="button" data-cmd="removeFormat" title="Clear formatting">Clear</button>
        </div>
        <div class="rich-area" contenteditable="true" data-placeholder="Format each entry as:
Name: Description (can span multiple lines)
MP (can be negative, e.g. -2)
EN (can be negative, e.g. -1)"></div>
      </div>

      <div style="display:flex; gap:10px; margin-top:10px;">
        <button class="btn" id="parse-btn">Parse</button>
        <button class="btn btn-secondary" onclick="location.href='home.html'">‚Üê Back Home</button>
      </div>
    </div>

    <div id="preview-card" class="home-card" style="display:none;">
      <h3>Preview & Edit</h3>
      <p>Review each effect. You can fix names/descriptions/MP/EN (negatives allowed) before saving.</p>
      <div id="errors" style="color:#ff6b6b; margin:8px 0;"></div>
      <div id="table-wrap" style="overflow:auto;">
        <table class="table" style="width:100%; border-collapse:collapse;">
          <thead>
            <tr>
              <th style="text-align:left;">Name</th>
              <th style="text-align:left;">Description</th>
              <th style="width:120px;">MP</th>
              <th style="width:120px;">EN</th>
            </tr>
          </thead>
          <tbody id="preview-body"></tbody>
        </table>
      </div>
      <div style="display:flex; gap:10px; margin-top:10px;">
        <button class="btn" id="confirm-btn">Confirm & Save</button>
        <button class="btn btn-secondary" id="reparse-btn">Re-parse</button>
      </div>
    </div>
  </div>

<script>
const API_BASE = "";
const $ = s => document.querySelector(s);

// Auth guard (admins & moderators)
const token = localStorage.getItem("auth_token") || "";
const role  = (localStorage.getItem("auth_role") || "").toLowerCase();
if (!token || (role !== "admin" && role !== "moderator")) {
  alert("Forbidden: moderators/admins only.");
  window.location.href = "home.html";
}

function setupRichTextEditor(containerId, placeholder=''){
  const container = document.getElementById(containerId);
  if (!container) throw new Error('Missing rich text container '+containerId);
  const area = container.querySelector('.rich-area');
  if (!area) throw new Error('Missing rich text area in '+containerId);
  if (placeholder) area.setAttribute('data-placeholder', placeholder);

  const sanitizePastedHtml = (html, text) => {
    if (html){
      const doc = new DOMParser().parseFromString(html, 'text/html');
      doc.querySelectorAll('*').forEach(el=>{
        el.removeAttribute('color');
        el.style.color = '';
        if (el.getAttribute('style') === '') el.removeAttribute('style');
      });
      return doc.body.innerHTML;
    }
    if (text != null){
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML.replace(/\n/g, '<br>');
    }
    return '';
  };
  area.addEventListener('paste', (e)=>{
    const html = e.clipboardData?.getData('text/html');
    const text = e.clipboardData?.getData('text/plain');
    if (html || text){
      e.preventDefault();
      const cleaned = sanitizePastedHtml(html, text);
      if (cleaned) document.execCommand('insertHTML', false, cleaned);
    }
  });

  const normalizeHtml = (html)=>{
    const text = (area.textContent || '').replace(/\u00a0/g, ' ').trim();
    const raw = (html || '').trim();
    if (!text) return '';
    return raw;
  };

  container.querySelectorAll('[data-cmd]').forEach(btn=>{
    btn.addEventListener('click', (ev)=>{
      ev.preventDefault();
      area.focus();
      const cmd = btn.dataset.cmd;
      if (cmd === 'table'){
        const tbl = '<table class="rte-table"><tbody><tr><td>Cell 1</td><td>Cell 2</td></tr><tr><td>Cell 3</td><td>Cell 4</td></tr></tbody></table>';
        document.execCommand('insertHTML', false, tbl);
      }else{
        document.execCommand(cmd, false, null);
      }
    });
  });

  return {
    el: area,
    getHTML: ()=> normalizeHtml(area.innerHTML),
    setHTML: (html='')=>{ area.innerHTML = html || ''; },
  };
}

function authHeaders(extra = {}) {
  return { "Authorization": `Bearer ${token}`, "Content-Type": "application/json", ...extra };
}

// Inputs
const schoolNameInput  = $("#school-name");
const schoolTypeSelect = $("#school-type");
const rangeTypeSelect  = $("#range-type");
const aoeTypeSelect    = $("#aoe-type");
const upgradeCheckbox  = $("#upgrade");
const effectTagsInput  = $("#effect-tags");

const rawEditor = setupRichTextEditor('raw-editor', `Format each entry as:
Name: Description (can span multiple lines)
MP (can be negative, e.g. -2)
EN (can be negative, e.g. -1)`);

// Table preview model
let PREVIEW = []; // [{name, description, mp_cost, en_cost}]

// ------------ Parsing helpers (accept +/- integers) ------------
function isSignedIntLine(s){ return /^[+-]?\d+$/.test((s||"").trim()); }

// Sanitize inline numeric edits: keep one leading +/-, digits only.
function cleanSignedIntInput(val) {
  val = String(val || "");
  // Remove invalid chars
  val = val.replace(/[^\d+-]/g, "");
  // Keep only first leading sign (if any)
  val = val.replace(/(?!^)[+-]/g, "");
  // Collapse multi-leading zeros like "-0003" -> "-3" (optional)
  const m = val.match(/^([+-]?)(\d*)$/);
  if (!m) return "";
  const sign = m[1] || "";
  let digits = m[2] || "";
  // allow empty digits during typing; treat as "" (we'll coerce to 0 later)
  if (digits.length > 1) digits = digits.replace(/^0+(\d)/, "$1");
  return sign + digits;
}

function escapeHtml(s){
  return String(s || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

function textToHtml(text){
  const parts = String(text || "").split(/\n\s*\n/);
  return parts.map(p=>{
    const lines = p.split(/\n/).map(l=> escapeHtml(l.trim())).filter(Boolean);
    if (!lines.length) return "";
    return `<p>${lines.join("<br>")}</p>`;
  }).filter(Boolean).join("");
}

function htmlToLineTokens(rawHtml){
  const doc = new DOMParser().parseFromString(rawHtml || "", "text/html");
  const out = [];
  const pushLine = (html)=>{
    const parts = String(html || "").split(/<br\s*\/?>/i);
    parts.forEach((part, idx)=>{
      if (idx > 0) out.push({ text:"", html:"" });
      const text = (part || "").replace(/<[^>]+>/g, "").replace(/\u00a0/g, " ").trim();
      if (text || String(part).trim()){
        out.push({ text, html: part.trim() });
      }
    });
  };
  const walk = (node)=>{
    if (node.nodeType === 3){
      const txt = (node.textContent || "").trim();
      if (txt) out.push({ text: txt, html: escapeHtml(txt) });
      return;
    }
    if (node.nodeType !== 1) return;
    const tag = node.tagName.toLowerCase();
    if (tag === "br"){ out.push({ text:"", html:"" }); return; }
    if (tag === "table"){ return; }
    if (tag === "ul" || tag === "ol"){
      node.querySelectorAll("li").forEach(li=> pushLine(li.innerHTML));
      return;
    }
    if (["p","div","li","h1","h2","h3","h4","h5","h6"].includes(tag)){
      pushLine(node.innerHTML);
      return;
    }
    if (node.children && node.children.length){
      Array.from(node.children).forEach(walk);
    }else{
      pushLine(node.innerHTML);
    }
  };
  Array.from(doc.body.childNodes).forEach(walk);
  return out;
}

function sliceHtmlAfterPrefix(html, prefixText){
  const wrap = document.createElement("div");
  wrap.innerHTML = html || "";
  let remaining = String(prefixText || "");
  const walker = document.createTreeWalker(wrap, NodeFilter.SHOW_TEXT, null);
  let node;
  while ((node = walker.nextNode())){
    if (!remaining) break;
    const text = node.textContent || "";
    if (remaining.length >= text.length){
      remaining = remaining.slice(text.length);
      node.textContent = "";
    }else{
      node.textContent = text.slice(remaining.length);
      remaining = "";
      break;
    }
  }
  wrap.querySelectorAll("*").forEach(el=>{
    if (el.textContent === "" && el.children.length === 0) el.remove();
  });
  return wrap.innerHTML.trim();
}

/**
 * Expected block:
 * Name: Description (can continue on several lines)
 * MP  (signed integer, e.g. -2 or 3)
 * EN  (signed integer, e.g. -1 or 0)
 * [blank line or next entry]
 */
function parseRawBlock(text, tokens){
  const lines = text.split(/\r?\n/).map(l => l.trim());
  const out = [];
  let i = 0;

  while (i < lines.length){
    while (i < lines.length && lines[i] === "") i++;
    if (i >= lines.length) break;

    const header = lines[i++];
    if (!header || isSignedIntLine(header))
      throw new Error(`Expected "Name: Description" near line ${i}, got "${header}"`);

    const colonIdx = header.indexOf(":");
    if (colonIdx === -1)
      throw new Error(`Missing ":" in header near line ${i}: "${header}"`);
    const name = header.slice(0, colonIdx).trim();
    let description = header.slice(colonIdx+1).trim();
    let descriptionHtml = "";
    if (tokens && tokens[i - 1] && tokens[i - 1].html){
      descriptionHtml = sliceHtmlAfterPrefix(tokens[i - 1].html, header.slice(0, colonIdx + 1));
    }

    // Collect extra description lines up to the MP line
    const htmlParts = descriptionHtml ? [descriptionHtml] : [];
    while (i < lines.length && lines[i] !== "" && !isSignedIntLine(lines[i])) {
      description += (description ? " " : "") + lines[i];
      if (tokens && tokens[i] && tokens[i].html){
        htmlParts.push(tokens[i].html);
      }
      i++;
    }
    if (htmlParts.length){
      descriptionHtml = htmlParts.join("<br>");
    }

    if (i >= lines.length || !isSignedIntLine(lines[i])) {
      throw new Error(`Missing/invalid MP after "${name}". Found: "${lines[i] || ""}"`);
    }
    const mp = parseInt(lines[i++], 10);

    if (i >= lines.length || !isSignedIntLine(lines[i])) {
      throw new Error(`Missing/invalid EN after "${name}". Found: "${lines[i] || ""}"`);
    }
    const en = parseInt(lines[i++], 10);

    out.push({
      name,
      description,
      description_html: descriptionHtml || textToHtml(description),
      mp_cost: mp,
      en_cost: en
    });

    while (i < lines.length && lines[i] === "") i++;
  }

  if (!out.length) throw new Error("No effects parsed. Check the text format.");
  return out;
}

function parseTableFromHtml(rawHtml){
  if (!rawHtml) return [];
  const doc = new DOMParser().parseFromString(rawHtml, "text/html");
  const tables = Array.from(doc.querySelectorAll("table"));
  if (!tables.length) return [];
  const table = tables
    .map(t => ({ el: t, rows: t.querySelectorAll("tr").length }))
    .sort((a,b) => b.rows - a.rows)[0].el;
  const rows = Array.from(table.querySelectorAll("tr"));
  const out = [];
  rows.forEach((row, idx)=>{
    const cells = Array.from(row.querySelectorAll("th,td"));
    if (cells.length < 3) return;
    const first = (cells[0].textContent || "").replace(/\s+/g, " ").trim();
    const firstHtml = (cells[0].innerHTML || "").trim();
    const mpRaw = (cells[1].textContent || "").replace(/\s+/g, " ").trim();
    const enRaw = (cells[2].textContent || "").replace(/\s+/g, " ").trim();
    const isHeader = idx === 0 && /spell\s*effect/i.test(first);
    if (isHeader) return;
    if (!first) return;
    const colonIdx = first.indexOf(":");
    const name = colonIdx === -1 ? first : first.slice(0, colonIdx).trim();
    const description = colonIdx === -1 ? "" : first.slice(colonIdx + 1).trim();
    let descriptionHtml = "";
    if (colonIdx >= 0 && firstHtml){
      descriptionHtml = sliceHtmlAfterPrefix(firstHtml, first.slice(0, colonIdx + 1));
    }
    const mpMatch = mpRaw.match(/[+-]?\d+/);
    const enMatch = enRaw.match(/[+-]?\d+/);
    const mp = mpMatch ? parseInt(mpMatch[0], 10) : NaN;
    const en = enMatch ? parseInt(enMatch[0], 10) : NaN;
    if (Number.isNaN(mp) || Number.isNaN(en)) return;
    out.push({
      name,
      description,
      description_html: descriptionHtml || textToHtml(description),
      mp_cost: mp,
      en_cost: en
    });
  });
  return out;
}

// ------------ UI rendering ------------
function renderPreview(){
  const tbody = $("#preview-body");
  tbody.innerHTML = PREVIEW.map((e, idx) => `
    <tr>
      <td><input data-idx="${idx}" data-key="name" value="${(e.name || "").replace(/"/g,'&quot;')}" /></td>
      <td><textarea data-idx="${idx}" data-key="description" rows="2">${e.description || ""}</textarea></td>
      <td><input data-idx="${idx}" data-key="mp_cost" value="${e.mp_cost}" /></td>
      <td><input data-idx="${idx}" data-key="en_cost" value="${e.en_cost}" /></td>
    </tr>
  `).join("");

  // Wire edits back into PREVIEW; allow signed ints
  tbody.querySelectorAll("input,textarea").forEach(el=>{
    el.addEventListener("input", (ev)=>{
      const idx = parseInt(ev.target.dataset.idx,10);
      const key = ev.target.dataset.key;
      let val = ev.target.value;

      if (key === "mp_cost" || key === "en_cost") {
        val = cleanSignedIntInput(val);
        ev.target.value = val;
        // Treat empty/sign-only as 0 for the model
        PREVIEW[idx][key] = (!val || val === "+" || val === "-") ? 0 : parseInt(val, 10);
      } else {
        PREVIEW[idx][key] = val;
        if (key === "description") PREVIEW[idx].description_html = textToHtml(val);
      }
    });
  });
}

function validatePreview(){
  const errs = [];
  PREVIEW.forEach((e,i)=>{
    if (!e.name) errs.push(`Row ${i+1}: name is empty`);
    if (typeof e.mp_cost !== "number" || Number.isNaN(e.mp_cost))
      errs.push(`Row ${i+1}: MP is not a valid number`);
    if (typeof e.en_cost !== "number" || Number.isNaN(e.en_cost))
      errs.push(`Row ${i+1}: EN is not a valid number`);
  });
  return errs;
}

// ------------ Events ------------
$("#parse-btn").addEventListener("click", ()=>{
  const schoolName = schoolNameInput.value.trim();
  if (!schoolName) return alert("Please fill School Name first.");

  try{
    const rawHtml = rawEditor.getHTML();
    const tableParsed = parseTableFromHtml(rawHtml);
    if (tableParsed.length){
      PREVIEW = tableParsed;
    }else{
      const text = rawHtml
        .replace(/<\/p>/gi, "\n")
        .replace(/<br\s*\/?>/gi, "\n")
        .replace(/<[^>]+>/g, "")
        .replace(/\u00a0/g, " ");
      const tokens = htmlToLineTokens(rawHtml);
      PREVIEW = parseRawBlock(text, tokens);
    }
    $("#errors").textContent = "";
    renderPreview();
    $("#preview-card").style.display = "block";
    window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" });
  }catch(e){
    $("#preview-card").style.display = "none";
    $("#errors").textContent = e.message;
  }
});

$("#reparse-btn").addEventListener("click", ()=>$("#parse-btn").click());

$("#confirm-btn").addEventListener("click", async ()=>{
  const errs = validatePreview();
  if (errs.length){ $("#errors").innerHTML = errs.join("<br>"); return; }

  const school_name = schoolNameInput.value.trim();
  if (!school_name){ alert("School Name is required."); return; }

  const replaceDupes = document.querySelector("#replace-duplicates").checked;

  const tags = (effectTagsInput.value || "").split(",").map(t=>t.trim()).filter(Boolean);
  const payload = {
    school_name: school_name,
    school_type: schoolTypeSelect.value,
    range_type:  rangeTypeSelect.value,
    aoe_type:    aoeTypeSelect.value,
    upgrade:     upgradeCheckbox.checked,
    replace_duplicates: replaceDupes,
    effects: PREVIEW.map(e => ({
      name: e.name,
      description: e.description_html || e.description || "",
      mp_cost: Number(e.mp_cost),
      en_cost: Number(e.en_cost),
      tags: tags
    }))
  };

  try{
    const res = await fetch(`${API_BASE}/effects/bulk_create`, {
      method: "POST",
      headers: authHeaders(),
      body: JSON.stringify(payload)
    });
    const data = await res.json();
    if (data.status === "success"){
      alert(`Created ${data.created.length} effect(s) in ${data.school.name} [${data.school.id}].`);
      location.href = "home.html";
    }else{
      $("#errors").textContent = data.message || "Bulk create failed";
    }
  }catch(e){
    console.error(e);
    $("#errors").textContent = "Request failed: " + e.message;
  }
  
});
</script>
</body>
</html>
