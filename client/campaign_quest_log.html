<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Campaign Quest Hub</title>
  <link rel="stylesheet" href="/static/style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" referrerpolicy="no-referrer" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b0c10;
      --panel: #12161d;
      --border: #232a35;
      --muted: #b7b2a8;
      --accent: #c9a227;
      --accent-2: #4a8b8f;
      --text: #f6f2ea;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Source Sans 3", "Inter", sans-serif;
      background: radial-gradient(900px 500px at 0% -10%, rgba(201,162,39,0.18), transparent 55%),
        radial-gradient(700px 420px at 100% 0%, rgba(74,139,143,0.2), transparent 50%),
        linear-gradient(180deg, var(--bg) 0%, #07080c 70%);
      color: var(--text);
      min-height: 100vh;
    }
    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 30px 16px 70px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .hero {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }
    .hero h1 {
      margin: 0;
      font-family: "Cinzel", "Times New Roman", serif;
      font-size: 2rem;
    }
    .hero-actions {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .hero-search {
      display: flex;
      flex-direction: column;
      font-size: 0.85rem;
      color: var(--muted);
    }
    .hero-search input {
      margin-top: 4px;
      width: 220px;
    }
    .filters-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
    }
    .filters-row select {
      width: 100%;
    }
    .layout {
      display: grid;
      grid-template-columns: minmax(280px, 1fr) minmax(0, 1.2fr);
      gap: 16px;
    }
    .panel {
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 18px;
      background: var(--panel);
      box-shadow: 0 20px 50px rgba(0,0,0,0.45);
    }
    .list-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 70vh;
    }
    .detail-panel {
      min-height: 70vh;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
    }
    .quest-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .quest-card {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px;
      background: #0d1016;
      cursor: pointer;
      transition: border 0.2s ease, transform 0.2s ease;
    }
    .quest-card.active {
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    .quest-card .titles {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .quest-card h3 {
      margin: 0;
      font-size: 1rem;
    }
    .status-pill {
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid transparent;
      text-transform: capitalize;
    }
    .status-pill.pending { border-color: #c9a227; color: #c9a227; }
    .status-pill.active { border-color: #4ac68f; color: #4ac68f; }
    .status-pill.on_hold { border-color: #7795f6; color: #7795f6; }
    .status-pill.completed { border-color: #6cc991; color: #6cc991; }
    .status-pill.failed { border-color: #e06666; color: #e06666; }
    .status-pill.abandoned { border-color: #ad6fdc; color: #ad6fdc; }
    .status-pill.hidden { border-color: #6c6c6c; color: #6c6c6c; }
    .badges {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }
    .badge {
      border-radius: 999px;
      padding: 2px 10px;
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 0.75rem;
    }
    .detail-empty {
      color: var(--muted);
      border: 1px dashed rgba(255,255,255,0.2);
      border-radius: 14px;
      padding: 24px;
      text-align: center;
    }
    .detail-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .detail-header h2 {
      margin: 0;
      font-size: 1.7rem;
    }
    .detail-subtitle {
      font-size: 0.95rem;
      color: var(--muted);
    }
    .detail-section {
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .objectives-grid {
      display: grid;
      gap: 12px;
    }
    .objective-card {
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 10px;
      background: #0c0f15;
      display: grid;
      gap: 6px;
    }
    .objective-card strong {
      font-size: 0.95rem;
    }
    .objective-card .objective-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .objective-status-icons {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .objective-status-btn {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: #101622;
      color: #cfd4e3;
      display: inline-grid;
      place-items: center;
      cursor: pointer;
    }
    .objective-status-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(201, 162, 39, 0.16);
    }
    .objective-status-btn[disabled] {
      opacity: 0.65;
      cursor: default;
    }
    .notes-grid {
      display: grid;
      gap: 12px;
    }
    .note-card {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px;
      background: #0c0f15;
    }
    .muted {
      color: var(--muted);
    }
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    body.modal-open {
      overflow: hidden;
    }
    textarea {
      width: 100%;
      min-height: 80px;
    }
    .btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 8px 16px;
      background: #12161d;
      color: var(--text);
      cursor: pointer;
    }
    .btn.primary {
      background: linear-gradient(135deg, rgba(197,53,53,0.35), rgba(20,20,29,0.95));
      border-color: var(--accent);
    }
    .btn.secondary {
      background: transparent;
      border-color: rgba(255,255,255,0.3);
    }
    .btn.ghost {
      background: rgba(255,255,255,0.05);
    }
    .create-panel .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }
    .create-panel label {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .section-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    .hidden {
      display: none !important;
    }
    .gm-only {
      display: none;
    }
    .gm-only.visible {
      display: inline-flex;
    }
    .overlay-layer {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      z-index: 20;
    }
    .overlay-layer.visible {
      display: flex;
    }
    .overlay-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(4px);
    }
    .panel.create-panel {
      position: relative;
      width: min(680px, 100%);
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.6);
    }
    .rtf-wrap {
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 10px;
      overflow: hidden;
      background: #0f141f;
    }
    .rtf-toolbar {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      padding: 6px;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      background: #0d121d;
    }
    .rtf-toolbar button {
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 8px;
      min-width: 28px;
      height: 28px;
      background: #151b29;
      color: var(--text);
      cursor: pointer;
    }
    .rtf-editor {
      min-height: 120px;
      padding: 10px;
      outline: none;
    }
    .rtf-editor.small {
      min-height: 90px;
    }
    .rich-view p {
      margin: 0 0 8px;
    }
    .rich-view ul,
    .rich-view ol {
      margin: 0 0 8px 18px;
      padding: 0;
    }
    .badge.tracked { border-color: #4a8b8f; color: #9adce0; }
    .badge.pinned { border-color: #c9a227; color: #edd77a; }
    .feedback {
      color: #8ed8be;
      font-size: 0.88rem;
    }
    .feedback.error {
      color: #f19e9e;
    }
    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }
      .hero-search input {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="hero">
      <div>
        <h1 id="page-title">Campaign Quest Hub</h1>
        <p id="page-subtitle" class="muted">Manage every quest, objective, and theory for this campaign.</p>
      </div>
      <div class="hero-actions">
        <label class="hero-search muted">
          <span>Search</span>
          <input id="search-input" type="search" placeholder="Title, tags, assigned, faction..." autocomplete="off" />
        </label>
        <button class="btn ghost" id="toggle-hidden">Show Hidden</button>
        <a class="btn" id="back-to-campaign-btn" href="campaigns_my.html">Back to Campaign</a>
        <a class="btn" href="portal.html">Portal</a>
        <button class="btn primary gm-only" id="open-create-btn">New Quest</button>
      </div>
    </header>
    <section class="filters-row">
      <select id="filter-type">
        <option value="">Quest Kind</option>
      </select>
      <select id="filter-status">
        <option value="">Status</option>
      </select>
      <select id="filter-assigned">
        <option value="">Assigned</option>
      </select>
      <select id="filter-faction">
        <option value="">Faction</option>
      </select>
      <select id="filter-session">
        <option value="">Session</option>
      </select>
    </section>
    <div class="layout">
      <aside class="panel list-panel">
        <div class="list-header">
          <strong>Quest List</strong>
          <span class="muted" id="quest-count">0 quests</span>
        </div>
        <div id="quest-list" class="quest-list"></div>
      </aside>
      <main class="panel detail-panel">
        <div id="quest-detail" class="detail-empty">
          Select a quest from the list to inspect its objectives, notes, and theories.
        </div>
      </main>
    </div>
    <div id="create-layer" class="overlay-layer">
      <div class="overlay-backdrop" id="create-backdrop"></div>
      <section id="create-panel" class="panel create-panel create-modal-content">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <strong>Create Quest</strong>
          <button class="btn secondary" id="close-create">Close</button>
        </div>
      <form id="create-form">
        <div class="form-grid">
          <label>
            Title
            <input name="title" required />
          </label>
          <label>
            Subtitle
            <input name="subtitle" />
          </label>
          <label>
            Quest Kind
            <select name="questKind">
              <option value="main">Main Quest</option>
              <option value="side">Side Quest</option>
              <option value="personal">Personal Quest</option>
              <option value="faction">Faction Quest</option>
              <option value="secret">Secret Quest</option>
              <option value="time_limited">Time-Limited Quest</option>
              <option value="dynamic">Dynamic/Event Quest</option>
            </select>
          </label>
          <label>
            Scope
            <select name="scope">
              <option value="group">Group</option>
              <option value="personal">Personal</option>
            </select>
          </label>
          <label>
            Status
            <select name="status">
              <option value="pending">Pending</option>
              <option value="active">Active</option>
              <option value="on_hold">On Hold</option>
              <option value="completed">Completed</option>
              <option value="failed">Failed</option>
              <option value="abandoned">Abandoned</option>
              <option value="hidden">Hidden</option>
            </select>
          </label>
          <label>
            Visibility
            <select name="visibility">
              <option value="gm_only">GM Only</option>
              <option value="party_visible">Party Visible</option>
              <option value="character_specific">Character Specific</option>
              <option value="role_restricted">Role Restricted</option>
            </select>
          </label>
          <label>
            Assigned Characters (comma-separated)
            <input name="assignedTo" placeholder="player1, player2" />
          </label>
          <label>
            Tags (comma separated)
            <input name="tags" placeholder="exploration, mystery" />
          </label>
          <label>
            Faction
            <input name="faction" />
          </label>
          <label>
            Session
            <input name="session" />
          </label>
        </div>
        <label>
          Description
          <textarea name="description"></textarea>
        </label>
        <label>
          Objectives (one per line)
          <textarea name="objectives" placeholder="Objective one\nObjective two"></textarea>
        </label>
        <div class="row">
          <label style="flex-direction:row;align-items:center;gap:6px;">
            <input type="checkbox" name="tracked" />
            Track for me
          </label>
          <label style="flex-direction:row;align-items:center;gap:6px;">
            <input type="checkbox" name="pinned" />
            Pin to HUD
          </label>
        </div>
        <div class="row" style="justify-content:flex-end;">
          <button class="btn primary" type="submit">Create Quest</button>
          <span id="create-feedback" class="muted"></span>
        </div>
      </form>
      </section>
    </div>
  </div>
  <script>
    const params = new URLSearchParams(location.search);
    const CID = (params.get('cid') || '').trim();
    const backToCampaignBtn = document.getElementById('back-to-campaign-btn');

    const searchInput = document.getElementById('search-input');
    const filterTypeEl = document.getElementById('filter-type');
    const filterStatusEl = document.getElementById('filter-status');
    const filterAssignedEl = document.getElementById('filter-assigned');
    const filterFactionEl = document.getElementById('filter-faction');
    const filterSessionEl = document.getElementById('filter-session');
    const toggleHiddenBtn = document.getElementById('toggle-hidden');
    const questListEl = document.getElementById('quest-list');
    const questDetailEl = document.getElementById('quest-detail');
    const questCountEl = document.getElementById('quest-count');
    const openCreateBtn = document.getElementById('open-create-btn');
    const createPanel = document.getElementById('create-panel');
    const createLayer = document.getElementById('create-layer');
    const createBackdrop = document.getElementById('create-backdrop');
    const closeCreateBtn = document.getElementById('close-create');
    const createForm = document.getElementById('create-form');
    const createFeedback = document.getElementById('create-feedback');
    const pageStatus = document.getElementById('page-subtitle');

    const OBJECTIVE_STATUS_META = {
      not_started: { label: 'Not Started', icon: 'fa-regular fa-circle' },
      ongoing: { label: 'Ongoing', icon: 'fa-solid fa-spinner' },
      succeeded: { label: 'Succeeded', icon: 'fa-solid fa-check-circle' },
      failed: { label: 'Failed', icon: 'fa-solid fa-circle-xmark' },
    };

    const QUEST_STATUS_LABELS = {
      pending: 'Pending',
      active: 'Active',
      on_hold: 'On Hold',
      completed: 'Completed',
      failed: 'Failed',
      abandoned: 'Abandoned',
      hidden: 'Hidden',
    };

    const QUEST_KIND_LABELS = {
      main: 'Main Quest',
      side: 'Side Quest',
      personal: 'Personal Quest',
      faction: 'Faction Quest',
      secret: 'Secret Quest',
      time_limited: 'Time-Limited Quest',
      dynamic: 'Dynamic/Event Quest',
    };

    const state = {
      user: null,
      campaign: null,
      quests: [],
      filters: {
        search: '',
        type: '',
        status: '',
        assigned: '',
        faction: '',
        session: '',
        showHidden: false,
      },
      activeQuest: null,
      isGm: false,
      editingQuestId: null,
      createDescriptionEditor: null,
      createDescriptionTextarea: null,
      createModalTitle: null,
      createModalSubmit: null,
      createQuestIdInput: null,
    };

    function refreshBackToCampaignLink() {
      if (!backToCampaignBtn) return;
      const targetCid = String(state.campaign?.id || CID || '').trim();
      if (targetCid) {
        backToCampaignBtn.href = `campaign_view.html?cid=${encodeURIComponent(targetCid)}`;
        backToCampaignBtn.textContent = 'Back to Campaign';
      } else {
        backToCampaignBtn.href = 'campaigns_my.html';
        backToCampaignBtn.textContent = 'Back to My Campaigns';
      }
    }

    function escapeHtml(val) {
      if (!val) return '';
      return String(val)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function stripHtml(val) {
      const div = document.createElement('div');
      div.innerHTML = String(val || '');
      return (div.textContent || div.innerText || '').trim();
    }

    function sanitizeRichHtml(input) {
      const allowedTags = new Set(['B', 'STRONG', 'I', 'EM', 'U', 'P', 'BR', 'UL', 'OL', 'LI', 'A', 'CODE', 'BLOCKQUOTE']);
      const allowedAttrs = { A: new Set(['href', 'target', 'rel']) };
      const tpl = document.createElement('template');
      tpl.innerHTML = String(input || '');
      function clean(node) {
        const children = Array.from(node.childNodes);
        children.forEach((child) => {
          if (child.nodeType === Node.ELEMENT_NODE) {
            const tag = child.tagName.toUpperCase();
            if (!allowedTags.has(tag)) {
              const text = document.createTextNode(child.textContent || '');
              child.replaceWith(text);
              return;
            }
            Array.from(child.attributes).forEach((attr) => {
              const name = attr.name.toLowerCase();
              const ok = allowedAttrs[tag] && allowedAttrs[tag].has(name);
              if (!ok) child.removeAttribute(attr.name);
            });
            if (tag === 'A') {
              const href = (child.getAttribute('href') || '').trim();
              if (!/^https?:\/\//i.test(href) && !href.startsWith('/')) {
                child.removeAttribute('href');
              } else {
                child.setAttribute('target', '_blank');
                child.setAttribute('rel', 'noopener noreferrer');
              }
            }
            clean(child);
          } else if (child.nodeType === Node.COMMENT_NODE) {
            child.remove();
          }
        });
      }
      clean(tpl.content);
      return tpl.innerHTML;
    }

    function richView(html) {
      const safe = sanitizeRichHtml(html || '');
      return `<div class="rich-view">${safe || '<span class="muted">None</span>'}</div>`;
    }

    function createEditorMarkup(editorId, small = false) {
      return `
        <div class="rtf-wrap">
          <div class="rtf-toolbar" data-editor="${editorId}">
            <button type="button" data-cmd="bold" title="Bold"><i class="fa-solid fa-bold"></i></button>
            <button type="button" data-cmd="italic" title="Italic"><i class="fa-solid fa-italic"></i></button>
            <button type="button" data-cmd="underline" title="Underline"><i class="fa-solid fa-underline"></i></button>
            <button type="button" data-cmd="insertUnorderedList" title="Bulleted List"><i class="fa-solid fa-list-ul"></i></button>
            <button type="button" data-cmd="insertOrderedList" title="Numbered List"><i class="fa-solid fa-list-ol"></i></button>
            <button type="button" data-link="1" title="Insert Link"><i class="fa-solid fa-link"></i></button>
            <button type="button" data-cmd="removeFormat" title="Clear"><i class="fa-solid fa-eraser"></i></button>
          </div>
          <div id="${editorId}" class="rtf-editor ${small ? 'small' : ''}" contenteditable="true"></div>
        </div>
      `;
    }

    function getEditorHtml(editor) {
      return sanitizeRichHtml(editor?.innerHTML || '');
    }

    function setEditorHtml(editor, html) {
      if (!editor) return;
      editor.innerHTML = sanitizeRichHtml(html || '');
    }

    function wireRichToolbars(root = document) {
      root.querySelectorAll('.rtf-toolbar button').forEach((btn) => {
        if (btn.dataset.wired === '1') return;
        btn.dataset.wired = '1';
        btn.addEventListener('click', () => {
          const toolbar = btn.closest('.rtf-toolbar');
          const editorId = toolbar?.dataset?.editor;
          const editor = editorId ? document.getElementById(editorId) : null;
          if (!editor) return;
          editor.focus();
          if (btn.dataset.link) {
            const url = window.prompt('Enter URL (https://...)');
            if (url && url.trim()) document.execCommand('createLink', false, url.trim());
            return;
          }
          const cmd = btn.dataset.cmd;
          if (cmd) document.execCommand(cmd, false, null);
        });
      });
    }

    function setupCreateQuestEditor() {
      const priorityLabel = createForm.querySelector('select[name="priority"]')?.closest('label');
      if (priorityLabel) priorityLabel.remove();

      state.createModalTitle = document.querySelector('#create-panel strong');
      state.createModalSubmit = createForm.querySelector('button[type="submit"]');

      const hiddenInput = document.createElement('input');
      hiddenInput.type = 'hidden';
      hiddenInput.name = 'questId';
      createForm.prepend(hiddenInput);
      state.createQuestIdInput = hiddenInput;

      const descriptionTextarea = createForm.querySelector('textarea[name="description"]');
      if (!descriptionTextarea) return;
      state.createDescriptionTextarea = descriptionTextarea;
      const wrapLabel = descriptionTextarea.closest('label');
      wrapLabel.firstChild.textContent = 'Description (Rich Text)';
      descriptionTextarea.classList.add('hidden');
      const editorHost = document.createElement('div');
      editorHost.innerHTML = createEditorMarkup('create-description-editor', false);
      wrapLabel.appendChild(editorHost.firstElementChild);
      state.createDescriptionEditor = document.getElementById('create-description-editor');
      setEditorHtml(state.createDescriptionEditor, '');
      wireRichToolbars(wrapLabel);
    }

    function getCampaignUsers() {
      const values = new Set();
      const owner = (state.campaign?.owner || '').trim();
      if (owner) values.add(owner);
      (state.campaign?.members || []).forEach((name) => { if (name) values.add(name); });
      (state.campaign?.assistant_gms || []).forEach((name) => { if (name) values.add(name); });
      const me = (state.user?.username || '').trim();
      if (me) values.add(me);
      return Array.from(values).sort((a, b) => a.localeCompare(b));
    }

    function refreshGmVisibility() {
      const campaignRole = ((state.campaign || {}).user_role || '').toLowerCase();
      const isOwner = Boolean(state.campaign?.is_owner);
      const isAssistant = Boolean(state.campaign?.is_assistant_gm);
      const userRole = (state.user?.role || '').toLowerCase();
      state.isGm =
        isOwner ||
        isAssistant ||
        ['gm', 'assistant', 'owner', 'assistant_gm', 'assistant gm'].includes(campaignRole) ||
        userRole === 'admin';
      if (openCreateBtn) {
        openCreateBtn.classList.toggle('visible', state.isGm);
        openCreateBtn.style.display = state.isGm ? 'inline-flex' : 'none';
      }
    }

    function setCreateModalVisible(visible) {
      if (!createLayer) return;
      createLayer.classList.toggle('visible', visible);
      document.body.classList.toggle('modal-open', visible);
    }

    function setCreateFormValue(name, value) {
      const field = createForm.elements.namedItem(name);
      if (!field) return;
      field.value = value || '';
    }

    function setCreateFormChecked(name, checked) {
      const field = createForm.elements.namedItem(name);
      if (!field || field.type !== 'checkbox') return;
      field.checked = Boolean(checked);
    }

    function openCreateModalForCreate() {
      state.editingQuestId = null;
      if (state.createQuestIdInput) state.createQuestIdInput.value = '';
      if (state.createModalTitle) state.createModalTitle.textContent = 'Create Quest';
      if (state.createModalSubmit) state.createModalSubmit.textContent = 'Create Quest';
      createForm.reset();
      setCreateFormValue('scope', 'group');
      setCreateFormValue('status', 'pending');
      setCreateFormValue('visibility', 'party_visible');
      if (state.createDescriptionEditor) setEditorHtml(state.createDescriptionEditor, '');
      createFeedback.textContent = '';
      setCreateModalVisible(true);
    }

    function openCreateModalForEdit(quest) {
      if (!quest || !quest.id) return;
      state.editingQuestId = quest.id;
      if (state.createQuestIdInput) state.createQuestIdInput.value = quest.id;
      if (state.createModalTitle) state.createModalTitle.textContent = 'Modify Quest';
      if (state.createModalSubmit) state.createModalSubmit.textContent = 'Save Changes';

      setCreateFormValue('title', quest.title || '');
      setCreateFormValue('subtitle', quest.subtitle || '');
      setCreateFormValue('questKind', quest.quest_kind || 'main');
      setCreateFormValue('scope', quest.type || 'group');
      setCreateFormValue('status', quest.status || 'pending');
      setCreateFormValue('visibility', quest.visibility || 'party_visible');
      setCreateFormValue('assignedTo', (quest.assignedTo || []).join(', '));
      setCreateFormValue('tags', (quest.tags || []).join(', '));
      setCreateFormValue('faction', quest.faction || '');
      setCreateFormValue('session', quest.session || '');
      setCreateFormValue(
        'objectives',
        (quest.objectives || [])
          .slice()
          .sort((a, b) => (a.order || 0) - (b.order || 0))
          .map((entry) => (entry.title || '').trim())
          .filter(Boolean)
          .join('\n'),
      );
      setCreateFormChecked('tracked', isTracked(quest));
      setCreateFormChecked('pinned', isPinned(quest));
      if (state.createDescriptionEditor) {
        setEditorHtml(state.createDescriptionEditor, quest.description || '');
      } else {
        setCreateFormValue('description', quest.description || '');
      }
      createFeedback.textContent = '';
      setCreateModalVisible(true);
    }

    function closeCreateModal() {
      setCreateModalVisible(false);
      createFeedback.textContent = '';
    }

    function buildObjectivesPayload(linesRaw, existing = []) {
      const titles = String(linesRaw || '')
        .split('\n')
        .map((line) => line.trim())
        .filter(Boolean);
      const pools = new Map();
      (existing || []).forEach((entry) => {
        const key = (entry?.title || '').trim().toLowerCase();
        if (!key) return;
        const queue = pools.get(key) || [];
        queue.push(entry);
        pools.set(key, queue);
      });
      return titles.map((title, idx) => {
        const key = title.toLowerCase();
        const queue = pools.get(key) || [];
        const current = queue.length ? queue.shift() : null;
        if (current) {
          return {
            id: current.id,
            title,
            description: current.description || '',
            status: current.status || 'not_started',
            type: current.type || (current.hidden ? 'hidden' : 'mandatory'),
            hidden: Boolean(current.hidden || current.type === 'hidden'),
            priority: current.priority || 'secondary',
            order: idx + 1,
          };
        }
        return { title, order: idx + 1 };
      });
    }

    function canUpdateObjectives(quest) {
      if (state.isGm) return true;
      const visibility = (quest.visibility || '').toLowerCase();
      if (visibility === 'gm_only') return false;
      const userLower = (state.user?.username || '').toLowerCase();
      const assigned = (quest.assignedTo || []).map((name) => (name || '').toLowerCase());
      const creator = (quest.createdBy || '').toLowerCase();
      return assigned.includes(userLower) || creator === userLower;
    }

    function getFilteredQuests() {
      const list = [];
      (state.quests || []).forEach((quest) => {
        if (!state.filters.showHidden && (quest.status || '').toLowerCase() === 'hidden') {
          return;
        }
        if (state.filters.type && quest.quest_kind !== state.filters.type) {
          return;
        }
        if (state.filters.status && quest.status !== state.filters.status) {
          return;
        }
        if (state.filters.assigned) {
          const assigned = (quest.assignedTo || []).map((value) => (value || '').toLowerCase());
          if (!assigned.includes(state.filters.assigned.toLowerCase())) return;
        }
        if (state.filters.faction) {
          if ((quest.faction || '').toLowerCase() !== state.filters.faction.toLowerCase()) return;
        }
        if (state.filters.session) {
          if ((quest.session || '').toLowerCase() !== state.filters.session.toLowerCase()) return;
        }
        const search = (state.filters.search || '').toLowerCase();
        if (search) {
          const haystack = [
            quest.title,
            quest.subtitle,
            stripHtml(quest.description),
            ...(quest.tags || []),
            ...(quest.assignedTo || []),
            quest.faction,
            quest.session,
          ]
            .filter(Boolean)
            .map((value) => String(value).toLowerCase())
            .join(' ');
          if (!haystack.includes(search)) return;
        }
        list.push(quest);
      });
      list.sort((a, b) => {
        const pinnedDelta = (isPinned(b) ? 1 : 0) - (isPinned(a) ? 1 : 0);
        if (pinnedDelta !== 0) return pinnedDelta;
        const trackedDelta = (isTracked(b) ? 1 : 0) - (isTracked(a) ? 1 : 0);
        if (trackedDelta !== 0) return trackedDelta;
        return String(b.updatedAt || b.createdAt || '').localeCompare(String(a.updatedAt || a.createdAt || ''));
      });
      return list;
    }

    function renderFilters() {
      const types = new Set();
      const statuses = new Set();
      const assigned = new Set();
      const factions = new Set();
      const sessions = new Set();
      state.quests.forEach((quest) => {
        if (quest.quest_kind) types.add(quest.quest_kind);
        if (quest.status) statuses.add(quest.status);
        (quest.assignedTo || []).forEach((name) => {
          if (name) assigned.add(name);
        });
        if (quest.faction) factions.add(quest.faction);
        if (quest.session) sessions.add(quest.session);
      });
      function pushOptions(el, values, placeholder) {
        const current = el.value;
        el.innerHTML = `<option value="">${placeholder}</option>`;
        Array.from(values)
          .sort((a, b) => String(a).localeCompare(String(b)))
          .forEach((value) => {
            const option = document.createElement('option');
            option.value = value;
            option.textContent = el === filterStatusEl ? QUEST_STATUS_LABELS[value] || value : value;
            el.appendChild(option);
          });
        if (current) el.value = current;
      }
      pushOptions(filterTypeEl, types, 'Quest Kind');
      pushOptions(filterStatusEl, statuses, 'Status');
      pushOptions(filterAssignedEl, assigned, 'Assigned');
      pushOptions(filterFactionEl, factions, 'Faction');
      pushOptions(filterSessionEl, sessions, 'Session');
    }

    function renderQuestList() {
      questListEl.innerHTML = '';
      const filtered = getFilteredQuests();
      questCountEl.textContent = `${filtered.length} quest${filtered.length === 1 ? '' : 's'}`;
      filtered.forEach((quest) => {
        const card = document.createElement('div');
        card.className = 'quest-card';
        if (state.activeQuest && state.activeQuest.id === quest.id) {
          card.classList.add('active');
        }
        const badges = [`<span class="badge">${QUEST_KIND_LABELS[quest.quest_kind] || 'Main Quest'}</span>`];
        if (isTracked(quest)) badges.push('<span class="badge tracked"><i class="fa-solid fa-eye"></i> Tracked</span>');
        if (isPinned(quest)) badges.push('<span class="badge pinned"><i class="fa-solid fa-thumbtack"></i> Pinned</span>');
        card.innerHTML = `
          <div class="titles">
            <h3>${escapeHtml(quest.title || 'Untitled Quest')}</h3>
            <span class="status-pill ${quest.status || 'pending'}">${QUEST_STATUS_LABELS[quest.status] || quest.status || 'Pending'}</span>
          </div>
          <div class="badges">${badges.join('')}</div>
          <div class="muted">${escapeHtml((quest.assignedTo || []).join(', ') || 'Unassigned')}</div>
        `;
        card.addEventListener('click', () => {
          state.activeQuest = quest;
          renderQuestDetail();
          document.querySelectorAll('.quest-card').forEach((el) => el.classList.remove('active'));
          card.classList.add('active');
        });
        questListEl.appendChild(card);
      });
      if (!filtered.length) {
        questListEl.innerHTML = '<div class="muted">No quests match the current filters.</div>';
      }
    }

    function renderQuestDetail() {
      const quest = state.activeQuest;
      if (!quest) {
        questDetailEl.innerHTML = '<div class="detail-empty">Select a quest to inspect its objectives, notes, and theories.</div>';
        return;
      }
      const assignedUsers = quest.assignedTo || [];
      const campaignUsers = getCampaignUsers();
      const assignOptions = campaignUsers.map((name) => `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`).join('');
      const gmControls = state.isGm ? `
        <div class="detail-section">
          <div class="section-actions">
            <button class="btn secondary" id="edit-quest-btn">Modify Quest</button>
            <button class="btn secondary" id="delete-quest-btn">Delete Quest</button>
            <label class="muted">Status
              <select id="status-update">${Object.entries(QUEST_STATUS_LABELS).map(([value, label]) => `<option value="${value}" ${value === quest.status ? 'selected' : ''}>${label}</option>`).join('')}</select>
            </label>
            <label class="muted">Scope
              <select id="scope-update">
                <option value="group" ${(quest.type || 'group') === 'group' ? 'selected' : ''}>Group</option>
                <option value="personal" ${(quest.type || '') === 'personal' ? 'selected' : ''}>Personal</option>
              </select>
            </label>
            <label class="muted">Quest Kind
              <select id="kind-update">${Object.entries(QUEST_KIND_LABELS).map(([value, label]) => `<option value="${value}" ${value === quest.quest_kind ? 'selected' : ''}>${label}</option>`).join('')}</select>
            </label>
          </div>
          <div class="section-actions">
            <label class="muted">Assign User
              <select id="assign-user-select">
                <option value="">Choose...</option>
                ${assignOptions}
              </select>
            </label>
            <button class="btn ghost" id="assign-user-btn">Assign</button>
            <button class="btn ghost" id="unassign-user-btn">Unassign</button>
            <span class="muted" id="assign-feedback"></span>
          </div>
        </div>
      ` : '';
      const objectives = (quest.objectives || [])
        .filter((entry) => {
          if (state.isGm) return true;
          return !(entry.hidden || entry.type === 'hidden');
        })
        .sort((a, b) => (a.order || 0) - (b.order || 0));
      const objectivesHtml = objectives.length
        ? objectives.map((obj) => {
            const hidden = !!obj.hidden || obj.type === 'hidden';
            const statusIcons = `<div class="objective-status-icons">${Object.entries(OBJECTIVE_STATUS_META).map(([status, meta]) => {
              const active = (obj.status || 'not_started') === status ? 'active' : '';
              const disabled = canUpdateObjectives(quest) ? '' : 'disabled';
              return `<button class="objective-status-btn ${active}" ${disabled} title="${meta.label}" data-status="${status}" data-objective-id="${escapeHtml(obj.id || '')}"><i class="${meta.icon}"></i></button>`;
            }).join('')}</div>`;
            return `
              <div class="objective-card">
                <div class="row" style="justify-content:space-between;">
                  <div class="row" style="gap:8px;">
                    <strong>${escapeHtml(obj.title || 'Untitled Objective')}</strong>
                    ${hidden ? '<span class="badge">Hidden</span>' : ''}
                  </div>
                  ${statusIcons}
                </div>
                <div class="objective-meta muted">
                  <span>Type: ${escapeHtml((obj.type || 'mandatory').replace('_', ' '))}</span>
                  <span>Status: ${escapeHtml(OBJECTIVE_STATUS_META[obj.status || 'not_started']?.label || obj.status || 'Not Started')}</span>
                </div>
                ${richView(obj.description || '')}
                ${state.isGm ? `<div class="section-actions"><button class="btn ghost objective-hide-btn" data-objective-id="${escapeHtml(obj.id || '')}" data-hidden="${hidden ? '1' : '0'}">${hidden ? 'Unhide Objective' : 'Hide Objective'}</button></div>` : ''}
              </div>
            `;
          }).join('')
        : '<div class="muted">No objectives yet.</div>';
      const objectiveManageHtml = state.isGm ? `
        <div class="section-actions">
          <input id="objective-add-input" placeholder="Add objective title..." />
          <button class="btn secondary" id="objective-add-btn">Add Objective</button>
        </div>
      ` : '';
      const notesHtml = `
        <div class="detail-section">
          <div class="row" style="justify-content:space-between;">
            <strong>Personal Notes</strong>
            <button class="btn secondary" id="note-add-btn">Add Note</button>
          </div>
          <div id="notes-list" class="notes-grid">
            ${(quest.personalNotes || []).map((note) => `
              <div class="note-card">
                <div class="row" style="justify-content:space-between;">
                  <span><strong>${escapeHtml(note.author || 'Unknown')}</strong></span>
                  <span class="muted" style="font-size:0.8rem;">${escapeHtml(note.createdAt || '')}</span>
                </div>
                ${richView(note.text || '')}
              </div>`).join('') || '<div class="muted">No notes yet.</div>'}
          </div>
          <div id="note-form-container" class="hidden">
            ${createEditorMarkup('note-editor', true)}
            <div class="section-actions">
              <button class="btn primary" id="note-submit">Save Note</button>
              <button class="btn secondary" id="note-cancel">Cancel</button>
            </div>
          </div>
        </div>
      `;
      const theoriesHtml = `
        <div class="detail-section">
          <div class="row" style="justify-content:space-between;">
            <strong>Theories</strong>
            <button class="btn secondary" id="theory-add-btn">Add Theory</button>
          </div>
          <div id="theories-list" class="notes-grid">
            ${(quest.theories || []).map((entry) => `
              <div class="note-card">
                <div class="row" style="justify-content:space-between;">
                  <span><strong>${escapeHtml(entry.author || 'Unknown')}</strong></span>
                  <span class="muted" style="font-size:0.8rem;">${escapeHtml(entry.createdAt || '')}</span>
                </div>
                ${richView(entry.text || '')}
              </div>`).join('') || '<div class="muted">No theories yet.</div>'}
          </div>
          <div id="theory-form-container" class="hidden">
            ${createEditorMarkup('theory-editor', true)}
            <div class="section-actions">
              <button class="btn primary" id="theory-submit">Save Theory</button>
              <button class="btn secondary" id="theory-cancel">Cancel</button>
            </div>
          </div>
        </div>
      `;
      const trackingControls = `
        <div class="detail-section">
          <div class="section-actions">
            <button class="btn ghost" id="track-btn">${isTracked(quest) ? 'Untrack' : 'Track'} Quest</button>
            <button class="btn ghost" id="pin-btn">${isPinned(quest) ? 'Unpin' : 'Pin'} to HUD</button>
            <span id="tracking-feedback" class="feedback"></span>
          </div>
        </div>
      `;
      questDetailEl.innerHTML = `
        <div class="detail-header">
          <div>
            <h2>${escapeHtml(quest.title || 'Untitled Quest')}</h2>
            ${quest.subtitle ? `<div class="detail-subtitle">${escapeHtml(quest.subtitle)}</div>` : ''}
          </div>
          <div class="badges">
            <span class="badge">${QUEST_KIND_LABELS[quest.quest_kind] || 'Main Quest'}</span>
            <span class="badge">${escapeHtml(quest.faction || 'No faction')}</span>
            ${isTracked(quest) ? '<span class="badge tracked"><i class="fa-solid fa-eye"></i> Tracked</span>' : ''}
            ${isPinned(quest) ? '<span class="badge pinned"><i class="fa-solid fa-thumbtack"></i> Pinned</span>' : ''}
          </div>
        </div>
        <div class="row">
          <span class="muted">Status: ${QUEST_STATUS_LABELS[quest.status] || quest.status || 'Pending'}</span>
          <span class="muted">Visibility: ${escapeHtml((quest.visibility || 'party_visible').replace('_', ' '))}</span>
          <span class="muted">Scope: ${escapeHtml((quest.type || 'group').replace('_', ' '))}</span>
          <span class="muted">Assigned: ${escapeHtml(assignedUsers.join(', ') || 'Unassigned')}</span>
          <span class="muted">Session: ${escapeHtml(quest.session || 'N/A')}</span>
        </div>
        ${gmControls}
        <div class="detail-section">
          <strong>Description</strong>
          ${richView(quest.description || '')}
        </div>
      ` + `
        <div class="detail-section">
          <strong>Objectives</strong>
          <div class="objectives-grid">${objectivesHtml}</div>
          ${objectiveManageHtml}
        </div>` + notesHtml + theoriesHtml + trackingControls;
      wireRichToolbars(questDetailEl);
      attachObjectiveListeners();
      attachNoteButtons();
      attachTheoryButtons();
      attachTrackingButtons();
      attachStatusUpdate();
    }

    function isTracked(quest) {
      const user = (state.user?.username || '').toLowerCase();
      return (quest.tracked_by || []).map((name) => (name || '').toLowerCase()).includes(user);
    }

    function isPinned(quest) {
      const user = (state.user?.username || '').toLowerCase();
      return (quest.pinned_by || []).map((name) => (name || '').toLowerCase()).includes(user);
    }

    function attachObjectiveListeners() {
      document.querySelectorAll('.objective-status-btn').forEach((btn) => {
        btn.addEventListener('click', async () => {
          if (btn.hasAttribute('disabled')) return;
          const objectiveId = btn.dataset.objectiveId;
          const status = btn.dataset.status;
          const questId = state.activeQuest?.id;
          if (questId && objectiveId && status) {
            await updateObjectiveStatus(questId, objectiveId, { status });
          }
        });
      });
      document.querySelectorAll('.objective-hide-btn').forEach((btn) => {
        btn.addEventListener('click', async () => {
          const objectiveId = btn.dataset.objectiveId;
          const hidden = btn.dataset.hidden === '1';
          const questId = state.activeQuest?.id;
          if (questId && objectiveId) {
            await updateObjectiveStatus(questId, objectiveId, { hidden: !hidden });
          }
        });
      });
      const objectiveAddBtn = document.getElementById('objective-add-btn');
      const objectiveAddInput = document.getElementById('objective-add-input');
      if (objectiveAddBtn && objectiveAddInput) {
        objectiveAddBtn.addEventListener('click', async () => {
          const title = objectiveAddInput.value.trim();
          const quest = state.activeQuest;
          if (!quest || !title) return;
          const objectives = (quest.objectives || []).map((entry, idx) => ({
            id: entry.id,
            title: entry.title || '',
            description: entry.description || '',
            status: entry.status || 'not_started',
            type: entry.type || (entry.hidden ? 'hidden' : 'mandatory'),
            hidden: Boolean(entry.hidden || entry.type === 'hidden'),
            priority: entry.priority || 'secondary',
            order: entry.order || idx + 1,
          }));
          objectives.push({ title, order: objectives.length + 1 });
          objectiveAddInput.value = '';
          await patchQuest(quest.id, { objectives });
        });
      }
    }

    function attachNoteButtons() {
      const noteAdd = document.getElementById('note-add-btn');
      const noteForm = document.getElementById('note-form-container');
      const noteCancel = document.getElementById('note-cancel');
      const noteSubmit = document.getElementById('note-submit');
      const noteEditor = document.getElementById('note-editor');
      if (!noteAdd || !noteForm) return;
      noteAdd.addEventListener('click', () => {
        noteForm.classList.remove('hidden');
        if (noteEditor) {
          noteEditor.innerHTML = '';
          noteEditor.focus();
        }
      });
      noteCancel.addEventListener('click', () => noteForm.classList.add('hidden'));
      noteSubmit.addEventListener('click', async () => {
        const text = getEditorHtml(noteEditor);
        if (!stripHtml(text)) return;
        await postNote(text);
      });
    }

    function attachTheoryButtons() {
      const theoryAdd = document.getElementById('theory-add-btn');
      const theoryForm = document.getElementById('theory-form-container');
      const theoryCancel = document.getElementById('theory-cancel');
      const theorySubmit = document.getElementById('theory-submit');
      const theoryEditor = document.getElementById('theory-editor');
      if (!theoryAdd || !theoryForm) return;
      theoryAdd.addEventListener('click', () => {
        theoryForm.classList.remove('hidden');
        if (theoryEditor) {
          theoryEditor.innerHTML = '';
          theoryEditor.focus();
        }
      });
      theoryCancel.addEventListener('click', () => theoryForm.classList.add('hidden'));
      theorySubmit.addEventListener('click', async () => {
        const text = getEditorHtml(theoryEditor);
        if (!stripHtml(text)) return;
        await postTheory(text);
      });
    }

    function attachTrackingButtons() {
      const trackBtn = document.getElementById('track-btn');
      const pinBtn = document.getElementById('pin-btn');
      const feedback = document.getElementById('tracking-feedback');
      if (trackBtn) {
        trackBtn.addEventListener('click', async () => {
          await toggleTracking('tracked', isTracked(state.activeQuest) ? 'untrack' : 'track');
          if (feedback) {
            feedback.classList.remove('error');
            feedback.textContent = isTracked(state.activeQuest || {}) ? 'Quest is tracked.' : 'Quest is no longer tracked.';
          }
        });
      }
      if (pinBtn) {
        pinBtn.addEventListener('click', async () => {
          await toggleTracking('pinned', isPinned(state.activeQuest) ? 'untrack' : 'track');
          if (feedback) {
            feedback.classList.remove('error');
            feedback.textContent = isPinned(state.activeQuest || {}) ? 'Quest is pinned to HUD.' : 'Quest is no longer pinned.';
          }
        });
      }
    }

    function attachStatusUpdate() {
      const statusSelect = document.getElementById('status-update');
      const scopeSelect = document.getElementById('scope-update');
      const kindSelect = document.getElementById('kind-update');
      const editBtn = document.getElementById('edit-quest-btn');
      const deleteBtn = document.getElementById('delete-quest-btn');
      const assignBtn = document.getElementById('assign-user-btn');
      const unassignBtn = document.getElementById('unassign-user-btn');
      const assignSelect = document.getElementById('assign-user-select');
      const assignFeedback = document.getElementById('assign-feedback');
      if (statusSelect) {
        statusSelect.addEventListener('change', async () => {
          await patchQuest(state.activeQuest.id, { status: statusSelect.value });
        });
      }
      if (scopeSelect) {
        scopeSelect.addEventListener('change', async () => {
          await patchQuest(state.activeQuest.id, { scope: scopeSelect.value });
        });
      }
      if (kindSelect) {
        kindSelect.addEventListener('change', async () => {
          await patchQuest(state.activeQuest.id, { questKind: kindSelect.value });
        });
      }
      if (editBtn) {
        editBtn.addEventListener('click', () => {
          openCreateModalForEdit(state.activeQuest);
        });
      }
      if (deleteBtn) {
        deleteBtn.addEventListener('click', async () => {
          if (!window.confirm('Delete this quest? This action cannot be undone.')) return;
          await deleteQuest(state.activeQuest.id);
        });
      }
      if (assignBtn) {
        assignBtn.addEventListener('click', async () => {
          const username = (assignSelect?.value || '').trim();
          if (!username) {
            if (assignFeedback) assignFeedback.textContent = 'Select a user first.';
            return;
          }
          const assigned = Array.from(new Set([...(state.activeQuest.assignedTo || []), username]));
          await patchQuest(state.activeQuest.id, { assignedTo: assigned });
          if (assignFeedback) assignFeedback.textContent = `${username} assigned.`;
        });
      }
      if (unassignBtn) {
        unassignBtn.addEventListener('click', async () => {
          const username = (assignSelect?.value || '').trim();
          if (!username) {
            if (assignFeedback) assignFeedback.textContent = 'Select a user first.';
            return;
          }
          const assigned = (state.activeQuest.assignedTo || []).filter((name) => (name || '').toLowerCase() !== username.toLowerCase());
          await patchQuest(state.activeQuest.id, { assignedTo: assigned });
          if (assignFeedback) assignFeedback.textContent = `${username} unassigned.`;
        });
      }
    }

    async function updateObjectiveStatus(questId, objectiveId, payload) {
      try {
        await api(`/campaigns/${encodeURIComponent(CID)}/quests/${encodeURIComponent(questId)}/objectives/${encodeURIComponent(objectiveId)}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload || {}),
        });
        await loadQuestData();
      } catch (error) {
        console.error('Objective update failed', error);
      }
    }

    async function postNote(text) {
      if (!state.activeQuest) return;
      await api(`/campaigns/${encodeURIComponent(CID)}/quests/${encodeURIComponent(state.activeQuest.id)}/notes`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text }),
      });
      await loadQuestData();
    }

    async function postTheory(text) {
      if (!state.activeQuest) return;
      await api(`/campaigns/${encodeURIComponent(CID)}/quests/${encodeURIComponent(state.activeQuest.id)}/theories`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text }),
      });
      await loadQuestData();
    }

    async function setQuestTracking(questId, type, action, options = {}) {
      await api(`/campaigns/${encodeURIComponent(CID)}/quests/${encodeURIComponent(questId)}/tracking`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type, action }),
      });
      if (options.reload !== false) {
        await loadQuestData();
      }
    }

    async function toggleTracking(type, action) {
      if (!state.activeQuest) return;
      await setQuestTracking(state.activeQuest.id, type, action);
    }

    async function patchQuest(questId, payload, options = {}) {
      await api(`/campaigns/${encodeURIComponent(CID)}/quests/${encodeURIComponent(questId)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (options.reload !== false) {
        await loadQuestData();
      }
    }

    async function deleteQuest(questId) {
      if (!questId) return;
      await api(`/campaigns/${encodeURIComponent(CID)}/quests/${encodeURIComponent(questId)}`, {
        method: 'DELETE',
      });
      if (state.activeQuest?.id === questId) {
        state.activeQuest = null;
      }
      await loadQuestData();
    }

    async function loadQuestData() {
      if (!CID) {
        pageStatus.textContent = 'Campaign ID missing.';
        return;
      }
      try {
        const res = await api(`/campaigns/${encodeURIComponent(CID)}/quests`);
        const payload = res.quests || {};
        const previousId = state.activeQuest?.id;
        state.quests = [
          ...(payload.group || []),
          ...(payload.personal || []),
          ...(payload.archive || []),
        ];
        if (previousId) {
          state.activeQuest = state.quests.find((entry) => entry.id === previousId) || null;
        } else if (!state.activeQuest && state.quests.length) {
          state.activeQuest = state.quests[0];
        }
        renderFilters();
        renderQuestList();
        renderQuestDetail();
      } catch (error) {
        pageStatus.textContent = `Unable to load quests: ${error.message}`;
      }
    }

    async function loadUser() {
      try {
        const user = await api('/auth/me');
        state.user = user;
      } catch {
        state.user = null;
      }
      refreshGmVisibility();
    }

    async function loadCampaign() {
      if (!CID) return;
      try {
        const res = await api(`/campaigns/${encodeURIComponent(CID)}`);
        state.campaign = res.campaign || {};
        refreshBackToCampaignLink();
        refreshGmVisibility();
      } catch (error) {
        console.warn('Failed to load campaign', error);
      }
    }

    function updateFiltersFromInputs() {
      state.filters.search = searchInput.value.trim().toLowerCase();
      state.filters.type = filterTypeEl.value;
      state.filters.status = filterStatusEl.value;
      state.filters.assigned = filterAssignedEl.value;
      state.filters.faction = filterFactionEl.value;
      state.filters.session = filterSessionEl.value;
      renderQuestList();
    }

    searchInput.addEventListener('input', () => {
      state.filters.search = searchInput.value.trim().toLowerCase();
      renderQuestList();
    });
    [filterTypeEl, filterStatusEl, filterAssignedEl, filterFactionEl, filterSessionEl].forEach((el) => {
      el.addEventListener('change', () => {
        updateFiltersFromInputs();
      });
    });

    toggleHiddenBtn.addEventListener('click', () => {
      state.filters.showHidden = !state.filters.showHidden;
      toggleHiddenBtn.textContent = state.filters.showHidden ? 'Hide Hidden' : 'Show Hidden';
      renderQuestList();
    });

    openCreateBtn?.addEventListener('click', () => openCreateModalForCreate());
    closeCreateBtn?.addEventListener('click', () => closeCreateModal());
    createBackdrop?.addEventListener('click', () => closeCreateModal());

    createForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      const formData = new FormData(createForm);
      const parseCsv = (value) =>
        String(value || '')
          .split(',')
          .map((entry) => entry.trim())
          .filter(Boolean);
      const questId = String(formData.get('questId') || state.editingQuestId || '').trim();
      const editingQuest = questId ? state.quests.find((entry) => entry.id === questId) || null : null;
      const trackedWanted = formData.get('tracked') === 'on';
      const pinnedWanted = formData.get('pinned') === 'on';
      const payload = {
        title: String(formData.get('title') || '').trim(),
        subtitle: String(formData.get('subtitle') || '').trim(),
        questKind: String(formData.get('questKind') || 'main').trim(),
        scope: String(formData.get('scope') || 'group').trim(),
        status: String(formData.get('status') || 'pending').trim(),
        visibility: String(formData.get('visibility') || 'party_visible').trim(),
        assignedTo: parseCsv(formData.get('assignedTo')),
        tags: parseCsv(formData.get('tags')),
        faction: String(formData.get('faction') || '').trim(),
        session: String(formData.get('session') || '').trim(),
        description: state.createDescriptionEditor
          ? getEditorHtml(state.createDescriptionEditor)
          : String(formData.get('description') || ''),
        objectives: buildObjectivesPayload(
          formData.get('objectives'),
          editingQuest?.objectives || [],
        ),
      };
      try {
        if (questId) {
          createFeedback.textContent = 'Saving quest...';
          await patchQuest(questId, payload, { reload: false });
          const wasTracked = editingQuest ? isTracked(editingQuest) : false;
          const wasPinned = editingQuest ? isPinned(editingQuest) : false;
          if (wasTracked !== trackedWanted) {
            await setQuestTracking(questId, 'tracked', trackedWanted ? 'track' : 'untrack', { reload: false });
          }
          if (wasPinned !== pinnedWanted) {
            await setQuestTracking(questId, 'pinned', pinnedWanted ? 'track' : 'untrack', { reload: false });
          }
          createFeedback.textContent = 'Quest updated.';
        } else {
          payload.tracked = trackedWanted;
          payload.pinned = pinnedWanted;
          createFeedback.textContent = 'Creating quest...';
          await api(`/campaigns/${encodeURIComponent(CID)}/quests`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          createFeedback.textContent = 'Quest created.';
        }
        closeCreateModal();
        await loadQuestData();
      } catch (error) {
        createFeedback.textContent = error.message || 'Save failed';
      }
    });

    async function api(path, options = {}) {
      const headers = options.headers || {};
      const resp = await fetch(path, {
        credentials: 'include',
        ...options,
        headers,
      });
      const contentType = resp.headers.get('content-type') || '';
      const data = contentType.includes('application/json') ? await resp.json() : { status: 'error', message: await resp.text() };
      if (!resp.ok || data.status === 'error') {
        throw new Error(data.message || `HTTP ${resp.status}`);
      }
      return data;
    }

    async function init() {
      setupCreateQuestEditor();
      refreshBackToCampaignLink();
      if (!CID) {
        pageStatus.textContent = 'This hub must be opened with a campaign id.';
        return;
      }
      await loadUser();
      await loadCampaign();
      await loadQuestData();
    }

    init().catch((error) => {
      if (pageStatus) pageStatus.textContent = error.message;
    });
  </script>
</body>
</html>
