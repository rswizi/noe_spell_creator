<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Create a Spell</title>
  <link rel="stylesheet" href="/static/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
  <div style="max-width:700px;margin:16px auto 0;">
    <a class="btn btn-secondary" href="#" onclick="confirmHome(event)">← Back Home</a>
  </div>

  <h1>Create a Spell</h1>

  <!-- Live Cost Preview -->
  <div id="preview">
    <h3>Live Spell Preview</h3>
    <p><strong>MP Cost:</strong> <span id="mp_cost">--</span></p>
    <p><strong>EN Cost:</strong> <span id="en_cost">--</span></p>
    <p><strong>Category:</strong> <span id="category">--</span></p>
  </div>

  <!-- No action/method; we submit via JS -->
  <form id="spell-form">
    <!-- Spell Name -->
    <label for="school_name">Spell Name:</label>
    <input type="text" id="school_name" name="school_name" required><br><br>

    <!-- Activation -->
    <label for="activation">Activation:</label>
    <select id="activation" name="activation" required>
      <option value="Action">Action</option>
      <option value="Special Action">Special Action</option>
      <option value="Ritual">Ritual</option>
    </select><br><br>

    <!-- Range -->
    <label for="range">Range:</label>
    <select id="range" name="range" required>
      <option value="0">0</option>
      <option value="1">1</option>
      <option value="3">3</option>
      <option value="5">5</option>
      <option value="7">7</option>
      <option value="9">9</option>
      <option value="13">13</option>
      <option value="15">15</option>
    </select><br><br>

    <!-- AoE -->
    <label for="aoe">Area of Effect (AoE):</label>
    <select id="aoe" name="aoe" required>
      <option value="A Square">A Square</option>
      <option value="Line (3)">Line (3)</option>
      <option value="Line (5)">Line (5)</option>
      <option value="Line (7)">Line (7)</option>
      <option value="Line (9)">Line (9)</option>
      <option value="Cross (3)">Cross (3)</option>
      <option value="Cross (5)">Cross (5)</option>
      <option value="Cross (9)">Cross (9)</option>
      <option value="Cone (3)">Cone (3)</option>
      <option value="Cone (5)">Cone (5)</option>
      <option value="Cone (7)">Cone (7)</option>
      <option value="Cone (9)">Cone (9)</option>
      <option value="Circle (3)">Circle (3)</option>
      <option value="Circle (5)">Circle (5)</option>
      <option value="Circle (7)">Circle (7)</option>
      <option value="Circle (9)">Circle (9)</option>
    </select><br><br>

    <!-- Duration -->
    <label for="duration">Duration:</label>
    <select id="duration" name="duration" required>
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="4">4</option>
      <option value="6">6</option>
      <option value="8">8</option>
      <option value="10">10</option>
      <option value="12">12</option>
    </select><br><br>

    <!-- Effect Filters -->
    <div class="filter-bar" style="max-width:700px;margin:0 auto 10px;">
      <input id="eff-filter-name" type="text" placeholder="Filter effects by name…" />
      <select id="eff-filter-school">
        <option value="">All Schools</option>
      </select>
      <button type="button" id="eff-filter-clear">Reset</button>
    </div>

    <!-- Effects Section -->
    <label>Effects:</label>
    <div id="effects-container"></div>
    <button type="button" onclick="addEffect()">➕ Add Effect</button><br><br>

    <input type="submit" value="Submit Spell">
  </form>

<script>
function alertModal(msg) { alert(msg); }

function getEffectById(id) {
  if (!id) return null;
  return ALL_EFFECTS.find(e => String(e.id) === String(id)) || null;
}

function setEntryDescription(descEl, effectId) {
  const eff = getEffectById(effectId);
  descEl.textContent = eff ? (eff.description || "(No description)") : "";
}

function normalize(s) { return (s || "").toString().toLowerCase().trim(); }

function currentEffectFilters() {
  return {
    name: normalize(effFilterNameEl?.value),
    school: normalize(effFilterSchoolEl?.value) // this will be an ID or ""
  };
}

function effectMatchesFilters(effect, filters) {
  const n = normalize(effect.name);
  const sid = normalize(effect.school?.id);
  const sname = normalize(effect.school?.name);
  const nameOk = !filters.name || n.includes(filters.name);
  const schoolOk = !filters.school || sid === filters.school || sname === filters.school;
  return nameOk && schoolOk;
}

  let effectCount = 0;
  const API_BASE = "";

  // caches
  let ALL_EFFECTS = [];
  let ALL_SCHOOLS = [];
  let SCHOOL_BY_ID = {};

  let effFilterNameEl, effFilterSchoolEl;

  // ---------- utilities ----------
  function normalize(str) {
    return (str || "").toString().toLowerCase().trim();
  }

  function currentEffectFilters() {
    return {
      name: normalize(effFilterNameEl?.value || ""),
      school: normalize(effFilterSchoolEl?.value || "")
    };
  }

  function effectMatchesFilters(effect, filters) {
    const n = normalize(effect?.name);
    const sid = normalize(effect?.school?.id || effect?.school_id);
    const sname = normalize(effect?.school?.name);

    const nameOk   = !filters.name   || n.includes(filters.name);
    const schoolOk = !filters.school || sid === filters.school || sname === filters.school;
    return nameOk && schoolOk;
  }

  function getFilteredEffects() {
    const f = currentEffectFilters();
    return ALL_EFFECTS.filter(e => effectMatchesFilters(e, f));
  }

  // builds options for a single <select>, preserving existing selected value if possible
  function populateEffectSelect(selectEl, effects, keepValue = true) {
    const prevVal = keepValue ? selectEl.value : "";
    selectEl.innerHTML = `<option value="">-- Select Effect --</option>`;
    effects.forEach(effect => {
      const opt = document.createElement("option");
      opt.value = effect.id;
      const schoolBadge = effect?.school?.name
        ? ` — ${effect.school.name}`
        : (effect?.school?.id ? ` — ${effect.school.id}` : "");
      opt.textContent = `[${effect.id}] ${effect.name}${schoolBadge}`;
      selectEl.appendChild(opt);
    });

    if (keepValue && prevVal) {
      const hasPrev = effects.some(e => String(e.id) === String(prevVal));
      selectEl.value = hasPrev ? prevVal : "";
    }

    // if this select sits in an .effect-entry, refresh its description
    const entry = selectEl.closest(".effect-entry");
    if (entry) {
      const descEl = entry.querySelector(".effect-desc");
      if (descEl) setEntryDescription(descEl, selectEl.value);
    }
  }

  function refreshAllEffectSelects() {
    const filtered = getFilteredEffects();
    document
      .querySelectorAll('#effects-container select[name="effects[]"]')
      .forEach(sel => populateEffectSelect(sel, filtered, /*keepValue*/ true));
  }


  // ---------- fetchers ----------
  async function loadSchools() {
    const res = await fetch(`${API_BASE}/schools`);
    const data = await res.json();
    ALL_SCHOOLS = data.schools || [];

    // Build map id -> {id, name}
    SCHOOL_BY_ID = {};
    for (const s of ALL_SCHOOLS) {
      SCHOOL_BY_ID[String(s.id)] = { id: String(s.id), name: s.name || String(s.id) };
    }

    // Populate the effect school filter (values are IDs)
    const schoolSel = document.getElementById("eff-filter-school");
    schoolSel.innerHTML = `<option value="">All Schools</option>`;
    ALL_SCHOOLS.forEach(s => {
      const opt = document.createElement("option");
      opt.value = s.id; // id like "0003"
      opt.textContent = `${s.name} [${s.id}]`;
      schoolSel.appendChild(opt);
    });
  }


  async function loadEffects() {
    const res = await fetch(`${API_BASE}/effects`);
    const data = await res.json();
    const raw = data.effects || [];

    ALL_EFFECTS = raw.map(e => {
      // e.school is a string id like "0003"
      const sid = String(e.school || "").trim();
      const schoolObj = SCHOOL_BY_ID[sid] || { id: sid, name: sid }; // fallback name = id
      return {
        ...e,
        school: { id: schoolObj.id, name: schoolObj.name }
      };
    });
  }

  async function addEffectPrefilled(effectId) {
    return new Promise((resolve) => {
      const container = document.getElementById('effects-container');

      const entry = document.createElement('div');
      entry.className = 'effect-entry';
      entry.id = `effect-${effectCount}`;

      const leftCol = document.createElement('div');
      leftCol.className = 'effect-col';

      const select = document.createElement('select');
      select.name = "effects[]";
      select.required = true;

      populateEffectSelect(select, getFilteredEffects(), /*keepValue*/ false);
      select.value = effectId;

      const desc = document.createElement('div');
      desc.className = 'effect-desc';
      setEntryDescription(desc, select.value);

      select.addEventListener('change', () => {
        setEntryDescription(desc, select.value);
        updatePreview();
      });

      leftCol.appendChild(select);
      leftCol.appendChild(desc);

      const button = document.createElement("button");
      button.type = "button";
      button.innerText = "❌";
      button.onclick = () => { entry.remove(); updatePreview(); };

      entry.appendChild(leftCol);
      entry.appendChild(button);

      container.appendChild(entry);
      effectCount++;
      resolve();
    });
  }

  // ---------- builder bits (your existing logic, with tweaks) ----------
  function addEffect() {
    const container = document.getElementById('effects-container');

    const entry = document.createElement('div');
    entry.className = 'effect-entry';
    entry.id = `effect-${effectCount}`;

    const leftCol = document.createElement('div');
    leftCol.className = 'effect-col';

    const select = document.createElement('select');
    select.name = "effects[]";
    select.required = true;

    // initial population with current filters
    populateEffectSelect(select, getFilteredEffects(), /*keepValue*/ false);

    const desc = document.createElement('div');
    desc.className = 'effect-desc';
    setEntryDescription(desc, select.value);

    select.addEventListener('change', () => {
      setEntryDescription(desc, select.value);
      updatePreview();
    });

    leftCol.appendChild(select);
    leftCol.appendChild(desc);

    const button = document.createElement("button");
    button.type = "button";
    button.innerText = "✖";
    button.onclick = () => { entry.remove(); updatePreview(); };

    entry.appendChild(leftCol);
    entry.appendChild(button);

    container.appendChild(entry);
    effectCount++;
  }


  function updatePreview() {
    const form = document.getElementById("spell-form");
    const formData = new FormData(form);
    const rawEffects = formData.getAll("effects[]") || [];
    const effects = rawEffects.filter(id => id && id.trim() !== "");

    const data = {
      activation: formData.get("activation"),
      range: parseInt(formData.get("range")),
      aoe: formData.get("aoe"),
      duration: parseInt(formData.get("duration")),
      effects
    };

    fetch(`${API_BASE}/costs`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data)
    })
      .then(res => res.json())
      .then(result => {
        if (result.error) throw new Error(result.error);
        document.getElementById("mp_cost").innerText = result.mp_cost ?? 0;
        document.getElementById("en_cost").innerText = result.en_cost ?? 0;
        document.getElementById("category").innerText = result.category || "--";
      })
      .catch(err => {
        console.error("Spell preview error:", err);
        document.getElementById("mp_cost").innerText = "--";
        document.getElementById("en_cost").innerText = "--";
        document.getElementById("category").innerText = "--";
      });
  }

  async function prefillFromSpell(id) {
    try {
      const res = await fetch(`${API_BASE}/spells/${encodeURIComponent(id)}`);
      const data = await res.json();
      if (data.error) throw new Error(data.error);
      const sp = data.spell;

      document.getElementById("school_name").value = sp.name || "";
      document.getElementById("activation").value = sp.activation || "Action";
      document.getElementById("range").value = String(sp.range ?? "0");
      document.getElementById("aoe").value = sp.aoe || "A Square";
      document.getElementById("duration").value = String(sp.duration ?? "1");

      const cont = document.getElementById("effects-container");
      cont.innerHTML = "";
      if (Array.isArray(sp.effects)) {
        for (const eid of sp.effects) {
          await addEffectPrefilled(eid);
        }
      }
      updatePreview();
    } catch (e) {
      console.error("Autofill error:", e);
      alert("Failed to load template: " + e.message);
    }
  }

  // ---------- DOM boot ----------
  document.addEventListener("DOMContentLoaded", async () => {
    // grab filter inputs
    effFilterNameEl   = document.getElementById("eff-filter-name");
    effFilterSchoolEl = document.getElementById("eff-filter-school");

    // load data IN ORDER
    await loadSchools();
    await loadEffects();

    // wire filters
    const run = () => refreshAllEffectSelects();
    effFilterNameEl.addEventListener("input", run);
    effFilterSchoolEl.addEventListener("change", run);
    document.getElementById("eff-filter-clear").addEventListener("click", () => {
      effFilterNameEl.value = "";
      effFilterSchoolEl.value = "";
      refreshAllEffectSelects();
    });

    // listen for preview changes on other fields
    document.querySelectorAll("select, input").forEach(el => {
      el.addEventListener("change", updatePreview);
    });

    // at least one effect row
    addEffect();

    // load template OR edit target
    const params  = new URLSearchParams(window.location.search);
    const spellId = params.get("spell_id");
    const editId  = params.get("edit_id");

    if (spellId) prefillFromSpell(spellId);
    if (editId) {
      prefillFromSpell(editId).then(() => {
        const submitBtn = document.querySelector('input[type="submit"]');
        if (submitBtn) submitBtn.value = "💾 Save Changes";
        const header = document.getElementById("preview");
        if (header && !document.getElementById("edit-mode-banner")) {
          const warn = document.createElement("p");
          warn.id = "edit-mode-banner";
          warn.style.marginTop = "10px";
          warn.style.color = "#ffb84a";
          warn.textContent = "Edit mode: saving will override this spell.";
          header.appendChild(warn);
        }
      });
    }
  });

  function confirmHome(e) {
    e.preventDefault();
    if (confirm("Are you sure? All unsaved modifications will be lost.")) {
      window.location.href = "home.html";
    }
  }

  // unified submit handler (unchanged except token on create for logging)
  document.getElementById("spell-form").addEventListener("submit", function (e) {
    e.preventDefault();

    const params = new URLSearchParams(window.location.search);
    const editId = params.get("edit_id");
    const token = localStorage.getItem("auth_token") || "";

    const form = document.getElementById("spell-form");
    const formData = new FormData(form);
    const rawEffects = formData.getAll("effects[]") || [];
    const effects = rawEffects.filter(id => id && id.trim() !== "");

    const data = {
      name: formData.get("school_name") || "Unnamed Spell",
      activation: formData.get("activation"),
      range: parseInt(formData.get("range")),
      aoe: formData.get("aoe"),
      duration: parseInt(formData.get("duration")),
      effects
    };

    const url = editId ? `${API_BASE}/spells/${encodeURIComponent(editId)}` : `${API_BASE}/submit_spell`;
    const method = editId ? "PUT" : "POST";
    const headers = { "Content-Type": "application/json" };
    if (token) headers["Authorization"] = `Bearer ${token}`;

    fetch(url, { method, headers, body: JSON.stringify(data) })
      .then(async res => {
        const text = await res.text();
        let data;
        try { data = text ? JSON.parse(text) : {}; } catch { throw new Error(text || `${res.status} ${res.statusText}`); }
        if (!res.ok || data.status === "error") {
          throw new Error(data.message || `${res.status} ${res.statusText}`);
        }
        return data;
      })
      .then(result => {
        alertModal("Spell saved!");
        clearSpellForm(); 
      })
      .catch(err => {
        alertModal("Submit error: " + err.message);
   });
  });

  function clearSpellForm() {

    const form = document.getElementById('spell-form');
  if (form) form.reset();

  const chosen = document.getElementById('chosen-effects');   // container that holds the added effect selects/rows
  if (chosen) chosen.innerHTML = '';

  const effectDesc = document.getElementById('effect-description');
  if (effectDesc) effectDesc.textContent = '';

  const mp = document.getElementById('mp-cost'); if (mp) mp.textContent = '0';
  const en = document.getElementById('en-cost'); if (en) en.textContent = '0';
  const cat = document.getElementById('spell-category'); if (cat) cat.textContent = '';

  if (window.selectedEffects) window.selectedEffects = [];
}
</script>

</body>
</html>