<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Create a Spell</title>
  <link rel="stylesheet" href="/static/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    .type-chip{margin-left:8px;padding:2px 6px;border-radius:6px;background:#eef;font-size:.8rem}
    .knob-cost{margin-left:8px;opacity:.85}
    .effect-entry{display:flex;align-items:flex-start;gap:10px;margin:8px 0;padding:8px;border:1px solid #ddd;border-radius:8px}
    .effect-col{flex:1;min-width:0}
    .effect-desc{opacity:.85;margin-top:6px;font-size:.95rem}
    .effect-cost{margin-top:6px;font-size:.9rem;opacity:.9}
    .tiny{font-size:.85rem;opacity:.75}
  </style>
</head>
<body>
  <div style="max-width:700px;margin:16px auto 0;">
    <a class="btn btn-secondary" href="#" id="back-home">‚Üê</a>
  </div>

  <h1>Create a Spell</h1>

  <!-- Live Cost Preview -->
  <div id="preview" class="home-card" style="max-width:700px;margin:0 auto 16px;">
    <h3>Live Spell Preview</h3>
    <p><strong>MP Cost:</strong> <span id="mp_cost">--</span></p>
    <p><strong>EN Cost:</strong> <span id="en_cost">--</span></p>
    <p><strong>Category:</strong> <span id="category">--</span></p>
    <p><strong>MP to Next Category:</strong> <span id="mp_to_next">--</span></p>
  </div>

  <!-- Form (submitted via JS) -->
  <form id="spell-form" class="home-card" style="max-width:700px;margin:0 auto;">
    <!-- Spell Name -->
    <label for="school_name">Spell Name:</label>
    <input type="text" id="school_name" name="school_name" required>

    <!-- Activation -->
    <div style="margin-top:14px;">
      <label for="activation">Activation:</label>
      <small id="cost-activation" class="knob-cost tiny"></small><br>
      <select id="activation" name="activation" required>
        <option value="Action">Action</option>
        <option value="Special Action">Special Action</option>
        <option value="Ritual">Ritual</option>
      </select>
    </div>

    <!-- Range -->
    <div style="margin-top:14px;">
      <label for="range">Range:</label>
      <small id="cost-range" class="knob-cost tiny"></small>
      <small id="range-type-chip" class="type-chip"></small><br>
      <select id="range" name="range" required>
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="3">3</option>
        <option value="5">5</option>
        <option value="7">7</option>
        <option value="9">9</option>
        <option value="13">13</option>
        <option value="15">15</option>
      </select>
    </div>

    <!-- AoE -->
    <div style="margin-top:14px;">
      <label for="aoe">Area of Effect (AoE):</label>
      <small id="cost-aoe" class="knob-cost tiny"></small>
      <small id="aoe-type-chip" class="type-chip"></small><br>
      <select id="aoe" name="aoe" required>
        <!-- Keep your canonical AoE names (backend already understands them) -->
        <option value="A Square">A Square</option>
        <option value="Line (3)">Line (3)</option>
        <option value="Line (5)">Line (5)</option>
        <option value="Line (7)">Line (7)</option>
        <option value="Line (9)">Line (9)</option>
        <option value="Cross (3)">Cross (3)</option>
        <option value="Cross (5)">Cross (5)</option>
        <option value="Cross (9)">Cross (9)</option>
        <option value="Cone (3)">Cone (3)</option>
        <option value="Cone (5)">Cone (5)</option>
        <option value="Cone (7)">Cone (7)</option>
        <option value="Cone (9)">Cone (9)</option>
        <option value="Circle (3)">Circle (3)</option>
        <option value="Circle (5)">Circle (5)</option>
        <option value="Circle (7)">Circle (7)</option>
        <option value="Circle (9)">Circle (9)</option>
      </select>
    </div>

    <!-- Duration -->
    <div style="margin-top:14px;">
      <label for="duration">Duration:</label>
      <small id="cost-duration" class="knob-cost tiny"></small><br>
      <select id="duration" name="duration" required>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="4">4</option>
        <option value="6">6</option>
        <option value="8">8</option>
        <option value="10">10</option>
        <option value="12">12</option>
      </select>
    </div>

    <!-- Effect Filters -->
    <div class="filter-bar" style="margin:18px 0 10px;">
      <input id="eff-filter-name" type="text" placeholder="Filter effects by name‚Ä¶" />
      <select id="eff-filter-school">
        <option value="">All Schools</option>
      </select>
      <button type="button" id="eff-filter-clear">Reset</button>
    </div>

    <!-- Effects -->
    <label>Effects:</label>
    <div id="effects-container"></div>
    <button type="button" id="btn-add-effect" style="margin-top:8px;">‚ûï Add Effect</button>

    <div style="margin-top:18px;">
      <input type="submit" value="Submit Spell">
    </div>
  </form>

<script>
/* ---------- Config & caches ---------- */
const API_BASE = "";
const TYPE_ORDER = { A:1, B:2, C:3 };

let ALL_SCHOOLS = [];          // [{id,name,range_type,aoe_type,...}]
let SCHOOL_BY_ID = {};         // id -> school
let ALL_EFFECTS = [];          // [{id,name,description,mp_cost,en_cost,school}]
let EFFECTS_BY_ID = {};        // id -> effect

/* ---------- Helpers ---------- */
const $  = (s) => document.querySelector(s);
const $$ = (s) => Array.from(document.querySelectorAll(s));

function maxType(arr) {
  if (!arr || !arr.length) return "A";
  let best = "A";
  for (const raw of arr) {
    const t = String(raw || "A").toUpperCase();
    if (TYPE_ORDER[t] > TYPE_ORDER[best]) best = t;
  }
  return best;
}

function escapeHtml(str) {
  return String(str)
    .replace(/&/g,"&amp;").replace(/</g,"&lt;")
    .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
    .replace(/'/g,"&#039;");
}

function normalize(s) { return (s || "").toString().toLowerCase().trim(); }

/* ---------- Loaders ---------- */
async function loadSchools() {
  const res = await fetch(`${API_BASE}/schools`);
  const data = await res.json();
  ALL_SCHOOLS = data.schools || [];
  SCHOOL_BY_ID = {};
  for (const s of ALL_SCHOOLS) {
    SCHOOL_BY_ID[String(s.id)] = s;
  }
  // populate school filter for effects
  const schoolSel = $("#eff-filter-school");
  schoolSel.innerHTML = `<option value="">All Schools</option>`;
  for (const s of ALL_SCHOOLS) {
    const opt = document.createElement("option");
    opt.value = s.id;
    opt.textContent = `${s.name} [${s.id}]`;
    schoolSel.appendChild(opt);
  }
}

async function loadEffects() {
  const res = await fetch(`${API_BASE}/effects`);
  const data = await res.json();
  const raw = data.effects || [];
  // shape each effect with attached school object if available
  ALL_EFFECTS = raw.map(e => {
    const sid = String(e.school || "");
    return { ...e, school_obj: SCHOOL_BY_ID[sid] || null };
  });
  EFFECTS_BY_ID = {};
  for (const e of ALL_EFFECTS) EFFECTS_BY_ID[String(e.id)] = e;
}

/* ---------- Effect filtering ---------- */
function currentEffectFilters() {
  return {
    name:   normalize($("#eff-filter-name")?.value),
    school: normalize($("#eff-filter-school")?.value)
  };
}
function effectMatchesFilters(effect, f) {
  const nameOk = !f.name || normalize(effect.name).includes(f.name);
  const sid    = normalize(effect.school || effect.school_id || (effect.school_obj?.id));
  const sOk    = !f.school || sid === f.school;
  return nameOk && sOk;
}
function filteredEffects() {
  const f = currentEffectFilters();
  return ALL_EFFECTS.filter(e => effectMatchesFilters(e, f));
}

/* ---------- Build rows ---------- */
function populateEffectSelect(selectEl, list, opts = {}) {
  const { preserveSelection = true, pinSelected = null } = opts;

  const prev = preserveSelection ? String(selectEl.value || "") : "";
  const pinnedId =
    pinSelected != null && pinSelected !== "" ? String(pinSelected) : (prev || "");

  selectEl.innerHTML = `<option value="">-- Select Effect --</option>`;

  let addedPinnedKept = false;
  if (pinnedId && !list.some(e => String(e.id) === pinnedId)) {
    const eff = EFFECTS_BY_ID[pinnedId];
    if (eff) {
      const opt = document.createElement("option");
      opt.value = String(eff.id);
      const badge = eff.school_obj?.name
        ? ` ‚Äî ${eff.school_obj.name}`
        : (eff.school ? ` ‚Äî ${eff.school}` : "");
      opt.textContent = `[${eff.id}] ${eff.name}${badge} (kept)`;
      selectEl.appendChild(opt);
      addedPinnedKept = true;
    }
  }

  for (const e of list) {
    if (addedPinnedKept && String(e.id) === pinnedId) continue;

    const opt = document.createElement("option");
    opt.value = String(e.id);
    const schoolBadge = e.school_obj?.name
      ? ` ‚Äî ${e.school_obj.name}`
      : (e.school ? ` ‚Äî ${e.school}` : "");
    opt.textContent = `[${e.id}] ${e.name}${schoolBadge}`;
    selectEl.appendChild(opt);
  }

  if (pinnedId) {
    selectEl.value = pinnedId;
  } else if (!preserveSelection) {
    selectEl.value = "";
  }
}

function addEffectRow(prefillId="") {
  const container = $("#effects-container");

  const entry = document.createElement("div");
  entry.className = "effect-entry";

  const left = document.createElement("div");
  left.className = "effect-col";

  // select
  const sel = document.createElement("select");
  sel.name = "effects[]";
  sel.required = true;
  populateEffectSelect(sel, filteredEffects(), {
  preserveSelection: false,
  pinSelected: prefillId || null
});

  // description
  const desc = document.createElement("div");
  desc.className = "effect-desc";
  const setDesc = () => {
    const eff = EFFECTS_BY_ID[String(sel.value)];
    if (eff && eff.description) {
      desc.innerHTML = eff.description;
    } else if (eff) {
      desc.textContent = "(No description)";
    } else {
      desc.textContent = "";
    }
  };
  setDesc();

  // per-effect cost chip
  const costDiv = document.createElement("div");
  costDiv.className = "effect-cost";
  const setEffCost = () => {
    const eff = EFFECTS_BY_ID[String(sel.value)];
    costDiv.textContent = eff ? `MP ${eff.mp_cost}, EN ${eff.en_cost}` : "";
  };
  setEffCost();

  // hook changes
  sel.addEventListener("change", () => {
    setDesc();
    setEffCost();
    recomputeKnobTypes();
    updatePreview();
  });

  left.appendChild(sel);
  left.appendChild(desc);
  left.appendChild(costDiv);

  const removeBtn = document.createElement("button");
  removeBtn.type = "button";
  removeBtn.textContent = "‚úñ";
  removeBtn.onclick = () => {
    entry.remove();
    recomputeKnobTypes();
    updatePreview();
  };

  entry.appendChild(left);
  entry.appendChild(removeBtn);
  container.appendChild(entry);
}

/* ---------- Type chips & preview ---------- */
function recomputeKnobTypes() {
  // collect selected effect IDs
  const selectedIds = $$('#effects-container select[name="effects[]"]')
    .map(s => s.value)
    .filter(Boolean);

  // map to each effect‚Äôs school‚Äôs types
  const types = selectedIds.map(id => {
    const eff = EFFECTS_BY_ID[String(id)];
    const sch = eff?.school_obj;
    return { r: (sch?.range_type || "A").toUpperCase(), a: (sch?.aoe_type || "A").toUpperCase() };
  });

  // compute max types (A < B < C)
  const TYPE_ORDER = { A:1, B:2, C:3 };
  const maxOf = (arr, key) => {
    let best = "A";
    for (const t of arr) {
      const v = (t?.[key] || "A").toUpperCase();
      if (TYPE_ORDER[v] > TYPE_ORDER[best]) best = v;
    }
    return best;
  };

  const rangeType = types.length ? maxOf(types, "r") : "A";
  const aoeType   = types.length ? maxOf(types, "a") : "A";

  // paint chips
  const rChip = $("#range-type-chip");
  const aChip = $("#aoe-type-chip");
  if (rChip) rChip.textContent = `Type ${rangeType}`;
  if (aChip) aChip.textContent = `Type ${aoeType}`;

  // return the types so callers can include them in the payload
  return { range_type: rangeType, aoe_type: aoeType };
}

function updateKnobCostChipsFromBreakdown(br) {
  // If backend starts returning knob breakdown, fill them; otherwise clear.
  const set = (id, mp, en) => {
    const el = document.getElementById(id);
    if (el) el.textContent = (mp==null && en==null) ? "" : `MP ${mp ?? 0}, EN ${en ?? 0}`;
  };
  if (!br) {
    set("cost-activation"); set("cost-range"); set("cost-aoe"); set("cost-duration");
    return;
  }
  set("cost-activation", br.activation?.mp, br.activation?.en);
  set("cost-range",      br.range?.mp,      br.range?.en);
  set("cost-aoe",        br.aoe?.mp,        br.aoe?.en);
  set("cost-duration",   br.duration?.mp,   br.duration?.en);
}

function updatePreview() {
  const fd = new FormData($("#spell-form"));
  const selected = fd.getAll("effects[]").filter(v => v && v.trim() !== "");

  // compute & paint chips, and ALSO capture types for the payload
  const { range_type, aoe_type } = recomputeKnobTypes();

  const payload = {
    activation: fd.get("activation"),
    range: parseInt(fd.get("range") || "0", 10),
    aoe: fd.get("aoe"),
    duration: parseInt(fd.get("duration") || "1", 10),
    effects: selected,

    // >>> IMPORTANT: tell the backend which cost tables to use
    range_type,
    aoe_type,
  };

  fetch(`${API_BASE}/costs`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  })
  .then(r => r.json())
  .then(j => {
    $("#mp_cost").textContent = j.mp_cost ?? "--";
    $("#en_cost").textContent = j.en_cost ?? "--";
    $("#category").textContent = j.category || "--";
    $("#mp_to_next").textContent = (j.mp_to_next_category ?? "--");
    updateKnobCostChipsFromBreakdown(j.breakdown || null);
  })
  .catch(() => {
    $("#mp_cost").textContent = "--";
    $("#en_cost").textContent = "--";
    $("#category").textContent = "--";
    $("#mp_to_next").textContent = "--";
    updateKnobCostChipsFromBreakdown(null);
  });
}

/* ---------- Submit (create/update) ---------- */
function handleSubmit(e) {
  e.preventDefault();
  const params = new URLSearchParams(location.search);
  const editId = params.get("edit_id");
  const token  = localStorage.getItem("auth_token") || "";
  const fd = new FormData($("#spell-form"));

  const effects = [];
  document.querySelectorAll("#effects-container .effect-entry").forEach(entry=>{
    const id = entry.querySelector('select[name="effects[]"]')?.value || "";
    const cleanId = id.trim();
    if (!cleanId) return;
    effects.push(cleanId);
  });

  const body = {
    name: (fd.get("school_name") || "Unnamed Spell"),
    activation: fd.get("activation"),
    range: parseInt(fd.get("range") || "0", 10),
    aoe: fd.get("aoe"),
    duration: parseInt(fd.get("duration") || "1", 10),
    effects

  };

  const url = editId ? `${API_BASE}/spells/${encodeURIComponent(editId)}` : `${API_BASE}/submit_spell`;
  const method = editId ? "PUT" : "POST";
  const headers = { "Content-Type": "application/json" };
  if (token) headers["Authorization"] = `Bearer ${token}`;

  fetch(url, { method, headers, body: JSON.stringify(body) })
    .then(async res => {
      let payload = {};
      try { payload = await res.json(); } catch { /* ignore non-JSON */ }
      if (!res.ok || payload.status === "error") {
        const msg = payload.message || `${res.status} ${res.statusText}`;
        throw new Error(msg);
      }
      return payload;
    })
    .then(() => {
      alert("Spell saved!");
      clearSpellForm();
    })
    .catch(err => {
      // if server saved but returned non-JSON, user might see error‚Äîthis keeps message accurate
      alert("Submit error: " + (err?.message || "Unknown error"));
    });
}

/* ---------- Prefill (template/edit) ---------- */
async function prefillFromSpell(id) {
  const r = await fetch(`${API_BASE}/spells/${encodeURIComponent(id)}`);
  const j = await r.json();
  if (!j || !j.spell) throw new Error("Spell not found");
  const sp = j.spell;

  $("#school_name").value = sp.name || "";
  $("#activation").value  = sp.activation || "Action";
  $("#range").value       = String(sp.range ?? "0");
  $("#aoe").value         = sp.aoe || "A Square";
  $("#duration").value    = String(sp.duration ?? "1");

  $("#effects-container").innerHTML = "";
  if (Array.isArray(sp.effects)) {
    sp.effects.forEach((eid, idx)=>{
      addEffectRow(String(eid));
    });
  }
}

/* ---------- Clear form ---------- */
function clearSpellForm() {
  const form = $("#spell-form");
  if (form) form.reset();
  $("#effects-container").innerHTML = "";
  addEffectRow();                       // keep one empty row
  recomputeKnobTypes();
  updatePreview();
}

/* ---------- Boot ---------- */
document.addEventListener("DOMContentLoaded", async () => {
  // nav
  $("#back-home").addEventListener("click", (e) => {
  e.preventDefault();
  if (!confirm("Are you sure? All unsaved modifications will be lost.")) return;

  const qs = new URLSearchParams(location.search);
  const editId   = qs.get("edit_id");
  // Optional override: pass ?from=database.html (or any page) when linking here
  const returnTo = qs.get("from") || qs.get("return") || "database.html";

  if (editId) {
    // If we navigated here from your DB page, just go back; otherwise go to the DB page directly.
    if (document.referrer && new URL(document.referrer).origin === location.origin) {
      history.back();
    } else {
      location.href = returnTo;
    }
  } else {
    location.href = "home.html";
  }
});


  // load data
  await loadSchools();
  await loadEffects();

  // filters
  $("#eff-filter-name").addEventListener("input", () => {
    document.querySelectorAll('#effects-container select[name="effects[]"]').forEach(sel => {
      populateEffectSelect(sel, filteredEffects(), { preserveSelection: true });
    });
  });

  $("#eff-filter-school").addEventListener("change", () => {
    document.querySelectorAll('#effects-container select[name="effects[]"]').forEach(sel => {
      populateEffectSelect(sel, filteredEffects(), { preserveSelection: true });
    });
  });

  $("#eff-filter-clear").addEventListener("click", () => {
    $("#eff-filter-name").value = "";
    $("#eff-filter-school").value = "";
    document.querySelectorAll('#effects-container select[name="effects[]"]').forEach(sel => {
      populateEffectSelect(sel, filteredEffects(), { preserveSelection: true });
    });
  });

  // initial row & listeners
  addEffectRow();

  // recompute & preview on knobs
  ["activation","range","aoe","duration"].forEach(id => {
    document.getElementById(id).addEventListener("change", () => {
      recomputeKnobTypes();
      updatePreview();
    });
  });

  // template/edit mode
  const qs = new URLSearchParams(location.search);
  const spellId = qs.get("spell_id");
  const editId  = qs.get("edit_id");
  if (spellId) await prefillFromSpell(spellId);
  if (editId) {
    await prefillFromSpell(editId);
    const submitBtn = document.querySelector('input[type="submit"]');
    if (submitBtn) submitBtn.value = "üíæ Save Changes";
    const banner = document.createElement("p");
    banner.className = "tiny";
    banner.style.color = "#ff9300";
    banner.textContent = "Edit mode: saving will override this spell.";
    $("#preview").appendChild(banner);
  }

  // first compute & preview
  recomputeKnobTypes();
  updatePreview();

  // add/remove/submit
  $("#btn-add-effect").addEventListener("click", () => addEffectRow());
  $("#spell-form").addEventListener("submit", handleSubmit);
});
</script>
</body>
</html>
