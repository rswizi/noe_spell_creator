<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Create a Spell</title>
  <link rel="stylesheet" href="/static/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    .type-chip{margin-left:8px;padding:2px 6px;border-radius:6px;background:#eef;font-size:.8rem}
    .knob-cost{margin-left:8px;opacity:.85}
    .effect-entry{display:flex;align-items:flex-start;gap:10px;margin:8px 0;padding:8px;border:1px solid #ddd;border-radius:8px}
    .effect-col{flex:1;min-width:0}
    .effect-desc{opacity:.85;margin-top:6px;font-size:.95rem}
    .effect-cost{margin-top:6px;font-size:.9rem;opacity:.9}
    .effect-rolls{margin-top:8px;padding-top:8px;border-top:1px dashed #ddd}
    .effect-skill-line{font-size:.85rem;opacity:.85;margin-top:6px}
    .roll-list{display:grid;gap:6px;margin-top:6px}
    .roll-row{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
    .roll-expr{flex:2;min-width:160px}
    .roll-kind{flex:1;min-width:140px}
    .roll-dmg-type{flex:1;min-width:120px}
    .roll-label{flex:1;min-width:140px}
    .skill-roll-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:8px;margin-top:6px}
    .skill-roll-group{border:1px solid #eee;border-radius:6px;padding:6px}
    .skill-roll-item{display:flex;align-items:center;gap:6px;font-size:.9rem}
    .tiny{font-size:.85rem;opacity:.75}
  </style>
</head>
<body>
  <div style="max-width:700px;margin:16px auto 0;">
    <a class="btn btn-secondary" href="#" id="back-home">‚Üê</a>
  </div>

  <h1>Create a Spell</h1>

  <!-- Live Cost Preview -->
  <div id="preview" class="home-card" style="max-width:700px;margin:0 auto 16px;">
    <h3>Live Spell Preview</h3>
    <p><strong>MP Cost:</strong> <span id="mp_cost">--</span></p>
    <p><strong>EN Cost:</strong> <span id="en_cost">--</span></p>
    <p><strong>Category:</strong> <span id="category">--</span></p>
    <p><strong>MP to Next Category:</strong> <span id="mp_to_next">--</span></p>
  </div>

  <!-- Form (submitted via JS) -->
  <form id="spell-form" class="home-card" style="max-width:700px;margin:0 auto;">
    <!-- Spell Name -->
    <label for="school_name">Spell Name:</label>
    <input type="text" id="school_name" name="school_name" required>

    <!-- Activation -->
    <div style="margin-top:14px;">
      <label for="activation">Activation:</label>
      <small id="cost-activation" class="knob-cost tiny"></small><br>
      <select id="activation" name="activation" required>
        <option value="Action">Action</option>
        <option value="Special Action">Special Action</option>
        <option value="Ritual">Ritual</option>
      </select>
    </div>

    <!-- Range -->
    <div style="margin-top:14px;">
      <label for="range">Range:</label>
      <small id="cost-range" class="knob-cost tiny"></small>
      <small id="range-type-chip" class="type-chip"></small><br>
      <select id="range" name="range" required>
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="3">3</option>
        <option value="5">5</option>
        <option value="7">7</option>
        <option value="9">9</option>
        <option value="13">13</option>
        <option value="15">15</option>
      </select>
    </div>

    <!-- AoE -->
    <div style="margin-top:14px;">
      <label for="aoe">Area of Effect (AoE):</label>
      <small id="cost-aoe" class="knob-cost tiny"></small>
      <small id="aoe-type-chip" class="type-chip"></small><br>
      <select id="aoe" name="aoe" required>
        <!-- Keep your canonical AoE names (backend already understands them) -->
        <option value="A Square">A Square</option>
        <option value="Line (3)">Line (3)</option>
        <option value="Line (5)">Line (5)</option>
        <option value="Line (7)">Line (7)</option>
        <option value="Line (9)">Line (9)</option>
        <option value="Cross (3)">Cross (3)</option>
        <option value="Cross (5)">Cross (5)</option>
        <option value="Cross (9)">Cross (9)</option>
        <option value="Cone (3)">Cone (3)</option>
        <option value="Cone (5)">Cone (5)</option>
        <option value="Cone (7)">Cone (7)</option>
        <option value="Cone (9)">Cone (9)</option>
        <option value="Circle (3)">Circle (3)</option>
        <option value="Circle (5)">Circle (5)</option>
        <option value="Circle (7)">Circle (7)</option>
        <option value="Circle (9)">Circle (9)</option>
      </select>
    </div>

    <!-- Duration -->
    <div style="margin-top:14px;">
      <label for="duration">Duration:</label>
      <small id="cost-duration" class="knob-cost tiny"></small><br>
      <select id="duration" name="duration" required>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="4">4</option>
        <option value="6">6</option>
        <option value="8">8</option>
        <option value="10">10</option>
        <option value="12">12</option>
      </select>
    </div>

    <!-- Effect Filters -->
    <div class="filter-bar" style="margin:18px 0 10px;">
      <input id="eff-filter-name" type="text" placeholder="Filter effects by name‚Ä¶" />
      <select id="eff-filter-school">
        <option value="">All Schools</option>
      </select>
      <button type="button" id="eff-filter-clear">Reset</button>
    </div>

    <!-- Effects -->
    <label>Effects:</label>
    <div id="effects-container"></div>
    <button type="button" id="btn-add-effect" style="margin-top:8px;">‚ûï Add Effect</button>

    <div style="margin-top:18px;">
      <input type="submit" value="Submit Spell">
    </div>
  </form>

<script>
/* ---------- Config & caches ---------- */
const API_BASE = "";
const TYPE_ORDER = { A:1, B:2, C:3 };
const ROLL_KINDS = [
  { value:'damage', label:'Damage' },
  { value:'true_damage', label:'True Damage' },
  { value:'heal_hp', label:'HP Heal' },
  { value:'restore_fo', label:'FO Restore' },
  { value:'restore_en', label:'EN Restore' },
  { value:'sp_gain', label:'SP Gain' },
  { value:'custom', label:'Custom' },
];
const DAMAGE_TYPES = ['Neutral','Fire','Water','Earth','Wind','Lightning','Sun','Moon','Ki','Magic'];
const SKILL_GROUPS = [
  { label:'Reflex', skills:['Technicity','Dodge','Counter','Reactivity'] },
  { label:'Dexterity', skills:['Accuracy','Evasion','Stealth','Acrobatics'] },
  { label:'Body', skills:['Brutality','Blocking','Resistance','Athletics'] },
  { label:'Wisdom', skills:['Survival','Education','Perception','Psychology','Investigation'] },
  { label:'Presence', skills:['Taming','Charm','Charisma','Deception','Persuasion'] },
  { label:'Magic', skills:['Aura','Incantation','Enchantment','Restoration','Potential'] },
  { label:'Willpower', skills:['Intimidation','Spirit','Instinct','Absorption'] },
  { label:'Tech', skills:['Crafting','Sleight of hand','Alchemy','Medicine','Engineering'] },
];

let ALL_SCHOOLS = [];          // [{id,name,range_type,aoe_type,...}]
let SCHOOL_BY_ID = {};         // id -> school
let ALL_EFFECTS = [];          // [{id,name,description,mp_cost,en_cost,school}]
let EFFECTS_BY_ID = {};        // id -> effect

/* ---------- Helpers ---------- */
const $  = (s) => document.querySelector(s);
const $$ = (s) => Array.from(document.querySelectorAll(s));

function maxType(arr) {
  if (!arr || !arr.length) return "A";
  let best = "A";
  for (const raw of arr) {
    const t = String(raw || "A").toUpperCase();
    if (TYPE_ORDER[t] > TYPE_ORDER[best]) best = t;
  }
  return best;
}

function escapeHtml(str) {
  return String(str)
    .replace(/&/g,"&amp;").replace(/</g,"&lt;")
    .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
    .replace(/'/g,"&#039;");
}

function normalize(s) { return (s || "").toString().toLowerCase().trim(); }
function uniqueList(list){
  const out = [];
  const seen = new Set();
  (list || []).forEach(item=>{
    const key = String(item || '').toLowerCase();
    if (!key || seen.has(key)) return;
    seen.add(key);
    out.push(item);
  });
  return out;
}
function allSkillNames(){
  return SKILL_GROUPS.flatMap(group=> group.skills || []);
}
function normalizeSkillKey(name){
  const cleaned = String(name || '').trim().toLowerCase().replace(/[^a-z]/g, '');
  if (cleaned === 'enchantement') return 'enchantment';
  return cleaned;
}
function linkedSkillForEffectId(effectId){
  const eff = EFFECTS_BY_ID[String(effectId || '')] || null;
  const schoolId = eff?.school || eff?.school_id || eff?.schoolId || eff?.school_obj?.id || '';
  const school = SCHOOL_BY_ID[String(schoolId || '')] || null;
  const raw = (school?.linked_skill || '').trim();
  if (!raw) return '';
  const rawKey = normalizeSkillKey(raw);
  const match = allSkillNames().find(s=> normalizeSkillKey(s) === rawKey);
  return match || raw;
}

/* ---------- Loaders ---------- */
async function loadSchools() {
  const res = await fetch(`${API_BASE}/schools`);
  const data = await res.json();
  ALL_SCHOOLS = data.schools || [];
  SCHOOL_BY_ID = {};
  for (const s of ALL_SCHOOLS) {
    SCHOOL_BY_ID[String(s.id)] = s;
  }
  // populate school filter for effects
  const schoolSel = $("#eff-filter-school");
  schoolSel.innerHTML = `<option value="">All Schools</option>`;
  for (const s of ALL_SCHOOLS) {
    const opt = document.createElement("option");
    opt.value = s.id;
    opt.textContent = `${s.name} [${s.id}]`;
    schoolSel.appendChild(opt);
  }
}

async function loadEffects() {
  const res = await fetch(`${API_BASE}/effects`);
  const data = await res.json();
  const raw = data.effects || [];
  // shape each effect with attached school object if available
  ALL_EFFECTS = raw.map(e => {
    const sid = String(e.school || "");
    return { ...e, school_obj: SCHOOL_BY_ID[sid] || null };
  });
  EFFECTS_BY_ID = {};
  for (const e of ALL_EFFECTS) EFFECTS_BY_ID[String(e.id)] = e;
}

/* ---------- Effect filtering ---------- */
function currentEffectFilters() {
  return {
    name:   normalize($("#eff-filter-name")?.value),
    school: normalize($("#eff-filter-school")?.value)
  };
}
function effectMatchesFilters(effect, f) {
  const nameOk = !f.name || normalize(effect.name).includes(f.name);
  const sid    = normalize(effect.school || effect.school_id || (effect.school_obj?.id));
  const sOk    = !f.school || sid === f.school;
  return nameOk && sOk;
}
function filteredEffects() {
  const f = currentEffectFilters();
  return ALL_EFFECTS.filter(e => effectMatchesFilters(e, f));
}

/* ---------- Build rows ---------- */
function populateEffectSelect(selectEl, list, opts = {}) {
  const { preserveSelection = true, pinSelected = null } = opts;

  const prev = preserveSelection ? String(selectEl.value || "") : "";
  const pinnedId =
    pinSelected != null && pinSelected !== "" ? String(pinSelected) : (prev || "");

  selectEl.innerHTML = `<option value="">-- Select Effect --</option>`;

  let addedPinnedKept = false;
  if (pinnedId && !list.some(e => String(e.id) === pinnedId)) {
    const eff = EFFECTS_BY_ID[pinnedId];
    if (eff) {
      const opt = document.createElement("option");
      opt.value = String(eff.id);
      const badge = eff.school_obj?.name
        ? ` ‚Äî ${eff.school_obj.name}`
        : (eff.school ? ` ‚Äî ${eff.school}` : "");
      opt.textContent = `[${eff.id}] ${eff.name}${badge} (kept)`;
      selectEl.appendChild(opt);
      addedPinnedKept = true;
    }
  }

  for (const e of list) {
    if (addedPinnedKept && String(e.id) === pinnedId) continue;

    const opt = document.createElement("option");
    opt.value = String(e.id);
    const schoolBadge = e.school_obj?.name
      ? ` ‚Äî ${e.school_obj.name}`
      : (e.school ? ` ‚Äî ${e.school}` : "");
    opt.textContent = `[${e.id}] ${e.name}${schoolBadge}`;
    selectEl.appendChild(opt);
  }

  if (pinnedId) {
    selectEl.value = pinnedId;
  } else if (!preserveSelection) {
    selectEl.value = "";
  }
}

function renderSkillOptions(container, selected, defaultSkill){
  if (!container) return;
  const picked = new Set((selected || []).map(s=> normalizeSkillKey(s)));
  const defaultKey = normalizeSkillKey(defaultSkill);
  container.innerHTML = '';
  SKILL_GROUPS.forEach(group=>{
    const wrap = document.createElement('div');
    wrap.className = 'skill-roll-group';
    const title = document.createElement('div');
    title.textContent = group.label;
    title.className = 'tiny';
    wrap.appendChild(title);
    (group.skills || []).forEach(skill=>{
      const key = normalizeSkillKey(skill);
      if (!key || key === defaultKey) return;
      const row = document.createElement('label');
      row.className = 'skill-roll-item';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.value = skill;
      if (picked.has(key)) cb.checked = true;
      row.appendChild(cb);
      const span = document.createElement('span');
      span.textContent = skill;
      row.appendChild(span);
      wrap.appendChild(row);
    });
    container.appendChild(wrap);
  });
}

function readSkillOptions(container){
  if (!container) return [];
  return Array.from(container.querySelectorAll('input[type="checkbox"]:checked'))
    .map(cb=> String(cb.value || '').trim())
    .filter(Boolean);
}

function addEffectRollRow(listEl, initial){
  if (!listEl) return;
  const row = document.createElement('div');
  row.className = 'roll-row';

  const expr = document.createElement('input');
  expr.className = 'roll-expr';
  expr.placeholder = 'Expression (ex: 2d6 + 4 or 2 ID + 5)';
  expr.value = initial?.expr || initial?.expression || '';

  const kind = document.createElement('select');
  kind.className = 'roll-kind';
  ROLL_KINDS.forEach(opt=>{
    const o = document.createElement('option');
    o.value = opt.value;
    o.textContent = opt.label;
    kind.appendChild(o);
  });
  kind.value = initial?.kind || initial?.reason || 'damage';

  const dmgType = document.createElement('select');
  dmgType.className = 'roll-dmg-type';
  DAMAGE_TYPES.forEach(t=>{
    const o = document.createElement('option');
    o.value = t;
    o.textContent = t;
    dmgType.appendChild(o);
  });
  const initType = (initial?.damage_type || initial?.damageType || '').trim();
  if (initType && DAMAGE_TYPES.some(t=> t.toLowerCase() === initType.toLowerCase())){
    dmgType.value = DAMAGE_TYPES.find(t=> t.toLowerCase() === initType.toLowerCase()) || 'Neutral';
  }else{
    dmgType.value = 'Neutral';
  }

  const label = document.createElement('input');
  label.className = 'roll-label';
  label.placeholder = 'Custom label';
  label.value = initial?.label || initial?.custom_label || '';

  const rm = document.createElement('button');
  rm.className = 'btn small';
  rm.type = 'button';
  rm.textContent = 'X';
  rm.addEventListener('click', ()=> row.remove());

  const syncVisibility = ()=>{
    const k = kind.value;
    dmgType.style.display = k === 'damage' ? '' : 'none';
    label.style.display = k === 'custom' ? '' : 'none';
  };
  kind.addEventListener('change', syncVisibility);
  syncVisibility();

  row.appendChild(expr);
  row.appendChild(kind);
  row.appendChild(dmgType);
  row.appendChild(label);
  row.appendChild(rm);
  listEl.appendChild(row);
}

function readEffectRolls(listEl){
  if (!listEl) return [];
  const rolls = [];
  listEl.querySelectorAll('.roll-row').forEach(row=>{
    const expr = row.querySelector('.roll-expr')?.value || '';
    const kind = row.querySelector('.roll-kind')?.value || 'custom';
    const dmgType = row.querySelector('.roll-dmg-type')?.value || '';
    const label = row.querySelector('.roll-label')?.value || '';
    const cleanExpr = expr.trim();
    if (!cleanExpr) return;
    rolls.push({
      expr: cleanExpr,
      kind,
      damage_type: kind === 'damage' ? dmgType : '',
      label: kind === 'custom' ? label.trim() : ''
    });
  });
  return rolls;
}

function addEffectRow(prefillId="", prefillMeta=null) {
  const container = $("#effects-container");

  const entry = document.createElement("div");
  entry.className = "effect-entry";

  const left = document.createElement("div");
  left.className = "effect-col";

  // select
  const sel = document.createElement("select");
  sel.name = "effects[]";
  sel.required = true;
  populateEffectSelect(sel, filteredEffects(), {
  preserveSelection: false,
  pinSelected: prefillId || null
});

  // description
  const desc = document.createElement("div");
  desc.className = "effect-desc";
  const setDesc = () => {
    const eff = EFFECTS_BY_ID[String(sel.value)];
    if (eff && eff.description) {
      desc.innerHTML = eff.description;
    } else if (eff) {
      desc.textContent = "(No description)";
    } else {
      desc.textContent = "";
    }
  };
  setDesc();

  // per-effect cost chip
  const costDiv = document.createElement("div");
  costDiv.className = "effect-cost";
  const setEffCost = () => {
    const eff = EFFECTS_BY_ID[String(sel.value)];
    costDiv.textContent = eff ? `MP ${eff.mp_cost}, EN ${eff.en_cost}` : "";
  };
  setEffCost();

  const rollsWrap = document.createElement('div');
  rollsWrap.className = 'effect-rolls';

  const rollToggle = document.createElement('label');
  rollToggle.className = 'row';
  rollToggle.style.gap = '6px';
  rollToggle.style.margin = '0';
  const rollReq = document.createElement('input');
  rollReq.type = 'checkbox';
  rollReq.className = 'effect-skill-required';
  rollReq.checked = !!prefillMeta?.skill_roll;
  const rollReqSpan = document.createElement('span');
  rollReqSpan.textContent = 'Requires skill roll';
  rollToggle.appendChild(rollReq);
  rollToggle.appendChild(rollReqSpan);

  const defaultSkillLine = document.createElement('div');
  defaultSkillLine.className = 'effect-skill-line';

  const skillOptionsWrap = document.createElement('div');
  skillOptionsWrap.className = 'skill-roll-grid';

  const rollList = document.createElement('div');
  rollList.className = 'roll-list';
  const rolls = Array.isArray(prefillMeta?.rolls) ? prefillMeta.rolls : [];
  rolls.forEach(r=> addEffectRollRow(rollList, r));

  const addRollBtn = document.createElement('button');
  addRollBtn.type = 'button';
  addRollBtn.className = 'btn small';
  addRollBtn.textContent = '+ Add Roll';
  addRollBtn.addEventListener('click', ()=> addEffectRollRow(rollList));

  const updateSkillLines = ()=>{
    const linkedSkill = linkedSkillForEffectId(sel.value || '');
    defaultSkillLine.textContent = linkedSkill ? `School skill: ${linkedSkill}` : 'School skill: --';
    const picked = Array.isArray(prefillMeta?.skill_roll_skills) ? prefillMeta.skill_roll_skills : [];
    renderSkillOptions(skillOptionsWrap, picked, linkedSkill);
  };
  updateSkillLines();

  const updateSkillVisibility = ()=>{
    const show = !!rollReq.checked;
    defaultSkillLine.style.display = show ? '' : 'none';
    skillOptionsWrap.style.display = show ? '' : 'none';
  };
  rollReq.addEventListener('change', updateSkillVisibility);
  updateSkillVisibility();

  rollsWrap.appendChild(rollToggle);
  rollsWrap.appendChild(defaultSkillLine);
  rollsWrap.appendChild(skillOptionsWrap);
  rollsWrap.appendChild(rollList);
  rollsWrap.appendChild(addRollBtn);

  // hook changes
  sel.addEventListener("change", () => {
    setDesc();
    setEffCost();
    updateSkillLines();
    recomputeKnobTypes();
    updatePreview();
  });

  left.appendChild(sel);
  left.appendChild(desc);
  left.appendChild(costDiv);
  left.appendChild(rollsWrap);

  const removeBtn = document.createElement("button");
  removeBtn.type = "button";
  removeBtn.textContent = "‚úñ";
  removeBtn.onclick = () => {
    entry.remove();
    recomputeKnobTypes();
    updatePreview();
  };

  entry.appendChild(left);
  entry.appendChild(removeBtn);
  container.appendChild(entry);
}

/* ---------- Type chips & preview ---------- */
function recomputeKnobTypes() {
  // collect selected effect IDs
  const selectedIds = $$('#effects-container select[name="effects[]"]')
    .map(s => s.value)
    .filter(Boolean);

  // map to each effect‚Äôs school‚Äôs types
  const types = selectedIds.map(id => {
    const eff = EFFECTS_BY_ID[String(id)];
    const sch = eff?.school_obj;
    return { r: (sch?.range_type || "A").toUpperCase(), a: (sch?.aoe_type || "A").toUpperCase() };
  });

  // compute max types (A < B < C)
  const TYPE_ORDER = { A:1, B:2, C:3 };
  const maxOf = (arr, key) => {
    let best = "A";
    for (const t of arr) {
      const v = (t?.[key] || "A").toUpperCase();
      if (TYPE_ORDER[v] > TYPE_ORDER[best]) best = v;
    }
    return best;
  };

  const rangeType = types.length ? maxOf(types, "r") : "A";
  const aoeType   = types.length ? maxOf(types, "a") : "A";

  // paint chips
  const rChip = $("#range-type-chip");
  const aChip = $("#aoe-type-chip");
  if (rChip) rChip.textContent = `Type ${rangeType}`;
  if (aChip) aChip.textContent = `Type ${aoeType}`;

  // return the types so callers can include them in the payload
  return { range_type: rangeType, aoe_type: aoeType };
}

function updateKnobCostChipsFromBreakdown(br) {
  // If backend starts returning knob breakdown, fill them; otherwise clear.
  const set = (id, mp, en) => {
    const el = document.getElementById(id);
    if (el) el.textContent = (mp==null && en==null) ? "" : `MP ${mp ?? 0}, EN ${en ?? 0}`;
  };
  if (!br) {
    set("cost-activation"); set("cost-range"); set("cost-aoe"); set("cost-duration");
    return;
  }
  set("cost-activation", br.activation?.mp, br.activation?.en);
  set("cost-range",      br.range?.mp,      br.range?.en);
  set("cost-aoe",        br.aoe?.mp,        br.aoe?.en);
  set("cost-duration",   br.duration?.mp,   br.duration?.en);
}

function updatePreview() {
  const fd = new FormData($("#spell-form"));
  const selected = fd.getAll("effects[]").filter(v => v && v.trim() !== "");

  // compute & paint chips, and ALSO capture types for the payload
  const { range_type, aoe_type } = recomputeKnobTypes();

  const payload = {
    activation: fd.get("activation"),
    range: parseInt(fd.get("range") || "0", 10),
    aoe: fd.get("aoe"),
    duration: parseInt(fd.get("duration") || "1", 10),
    effects: selected,

    // >>> IMPORTANT: tell the backend which cost tables to use
    range_type,
    aoe_type,
  };

  fetch(`${API_BASE}/costs`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  })
  .then(r => r.json())
  .then(j => {
    $("#mp_cost").textContent = j.mp_cost ?? "--";
    $("#en_cost").textContent = j.en_cost ?? "--";
    $("#category").textContent = j.category || "--";
    $("#mp_to_next").textContent = (j.mp_to_next_category ?? "--");
    updateKnobCostChipsFromBreakdown(j.breakdown || null);
  })
  .catch(() => {
    $("#mp_cost").textContent = "--";
    $("#en_cost").textContent = "--";
    $("#category").textContent = "--";
    $("#mp_to_next").textContent = "--";
    updateKnobCostChipsFromBreakdown(null);
  });
}

/* ---------- Submit (create/update) ---------- */
function handleSubmit(e) {
  e.preventDefault();
  const params = new URLSearchParams(location.search);
  const editId = params.get("edit_id");
  const token  = localStorage.getItem("auth_token") || "";
  const fd = new FormData($("#spell-form"));

  const effects = [];
  const effects_meta = [];
  document.querySelectorAll("#effects-container .effect-entry").forEach(entry=>{
    const id = entry.querySelector('select[name="effects[]"]')?.value || "";
    const cleanId = id.trim();
    if (!cleanId) return;
    effects.push(cleanId);
    const skillRoll = !!entry.querySelector('.effect-skill-required')?.checked;
    const skillList = readSkillOptions(entry.querySelector('.skill-roll-grid'));
    const rolls = readEffectRolls(entry.querySelector('.roll-list'));
    effects_meta.push({
      id: cleanId,
      skill_roll: skillRoll,
      skill_roll_skills: skillList,
      rolls
    });
  });

  const body = {
    name: (fd.get("school_name") || "Unnamed Spell"),
    activation: fd.get("activation"),
    range: parseInt(fd.get("range") || "0", 10),
    aoe: fd.get("aoe"),
    duration: parseInt(fd.get("duration") || "1", 10),
    effects,
    effects_meta

  };

  const url = editId ? `${API_BASE}/spells/${encodeURIComponent(editId)}` : `${API_BASE}/submit_spell`;
  const method = editId ? "PUT" : "POST";
  const headers = { "Content-Type": "application/json" };
  if (token) headers["Authorization"] = `Bearer ${token}`;

  fetch(url, { method, headers, body: JSON.stringify(body) })
    .then(async res => {
      let payload = {};
      try { payload = await res.json(); } catch { /* ignore non-JSON */ }
      if (!res.ok || payload.status === "error") {
        const msg = payload.message || `${res.status} ${res.statusText}`;
        throw new Error(msg);
      }
      return payload;
    })
    .then(() => {
      alert("Spell saved!");
      clearSpellForm();
    })
    .catch(err => {
      // if server saved but returned non-JSON, user might see error‚Äîthis keeps message accurate
      alert("Submit error: " + (err?.message || "Unknown error"));
    });
}

/* ---------- Prefill (template/edit) ---------- */
async function prefillFromSpell(id) {
  const r = await fetch(`${API_BASE}/spells/${encodeURIComponent(id)}`);
  const j = await r.json();
  if (!j || !j.spell) throw new Error("Spell not found");
  const sp = j.spell;
  const rawMeta = Array.isArray(sp.effects_meta) ? sp.effects_meta : [];
  const metaById = new Map();
  rawMeta.forEach(entry=>{
    if (!entry || typeof entry !== "object") return;
    const eid = String(entry.id || entry.effect_id || "").trim();
    if (!eid || metaById.has(eid)) return;
    metaById.set(eid, entry);
  });
  const metaList = Array.isArray(sp.effects) && rawMeta.length === sp.effects.length
    ? rawMeta
    : (Array.isArray(sp.effects) ? sp.effects.map(eid=> metaById.get(String(eid)) || {}) : []);

  $("#school_name").value = sp.name || "";
  $("#activation").value  = sp.activation || "Action";
  $("#range").value       = String(sp.range ?? "0");
  $("#aoe").value         = sp.aoe || "A Square";
  $("#duration").value    = String(sp.duration ?? "1");

  $("#effects-container").innerHTML = "";
  if (Array.isArray(sp.effects)) {
    sp.effects.forEach((eid, idx)=>{
      addEffectRow(String(eid), metaList[idx] || null);
    });
  }
}

/* ---------- Clear form ---------- */
function clearSpellForm() {
  const form = $("#spell-form");
  if (form) form.reset();
  $("#effects-container").innerHTML = "";
  addEffectRow();                       // keep one empty row
  recomputeKnobTypes();
  updatePreview();
}

/* ---------- Boot ---------- */
document.addEventListener("DOMContentLoaded", async () => {
  // nav
  $("#back-home").addEventListener("click", (e) => {
  e.preventDefault();
  if (!confirm("Are you sure? All unsaved modifications will be lost.")) return;

  const qs = new URLSearchParams(location.search);
  const editId   = qs.get("edit_id");
  // Optional override: pass ?from=database.html (or any page) when linking here
  const returnTo = qs.get("from") || qs.get("return") || "database.html";

  if (editId) {
    // If we navigated here from your DB page, just go back; otherwise go to the DB page directly.
    if (document.referrer && new URL(document.referrer).origin === location.origin) {
      history.back();
    } else {
      location.href = returnTo;
    }
  } else {
    location.href = "home.html";
  }
});


  // load data
  await loadSchools();
  await loadEffects();

  // filters
  $("#eff-filter-name").addEventListener("input", () => {
    document.querySelectorAll('#effects-container select[name="effects[]"]').forEach(sel => {
      populateEffectSelect(sel, filteredEffects(), { preserveSelection: true });
    });
  });

  $("#eff-filter-school").addEventListener("change", () => {
    document.querySelectorAll('#effects-container select[name="effects[]"]').forEach(sel => {
      populateEffectSelect(sel, filteredEffects(), { preserveSelection: true });
    });
  });

  $("#eff-filter-clear").addEventListener("click", () => {
    $("#eff-filter-name").value = "";
    $("#eff-filter-school").value = "";
    document.querySelectorAll('#effects-container select[name="effects[]"]').forEach(sel => {
      populateEffectSelect(sel, filteredEffects(), { preserveSelection: true });
    });
  });

  // initial row & listeners
  addEffectRow();

  // recompute & preview on knobs
  ["activation","range","aoe","duration"].forEach(id => {
    document.getElementById(id).addEventListener("change", () => {
      recomputeKnobTypes();
      updatePreview();
    });
  });

  // template/edit mode
  const qs = new URLSearchParams(location.search);
  const spellId = qs.get("spell_id");
  const editId  = qs.get("edit_id");
  if (spellId) await prefillFromSpell(spellId);
  if (editId) {
    await prefillFromSpell(editId);
    const submitBtn = document.querySelector('input[type="submit"]');
    if (submitBtn) submitBtn.value = "üíæ Save Changes";
    const banner = document.createElement("p");
    banner.className = "tiny";
    banner.style.color = "#ff9300";
    banner.textContent = "Edit mode: saving will override this spell.";
    $("#preview").appendChild(banner);
  }

  // first compute & preview
  recomputeKnobTypes();
  updatePreview();

  // add/remove/submit
  $("#btn-add-effect").addEventListener("click", () => addEffectRow());
  $("#spell-form").addEventListener("submit", handleSubmit);
});
</script>
</body>
</html>
