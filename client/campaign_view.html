<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Campaign</title>
  <link rel="stylesheet" href="/static/style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Source+Sans+3:wght@300;400;600&display=swap" rel="stylesheet" />
  <style>
    :root{
      color-scheme: dark;
      --ink:#f6f2ea;
      --muted:#b7b2a8;
      --bg:#0b0c10;
      --panel:#161924;
      --border:#2a2f3a;
      --accent:#c9a227;
      --accent-2:#4a8b8f;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family:"Source Sans 3","Trebuchet MS",sans-serif;
      color:var(--ink);
      background:
        radial-gradient(900px 520px at 0% -10%, rgba(201,162,39,0.2), transparent 60%),
        radial-gradient(700px 420px at 100% 0%, rgba(74,139,143,0.2), transparent 50%),
        linear-gradient(180deg, var(--bg), #0a0b10 60%, #07080c);
      min-height:100vh;
    }
    .page{max-width:1200px;margin:0 auto;padding:30px 16px 70px;}
    .topbar{display:flex;align-items:center;gap:12px;flex-wrap:wrap;margin-bottom:18px;}
    .topbar h1{margin:0;font-family:"Cinzel","Times New Roman",serif;font-size:1.9rem;letter-spacing:.06em;}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:999px;border:1px solid #3a3f49;font-size:.82rem;color:var(--muted);}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .panel{
      border:1px solid var(--border);
      border-radius:18px;
      padding:16px;
      background:linear-gradient(150deg, rgba(22,25,36,0.96), rgba(10,11,16,0.92));
      display:grid;gap:12px;margin-bottom:14px;
    }
    .avatar{width:96px;height:96px;border-radius:16px;border:1px solid #333;overflow:hidden;background:#0b0b10;display:grid;place-items:center;}
    .avatar img{width:100%;height:100%;object-fit:cover;}
    .btn{
      border-radius:999px;border:1px solid #3a3f49;
      padding:8px 14px;background:#121521;color:var(--ink);
    }
    .btn:hover{border-color:#5c626f;}
    .btn.secondary{background:#0f111b;}
    .muted{color:var(--muted);}
    .grid{display:grid;gap:14px;}
    @media(min-width:980px){.grid.cols-2{grid-template-columns:1.4fr .8fr;}}
    .char-grid{display:grid;gap:14px;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));}
    .char-card{
      border:1px solid #2a2f3a;border-radius:16px;padding:12px;background:#10131d;
      display:flex;gap:12px;align-items:center;position:relative;
      box-shadow:0 10px 24px rgba(0,0,0,0.28);
    }
    .char-card .avatar{width:72px;height:72px;border-radius:14px;}
    .char-info{display:grid;gap:6px;flex:1 1 auto;min-width:0;}
    .char-meta{font-size:.85rem;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .char-actions{display:flex;gap:8px;flex-wrap:wrap;margin-left:auto;}
    .tag{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;border:1px solid #3a3f49;font-size:.75rem;color:var(--muted);}
    .chat-wrap{display:grid;gap:10px;}
    .chat-log{border:1px solid #2a2f3a;border-radius:16px;padding:12px;background:#0f111b;max-height:480px;overflow:auto;display:grid;gap:12px;}
    .chat-group{display:grid;gap:6px;}
    .chat-head{display:flex;gap:10px;align-items:center;}
    .chat-head .avatar{width:42px;height:42px;border-radius:12px;}
    .chat-user{font-weight:600;}
    .chat-lines{--chat-indent:52px;display:grid;gap:4px;padding-left:var(--chat-indent);}
    .chat-line{background:#121623;border:1px solid #232839;border-radius:10px;padding:8px 10px;}
    .chat-line .muted{font-size:.85rem;}
    .chat-line.whisper{border-color:#5a4a22;}
    .chat-line.self{border-color:#34555a;}
    .chat-line.chat-roll{background:transparent;border:none;padding:0;}
    .chat-line.chat-roll{margin-left:calc(-1 * var(--chat-indent));}
    .roll-card{
      --roll-accent:#a6b2ff;
      border:1px solid #2b303e;
      border-radius:16px;
      padding:12px 12px 10px;
      background:linear-gradient(180deg, rgba(18,20,33,0.98), rgba(12,13,20,0.96));
      display:grid;
      gap:8px;
      box-shadow:0 12px 18px rgba(0,0,0,0.35);
    }
    .roll-card.roll-skill{--roll-accent:#a6b2ff;}
    .roll-card.crit-success{--roll-accent:#b632ff;}
    .roll-card.crit-fail{--roll-accent:#e0672c;}
    .roll-card.crit-max{
      --roll-accent:#ff3b3b;
      border-color:#6a1010;
      background:linear-gradient(180deg, rgba(6,6,10,0.98), rgba(8,8,12,0.95));
      box-shadow:0 0 0 1px rgba(140,0,0,0.7), 0 16px 30px rgba(120,0,0,0.65), 0 0 18px rgba(255,0,0,0.45);
    }
    .roll-card.crit-max .roll-title,
    .roll-card.crit-max .roll-total{ text-shadow:0 0 12px rgba(255,40,40,0.6); }
    .roll-card.is-active{--roll-accent:#c9a227;}
    .roll-card.is-passive{--roll-accent:#d4d7e8;}
    .roll-card.roll-damage{--roll-accent:#c96b52;}
    .roll-card.roll-heal{--roll-accent:#6ac982;}
    .roll-card.roll-custom{--roll-accent:#9ea4b8;}
    .roll-title{
      font-weight:700;
      text-align:center;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--roll-accent);
    }
    .roll-divider{
      height:1px;
      background:linear-gradient(90deg, transparent, rgba(210,210,230,0.35), transparent);
    }
    .roll-sub{
      text-align:center;
      font-size:.82rem;
      opacity:.8;
    }
    .roll-total{
      text-align:center;
      font-size:2.6rem;
      font-weight:700;
      color:var(--roll-accent);
      letter-spacing:.02em;
    }
    .roll-total::before,
    .roll-total::after{
      color:var(--roll-accent);
    }
    .roll-total::before{content:'{';margin-right:4px;}
    .roll-total::after{content:'}';margin-left:4px;}
    .roll-formula{
      font-size:.78rem;
      opacity:.7;
      text-align:center;
    }
    .roll-desc{
      border:1px solid #2b303e;
      border-radius:12px;
      padding:10px;
      background:#121622;
      font-size:.88rem;
      line-height:1.4;
    }
    .roll-meta-line{
      text-align:center;
      font-size:.75rem;
      text-transform:uppercase;
      letter-spacing:.08em;
      opacity:.75;
    }
    .roll-dmg-row{
      display:grid;
      grid-template-columns:1fr auto;
      gap:8px;
      align-items:baseline;
    }
    .roll-dmg-type{
      font-size:.78rem;
      text-transform:uppercase;
      letter-spacing:.08em;
      opacity:.85;
    }
    .roll-dmg-value{
      font-size:2rem;
      font-weight:700;
      color:var(--roll-accent);
    }
    .roll-foot{
      text-align:center;
      font-size:.72rem;
      opacity:.6;
    }
    .chat-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    .chat-line.chat-image{ background:#121623; border:1px solid #232839; padding:8px; }
    .chat-line.chat-image img{ width:100%; border-radius:12px; border:1px solid #2a2a38; display:block; }
    .chat-line.chat-image .caption{ font-size:.85rem; margin-bottom:6px; }
    #chat-input{width:100%;max-width:100%;box-sizing:border-box;}
    input,select,textarea{padding:10px 12px;border-radius:12px;border:1px solid #2a2f3a;background:#11131d;color:var(--ink);}
    textarea{min-height:80px;resize:vertical;}
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.55);display:none;align-items:center;justify-content:center;z-index:4000;}
    .modal-backdrop.open{display:flex;}
    .modal{background:#10131d;border:1px solid #2a2f3a;border-radius:16px;padding:16px;min-width:320px;max-width:90vw;}
    .menu{position:fixed;z-index:5000;background:#10131d;border:1px solid #2a2f3a;border-radius:12px;padding:10px;display:none;min-width:260px;}
    .menu.open{display:block;}
    .menu label{font-size:.85rem;color:var(--muted);}
    .menu .row{margin-top:6px;}
  </style>
</head>
<body>
  <div class="page">
    <div class="topbar">
      <h1 id="camp-title">Campaign</h1>
      <span id="login-chip" class="pill">Checking login...</span>
      <a class="btn" href="campaigns_my.html">My Campaigns</a>
      <a class="btn" href="campaign_manager.html">Back</a>
      <span id="status" class="muted"></span>
    </div>

    <div class="panel">
      <div class="row" style="align-items:flex-start;">
        <div class="avatar"><img id="camp-avatar" alt="Campaign avatar" onerror="this.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9WUZPi8AAAAASUVORK5CYII=';"></div>
        <div style="flex:1;">
          <div class="row" style="justify-content:space-between;align-items:center;">
            <div>
              <div class="muted">Campaign</div>
              <div style="font-size:1.3rem;font-weight:600;" id="camp-name"></div>
              <div class="muted" id="camp-code" style="display:none;">Code: --</div>
            </div>
            <div class="row" id="gm-actions" style="display:none;">
              <button class="btn" id="gm-add-char">Add Character</button>
              <button class="btn secondary" id="gm-create-char">Create Character</button>
            </div>
          </div>
          <div id="camp-desc" class="muted" style="margin-top:10px;"></div>
        </div>
      </div>
    </div>

    <div class="grid cols-2">
      <div class="panel">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <strong>Characters</strong>
          <span class="muted">Right click a card for permissions (GM).</span>
        </div>
        <div id="char-list" class="char-grid"></div>
      </div>

      <div class="panel chat-wrap">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <strong>Campaign Chat</strong>
          <span class="muted" id="chat-status"></span>
        </div>
        <div id="chat-log" class="chat-log"></div>
        <div class="chat-controls">
          <label class="muted">Speaker
            <select id="chat-speaker"></select>
          </label>
          <label class="muted">Visibility
            <select id="chat-visibility">
              <option value="public">Public</option>
              <option value="whisper">Whisper</option>
              <option value="self">Self</option>
            </select>
          </label>
        </div>
        <textarea id="chat-input" placeholder="Type a message, or /r 2d6+1 adv"></textarea>
        <div class="row">
          <button class="btn" id="chat-send">Send</button>
          <span class="muted">Commands: /r XdY +Z adv|dis, /w or /s for visibility.</span>
        </div>
      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="add-char-backdrop">
    <div class="modal">
      <div class="row" style="justify-content:space-between;align-items:center;">
        <strong>Add Character (duplicate)</strong>
        <button class="btn secondary" id="add-char-close">Close</button>
      </div>
      <div style="margin-top:10px;">
        <label>Character</label>
        <select id="add-char-select" style="width:100%;"></select>
      </div>
      <div style="margin-top:10px;">
        <label>Duplicate name (optional)</label>
        <input id="add-char-name" placeholder="Leave empty to keep name" />
      </div>
      <div class="row" style="margin-top:12px;">
        <button class="btn" id="add-char-confirm">Add to Campaign</button>
        <span class="muted" id="add-char-status"></span>
      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="create-char-backdrop">
    <div class="modal">
      <div class="row" style="justify-content:space-between;align-items:center;">
        <strong>Create Character</strong>
        <button class="btn secondary" id="create-char-close">Close</button>
      </div>
      <div style="margin-top:10px;">
        <label>Character name</label>
        <input id="create-char-name" placeholder="New Campaign Character" />
      </div>
      <div class="row" style="margin-top:12px;">
        <button class="btn" id="create-char-confirm">Create and Add</button>
        <span class="muted" id="create-char-status"></span>
      </div>
    </div>
  </div>

  <div class="menu" id="perm-menu">
    <div><strong>Permissions</strong></div>
    <div class="row">
      <label>Target</label>
      <select id="perm-target"></select>
    </div>
    <div class="row">
      <label>Access</label>
      <select id="perm-level">
        <option value="none">None</option>
        <option value="limited">Limited</option>
        <option value="viewer">Viewer</option>
        <option value="owner">Owner</option>
      </select>
    </div>
    <div class="row">
      <button class="btn" id="perm-apply">Apply</button>
      <button class="btn secondary" id="perm-close">Close</button>
    </div>
    <div class="muted" id="perm-status"></div>
  </div>

  <script>
    const params = new URLSearchParams(location.search);
    const CID = params.get('cid') || '';
    const loginChip = document.getElementById('login-chip');
    const statusEl = document.getElementById('status');
    const campTitle = document.getElementById('camp-title');
    const campName = document.getElementById('camp-name');
    const campDesc = document.getElementById('camp-desc');
    const campCode = document.getElementById('camp-code');
    const campAvatar = document.getElementById('camp-avatar');
    const gmActions = document.getElementById('gm-actions');
    const charList = document.getElementById('char-list');

    const chatLog = document.getElementById('chat-log');
    const chatStatus = document.getElementById('chat-status');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const chatVisibility = document.getElementById('chat-visibility');
    const chatSpeaker = document.getElementById('chat-speaker');

    const addCharBackdrop = document.getElementById('add-char-backdrop');
    const addCharClose = document.getElementById('add-char-close');
    const addCharSelect = document.getElementById('add-char-select');
    const addCharName = document.getElementById('add-char-name');
    const addCharConfirm = document.getElementById('add-char-confirm');
    const addCharStatus = document.getElementById('add-char-status');

    const createCharBackdrop = document.getElementById('create-char-backdrop');
    const createCharClose = document.getElementById('create-char-close');
    const createCharName = document.getElementById('create-char-name');
    const createCharConfirm = document.getElementById('create-char-confirm');
    const createCharStatus = document.getElementById('create-char-status');

    const permMenu = document.getElementById('perm-menu');
    const permTarget = document.getElementById('perm-target');
    const permLevel = document.getElementById('perm-level');
    const permApply = document.getElementById('perm-apply');
    const permClose = document.getElementById('perm-close');
    const permStatus = document.getElementById('perm-status');

    const CHAT_VIS_KEY = `campaign_chat_visibility:${CID}`;
    const CHAT_STORAGE_KEY = `campaign_chat_local:${CID}`;

    let ME = null;
    let CAMPAIGN = null;
    let MY_CHARS = [];
    let CHAT_MESSAGES = [];
    let CHAT_MESSAGE_IDS = new Set();
    let CHAT_API_OK = true;
    let ACTIVE_CHAR_FOR_PERM = null;
    let CHAT_WS = null;
    let CHAT_WS_RETRY = null;
    let CHAT_POLL = null;

    function authHeaders(){
      const t = localStorage.getItem('auth_token') || '';
      return t ? { Authorization: 'Bearer ' + t, 'X-Auth-Token': t } : {};
    }
    async function api(path,opt={}){
      const headers = Object.assign({}, opt.headers||{}, authHeaders());
      const resp = await fetch(path, { credentials:'include', ...opt, headers });
      const ct = resp.headers.get('content-type') || '';
      const data = ct.includes('application/json') ? await resp.json() : { status:'error', message: await resp.text() };
      if (!resp.ok || data.status === 'error') throw new Error(data.message || `HTTP ${resp.status}`);
      return data;
    }

    function openModal(el){ el.classList.add('open'); }
    function closeModal(el){ el.classList.remove('open'); }

    async function loadMe(){
      try{
        const me = await api('/auth/me');
        ME = me;
        loginChip.textContent = `${me.username} (${me.role})`;
      }catch{
        loginChip.textContent = 'Not logged in';
      }
    }
    async function loadCampaign(){
      const res = await api(`/campaigns/${encodeURIComponent(CID)}`);
      CAMPAIGN = res.campaign;
      renderCampaign();
    }
    async function loadMyCharacters(){
      try{
        const res = await api('/characters');
        MY_CHARS = res.characters || [];
      }catch{
        MY_CHARS = [];
      }
    }

    function isGm(){
      if (!CAMPAIGN || !ME) return false;
      const role = (ME.role || '').toLowerCase();
      return !!CAMPAIGN.is_owner || role === 'admin';
    }

    function resolvePermission(c, username){
      if (isGm()) return 'owner';
      const directOwner = (c.owner || c.assigned_to || '') === username;
      if (directOwner) return 'owner';
      const map = c.permissions || c.permission_map || {};
      const direct = map[username];
      if (direct) return String(direct).toLowerCase();
      const fallback = c.permission_all || c.permission || 'viewer';
      return String(fallback).toLowerCase();
    }

    function charDisplayName(c){
      return c.name || c.character_name || 'Character';
    }

    function charOwnerName(c){
      return c.owner || c.assigned_to || c.player || 'Unassigned';
    }

    function avatarUrlForCharacter(c){
      const id = c.character_id || c.id || '';
      return id ? `/characters/${encodeURIComponent(id)}/avatar` : '';
    }

    function renderCampaign(){
      if (!CAMPAIGN) return;
      const gm = isGm();
      campTitle.textContent = CAMPAIGN.name || 'Campaign';
      campName.textContent = CAMPAIGN.name || 'Campaign';
      campDesc.textContent = (CAMPAIGN.description || '').trim() || 'No description.';
      campAvatar.src = CAMPAIGN.avatar_url ? `${CAMPAIGN.avatar_url}?ts=${Date.now()}` : `/campaigns/${encodeURIComponent(CID)}/avatar?ts=${Date.now()}`;
      gmActions.style.display = gm ? '' : 'none';
      campCode.style.display = gm ? '' : 'none';
      if (gm) campCode.textContent = `Code: ${CAMPAIGN.join_code || '--'}`;

      const members = [CAMPAIGN.owner].concat(CAMPAIGN.members || []).filter(Boolean);
      permTarget.innerHTML = '<option value="__all__">All members</option>' + members.map(m=>`<option value="${m}">${m}</option>`).join('');

      renderCharacters();
      renderChatSpeaker();
    }

    async function unlinkCampaignCharacter(charId){
      if (!charId) return;
      const confirmed = confirm('Unlink this character from the campaign?');
      if (!confirmed) return;
      try{
        await api(`/campaigns/${encodeURIComponent(CID)}/characters/${encodeURIComponent(charId)}`, { method:'DELETE' });
        await loadCampaign();
      }catch(e){
        alert(e.message);
      }
    }

    function renderCharacters(){
      charList.innerHTML = '';
      const chars = CAMPAIGN?.characters || [];
      if (!chars.length){
        charList.innerHTML = '<div class="muted">No characters yet.</div>';
        return;
      }
      const username = ME?.username || '';
      chars.forEach(c=>{
        const perm = resolvePermission(c, username);
        if (!isGm() && perm === 'none') return;
        const card = document.createElement('div');
        card.className = 'char-card';
        const charId = c.character_id || c.id || '';
        const name = charDisplayName(c);
        const owner = charOwnerName(c);
        const avatar = avatarUrlForCharacter(c);
        const isViewer = perm === 'viewer';
        const isLimited = perm === 'limited';
        const canUnlink = isGm() || owner === username;
        const openUrl = `character_edit.html?id=${encodeURIComponent(charId)}&cid=${encodeURIComponent(CID)}${isViewer ? '&view=1' : ''}`;
        card.innerHTML = `
          <div class="avatar"><img src="${avatar}" onerror="this.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9WUZPi8AAAAASUVORK5CYII=';"></div>
          <div class="char-info">
            <div><strong>${name}</strong></div>
            <div class="char-meta">Owner: ${owner}</div>
            ${isGm() ? `<div class="char-meta">Permission: ${perm}</div>` : ''}
          </div>
          <div class="char-actions">
            ${isLimited ? '<button class="btn secondary" disabled>Limited</button>' : `<a class="btn" href="${openUrl}">Open</a>`}
            ${canUnlink ? '<button class="btn secondary unlink-btn">Unlink</button>' : ''}
          </div>
        `;
        card.querySelector('.unlink-btn')?.addEventListener('click', (e)=>{
          e.preventDefault();
          e.stopPropagation();
          unlinkCampaignCharacter(charId);
        });
        if (isGm()){
          card.addEventListener('contextmenu', (e)=>{
            e.preventDefault();
            ACTIVE_CHAR_FOR_PERM = c;
            openPermMenu(e.clientX, e.clientY);
          });
        }
        charList.appendChild(card);
      });
    }

    function openPermMenu(x, y){
      permStatus.textContent = '';
      permMenu.style.left = `${x}px`;
      permMenu.style.top = `${y}px`;
      permMenu.classList.add('open');
    }

    function closePermMenu(){
      permMenu.classList.remove('open');
      ACTIVE_CHAR_FOR_PERM = null;
    }

    permClose.addEventListener('click', closePermMenu);
    document.addEventListener('click', (e)=>{
      if (!permMenu.contains(e.target)) closePermMenu();
    });

    permApply.addEventListener('click', async ()=>{
      if (!ACTIVE_CHAR_FOR_PERM) return;
      const target = permTarget.value;
      const level = permLevel.value;
      const charId = ACTIVE_CHAR_FOR_PERM.character_id || ACTIVE_CHAR_FOR_PERM.id || '';
      if (!charId) return;
      try{
        permStatus.textContent = 'Saving...';
        const payload = {};
        if (target === '__all__'){
          payload.permission_all = level;
        }else{
          payload.permissions = { [target]: level };
        }
        await api(`/campaigns/${encodeURIComponent(CID)}/characters/${encodeURIComponent(charId)}`, {
          method:'PATCH',
          headers:{ 'content-type':'application/json' },
          body: JSON.stringify(payload)
        });
        await loadCampaign();
        permStatus.textContent = 'Saved.';
      }catch(e){
        permStatus.textContent = e.message;
      }
    });

    function renderChatSpeaker(){
      const chars = CAMPAIGN?.characters || [];
      const username = ME?.username || '';
      const mine = chars.filter(c=> resolvePermission(c, username) === 'owner');
      const list = mine.length ? mine : chars;
      chatSpeaker.innerHTML = list.map(c=>`<option value="${c.character_id || c.id || ''}">${charDisplayName(c)}</option>`).join('');
    }

    function normalizeMessage(raw){
      const ts = raw.ts || raw.timestamp || raw.created_at || raw.time;
      const stamp = typeof ts === 'number' ? ts : (ts ? new Date(ts).getTime() : Date.now());
      return {
        id: raw.id || `${stamp}_${Math.random().toString(16).slice(2)}`,
        ts: stamp,
        visibility: (raw.visibility || raw.scope || 'public').toLowerCase(),
        type: raw.type || raw.kind || 'message',
        user: raw.user || raw.username || raw.sender || 'Unknown',
        character_id: raw.character_id || raw.characterId || raw.character?.id || '',
        character_name: raw.character_name || raw.characterName || raw.character?.name || raw.character_id || 'Character',
        character_avatar: raw.character_avatar || raw.avatar_url || raw.character?.avatar_url || '',
        text: raw.text || raw.message || raw.content || '',
        lines: raw.lines || raw.detail_lines || raw.details || [],
        image: raw.image || raw.image_url || raw.imageUrl || raw.media || ''
      };
    }

    function setChatMessages(list){
      CHAT_MESSAGES = list || [];
      CHAT_MESSAGE_IDS = new Set(CHAT_MESSAGES.map(m=> m.id));
    }

    function addChatMessage(raw){
      const msg = normalizeMessage(raw);
      if (CHAT_MESSAGE_IDS.has(msg.id)) return false;
      CHAT_MESSAGE_IDS.add(msg.id);
      CHAT_MESSAGES.push(msg);
      return true;
    }

    function messageVisible(msg){
      if (!msg) return false;
      if (msg.visibility === 'public') return true;
      const username = ME?.username || '';
      if (msg.visibility === 'self') return msg.user === username;
      if (msg.visibility === 'whisper') return isGm();
      return true;
    }

    function cleanChatLines(lines){
      return (lines || []).map(l=> String(l || '').trim()).filter(Boolean);
    }

    function imageFromMessage(msg){
      if (!msg) return '';
      if (msg.image) return String(msg.image);
      const line = (msg.lines || []).find(l=> /^Image:/i.test(l));
      if (line) return line.replace(/^Image:\s*/i, '').trim();
      return '';
    }

    function isTimeLine(line){
      return /^\d{1,2}:\d{2}/.test(line || '');
    }

    function detailMapFromLine(line){
      const map = {};
      if (!line) return map;
      line.split('|').forEach(part=>{
        const clean = part.trim();
        const idx = clean.indexOf(':');
        if (idx === -1) return;
        const key = clean.slice(0, idx).trim().toLowerCase();
        const val = clean.slice(idx + 1).trim();
        if (key) map[key] = val;
      });
      return map;
    }

    function parseAbilityCard(msg){
      const lines = cleanChatLines(msg.lines);
      const typeLine = lines.find(l=> /^Type:/i.test(l));
      if (!typeLine) return null;
      const typeMatch = typeLine.match(/Type:\s*([^|]+)/i);
      const kind = typeMatch ? typeMatch[1].trim().toLowerCase() : '';
      if (kind !== 'active' && kind !== 'passive') return null;
      const details = detailMapFromLine(typeLine);
      const filtered = lines.filter(l=> l !== typeLine && !/^Source:/i.test(l) && !/^Info only/i.test(l) && !isTimeLine(l));
      let desc = '';
      const effectLine = filtered.find(l=> /^Effect:/i.test(l));
      if (effectLine) desc = effectLine.replace(/^Effect:\s*/i, '').trim();
      if (!desc){
        const descLine = filtered.find(l=> !/^Cost:/i.test(l) && !/^Range:/i.test(l) && !/^AoE:/i.test(l) && !/^Activation:/i.test(l));
        if (descLine) desc = descLine;
      }
      return { kind, details, desc };
    }

    function parseSkillCard(msg){
      const lines = cleanChatLines(msg.lines);
      const skillLine = lines.find(l=> /^Skill:/i.test(l));
      if (!skillLine) return null;
      const resultLine = lines.find(l=> /^Result:/i.test(l));
      const totalMatch = resultLine ? resultLine.match(/Result:\s*([+-]?\d+)/i) : null;
      const total = totalMatch ? totalMatch[1] : '';
      const modeLine = lines.find(l=> /^Roll type:/i.test(l));
      const condLine = lines.find(l=> /^Conditions:/i.test(l));
      const critLine = lines.find(l=> /^Critical/i.test(l));
      const effectLine = lines.find(l=> /^Effect:/i.test(l));
      const breakdownLine = lines.find(l=> /\bBase\b/i.test(l) && /\bMod\b/i.test(l));
      const baseMatch = breakdownLine ? breakdownLine.match(/\bBase\s+(-?\d+)/i) : null;
      const modMatch = breakdownLine ? breakdownLine.match(/\bMod\s+(-?\d+)/i) : null;
      const base = baseMatch ? baseMatch[1] : null;
      const mod = modMatch ? modMatch[1] : null;
      const summaryPart = breakdownLine ? breakdownLine.split('| Base')[0].trim() : '';
      const parts = [];
      if (summaryPart) parts.push(summaryPart);
      if (base != null) parts.push(`Skill ${base}`);
      if (mod != null) parts.push(`Mod ${mod}`);
      if (critLine) parts.push(critLine.replace(/^Critical:\s*/i, '').trim());
      const formula = parts.length ? `[ ${parts.join(' + ')} ]` : '';
      const rollType = modeLine ? modeLine.replace(/^Roll type:\s*/i, '').trim() : 'Simple';
      const condText = condLine ? condLine.replace(/^Conditions:\s*/i, '').trim().replace(/\s*\|\s*/g, ', ') : '';
      const sub = condText ? `Rolled with ${rollType} + ${condText}` : `Rolled with ${rollType}`;
      let critClass = '';
      if (critLine){
        const critText = critLine.replace(/^Critical:\s*/i, '').trim().toLowerCase();
        if (critText.includes('maximum')) critClass = 'crit-max';
        if (!critClass && (/success/i.test(critLine) || /\+\s*\d+/.test(critLine))) critClass = 'crit-success';
        if (!critClass && (/fail/i.test(critLine) || /-\s*\d+/.test(critLine))) critClass = 'crit-fail';
      }
      const effect = effectLine ? effectLine.replace(/^Effect:\s*/i, '').trim() : '';
      return { total, sub, formula, critClass, effect };
    }

    function templateTagFromLines(lines){
      const line = (lines || []).find(l=> /^Template:/i.test(l));
      if (!line) return '';
      return line.replace(/^Template:\s*/i, '').trim().toLowerCase();
    }
    function stripTemplateLines(lines){
      return (lines || []).filter(l=> !/^Template:/i.test(l));
    }
    function parseRollSegments(lines){
      const rollLine = (lines || []).find(l=> /^(Result|Roll):/i.test(l));
      if (!rollLine) return null;
      const content = rollLine.replace(/^(Result|Roll):\s*/i, '');
      let types = [];
      const formulas = {};
      const segments = content.split('|').map(s=> s.trim()).filter(Boolean);
      segments.forEach(seg=>{
        const m = seg.match(/^(.+?)\s+([+-]?\d+)(?:\s*\((.+)\))?$/);
        if (m){
          const label = m[1].trim();
          types.push({ name: label, total: m[2] });
          if (m[3]) formulas[label] = m[3].trim();
        }
      });
      if (!types.length){
        const inParen = content.match(/\((.+)\)/);
        if (!inParen) return null;
        const typeParts = inParen[1].split('+').map(p=> p.trim()).filter(Boolean);
        types = [];
        typeParts.forEach(part=>{
          const m = part.match(/^(.+?)\s+([+-]?\d+)/);
          if (m) types.push({ name: m[1].trim(), total: m[2] });
        });
      }
      if (!types.length) return null;
      (lines || []).forEach(line=>{
        const m = line.match(/^(.+?):\s*(.+)$/);
        if (m){
          const key = m[1].trim();
          if (!formulas[key]) formulas[key] = m[2].trim();
        }
      });
      if (!Object.keys(formulas).length){
        const breakdownLine = (lines || []).find(l=> l !== rollLine && /\|/.test(l)) || '';
        const fallbackSegs = breakdownLine ? breakdownLine.split('|').map(s=> s.trim()).filter(Boolean) : [];
        fallbackSegs.forEach(seg=>{
          const m = seg.match(/(.+?)\s+([+-]?\d+)/);
          if (m) formulas[m[1].trim()] = seg;
        });
      }
      return { types, formulas };
    }
    function parseDamageCard(msg){
      const title = msg.text || '';
      const lines = cleanChatLines(msg.lines);
      const template = templateTagFromLines(lines);
      if (template && (template.includes('ability heal') || template.includes('ability custom'))){
        return null;
      }
      if (!/damage/i.test(title) && !(template && template.includes('ability damage'))) return null;
      const parsed = parseRollSegments(stripTemplateLines(lines));
      if (!parsed) return null;
      return parsed;
    }
    function parseHealCard(msg){
      const lines = cleanChatLines(msg.lines);
      const template = templateTagFromLines(lines);
      if (!template || !template.includes('ability heal')) return null;
      const parsed = parseRollSegments(stripTemplateLines(lines));
      if (!parsed) return null;
      return parsed;
    }
    function parseCustomCard(msg){
      const lines = cleanChatLines(msg.lines);
      const template = templateTagFromLines(lines);
      if (!template || !template.includes('ability custom')) return null;
      const parsed = parseRollSegments(stripTemplateLines(lines));
      if (!parsed) return null;
      return parsed;
    }

    function buildSegmentCard(meta, className, titleText){
      const card = document.createElement('div');
      card.className = `roll-card ${className}`.trim();
      const title = document.createElement('div');
      title.className = 'roll-title';
      title.textContent = titleText || 'Roll';
      card.appendChild(title);
      const topDivider = document.createElement('div');
      topDivider.className = 'roll-divider';
      card.appendChild(topDivider);
      meta.types.forEach((row, idx)=>{
        const rowEl = document.createElement('div');
        rowEl.className = 'roll-dmg-row';
        const typeEl = document.createElement('div');
        typeEl.className = 'roll-dmg-type';
        typeEl.textContent = row.name;
        const valueEl = document.createElement('div');
        valueEl.className = 'roll-dmg-value';
        valueEl.textContent = row.total;
        rowEl.appendChild(typeEl);
        rowEl.appendChild(valueEl);
        card.appendChild(rowEl);
        const formulaText = meta.formulas[row.name];
        if (formulaText){
          const formula = document.createElement('div');
          formula.className = 'roll-formula';
          formula.textContent = `[ ${formulaText} ]`;
          card.appendChild(formula);
        }
        if (idx < meta.types.length - 1){
          const sep = document.createElement('div');
          sep.className = 'roll-divider';
          card.appendChild(sep);
        }
      });
      return card;
    }

    function buildRollCard(msg){
      const skillMeta = parseSkillCard(msg);
      if (skillMeta){
        const card = document.createElement('div');
        card.className = `roll-card roll-skill ${skillMeta.critClass}`.trim();
        const title = document.createElement('div');
        title.className = 'roll-title';
        title.textContent = msg.text || 'Skill';
        const divider = document.createElement('div');
        divider.className = 'roll-divider';
        const sub = document.createElement('div');
        sub.className = 'roll-sub';
        sub.textContent = skillMeta.sub;
        const total = document.createElement('div');
        total.className = 'roll-total';
        total.textContent = skillMeta.total || '--';
        card.appendChild(title);
        card.appendChild(divider);
        card.appendChild(sub);
        card.appendChild(total);
        if (skillMeta.formula){
          const formula = document.createElement('div');
          formula.className = 'roll-formula';
          formula.textContent = skillMeta.formula;
          card.appendChild(formula);
        }
        if (skillMeta.effect){
          const desc = document.createElement('div');
          desc.className = 'roll-desc';
          desc.textContent = skillMeta.effect;
          card.appendChild(desc);
        }
        return card;
      }
      const abilityMeta = parseAbilityCard(msg);
      if (abilityMeta){
        const card = document.createElement('div');
        card.className = `roll-card roll-ability ${abilityMeta.kind === 'active' ? 'is-active' : 'is-passive'}`.trim();
        const title = document.createElement('div');
        title.className = 'roll-title';
        title.textContent = msg.text || 'Ability';
        const divider = document.createElement('div');
        divider.className = 'roll-divider';
        card.appendChild(title);
        card.appendChild(divider);
        if (abilityMeta.kind === 'active'){
          const metaLine = document.createElement('div');
          metaLine.className = 'roll-meta-line';
          const parts = [];
          if (abilityMeta.details.cost) parts.push(`Cost: ${abilityMeta.details.cost}`);
          if (abilityMeta.details.aoe) parts.push(`AoE: ${abilityMeta.details.aoe}`);
          if (abilityMeta.details.range) parts.push(`Range: ${abilityMeta.details.range}`);
          metaLine.textContent = parts.join(' || ');
          if (metaLine.textContent) card.appendChild(metaLine);
          if (abilityMeta.details.activation){
            const activationLine = document.createElement('div');
            activationLine.className = 'roll-meta-line';
            activationLine.textContent = `Activation: ${abilityMeta.details.activation}`;
            card.appendChild(activationLine);
          }
          const skillReq = abilityMeta.details['skill roll'];
          if (skillReq){
            const skillLine = document.createElement('div');
            skillLine.className = 'roll-meta-line';
            skillLine.textContent = `Skill Roll: ${skillReq}`;
            card.appendChild(skillLine);
          }
        }
        if (abilityMeta.desc){
          const desc = document.createElement('div');
          desc.className = 'roll-desc';
          desc.textContent = abilityMeta.desc;
          card.appendChild(desc);
        }
        return card;
      }
      const healMeta = parseHealCard(msg);
      if (healMeta){
        return buildSegmentCard(healMeta, 'roll-heal', msg.text || 'Ability Heal');
      }
      const customMeta = parseCustomCard(msg);
      if (customMeta){
        return buildSegmentCard(customMeta, 'roll-custom', msg.text || 'Ability Roll');
      }
      const dmgMeta = parseDamageCard(msg);
      if (dmgMeta){
        return buildSegmentCard(dmgMeta, 'roll-damage', msg.text || 'Weapon Damage');
      }
      return null;
    }

    function renderChat(){
      chatLog.innerHTML = '';
      const visible = CHAT_MESSAGES.filter(messageVisible).sort((a,b)=>a.ts-b.ts);
      if (!visible.length){
        chatLog.innerHTML = '<div class="muted">No messages yet.</div>';
        return;
      }
      let lastGroup = null;
      visible.forEach(msg=>{
        const key = `${msg.user}|${msg.character_id}`;
        const within = lastGroup && lastGroup.key === key && (msg.ts - lastGroup.lastTs) <= 5 * 60 * 1000;
        let group = lastGroup?.el;
        if (!within){
          group = document.createElement('div');
          group.className = 'chat-group';
          const head = document.createElement('div');
          head.className = 'chat-head';
          const avatar = document.createElement('div');
          avatar.className = 'avatar';
          const img = document.createElement('img');
          img.src = msg.character_avatar || (msg.character_id ? `/characters/${encodeURIComponent(msg.character_id)}/avatar` : '');
          img.onerror = () => { img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9WUZPi8AAAAASUVORK5CYII='; };
          avatar.appendChild(img);
          const info = document.createElement('div');
          info.innerHTML = `<div class="chat-user">${msg.character_name}</div><div class="muted">${msg.user}</div>`;
          head.appendChild(avatar);
          head.appendChild(info);
          group.appendChild(head);
          const lines = document.createElement('div');
          lines.className = 'chat-lines';
          group.appendChild(lines);
          chatLog.appendChild(group);
          lastGroup = { key, el: group, lastTs: msg.ts };
        }
        const lines = group.querySelector('.chat-lines');
        const line = document.createElement('div');
        const imageSrc = imageFromMessage(msg);
        if (msg.type === 'image' || imageSrc){
          line.className = `chat-line chat-image ${msg.visibility}`;
          if (msg.text){
            const caption = document.createElement('div');
            caption.className = 'caption';
            caption.textContent = msg.text;
            line.appendChild(caption);
          }
          const img = document.createElement('img');
          img.src = imageSrc;
          img.alt = msg.text || 'Image';
          line.appendChild(img);
          const meta = document.createElement('div');
          meta.className = 'muted';
          meta.textContent = `${new Date(msg.ts).toLocaleTimeString()} | ${msg.visibility}`;
          line.appendChild(meta);
          lines.appendChild(line);
          if (lastGroup) lastGroup.lastTs = msg.ts;
          return;
        }
        if (msg.type === 'roll'){
          const card = buildRollCard(msg);
          if (card){
            line.className = `chat-line chat-roll ${msg.visibility}`;
            const meta = document.createElement('div');
            meta.className = 'roll-foot';
            meta.textContent = `${new Date(msg.ts).toLocaleTimeString()} | ${msg.visibility}`;
            card.appendChild(meta);
            line.appendChild(card);
            lines.appendChild(line);
            if (lastGroup) lastGroup.lastTs = msg.ts;
            return;
          }
        }
        line.className = `chat-line ${msg.visibility}`;
        const title = document.createElement('div');
        title.textContent = msg.text || (msg.type === 'roll' ? 'Roll' : 'Message');
        line.appendChild(title);
        (msg.lines || []).forEach(l=>{
          if (!l) return;
          const div = document.createElement('div');
          div.className = 'muted';
          div.textContent = l;
          line.appendChild(div);
        });
        const meta = document.createElement('div');
        meta.className = 'muted';
        meta.textContent = `${new Date(msg.ts).toLocaleTimeString()} | ${msg.visibility}`;
        line.appendChild(meta);
        lines.appendChild(line);
        if (lastGroup) lastGroup.lastTs = msg.ts;
      });
    }

    function saveChatLocal(){
      localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(CHAT_MESSAGES.slice(-400)));
    }

    function loadChatLocal(){
      const raw = localStorage.getItem(CHAT_STORAGE_KEY);
      if (!raw) return [];
      try{
        return JSON.parse(raw).map(normalizeMessage);
      }catch{
        return [];
      }
    }

    async function loadChat(){
      if (!CID) return;
      if (!CHAT_API_OK){
        setChatMessages(loadChatLocal());
        renderChat();
        return;
      }
      try{
        const res = await api(`/campaigns/${encodeURIComponent(CID)}/chat`);
        setChatMessages((res.messages || res.chat || []).map(normalizeMessage));
        renderChat();
      }catch(e){
        CHAT_API_OK = false;
        closeChatSocket();
        setChatMessages(loadChatLocal());
        renderChat();
        chatStatus.textContent = 'Chat API unavailable, using local log.';
      }
    }

    async function postChatMessage(msg){
      const payload = {
        visibility: msg.visibility,
        type: msg.type,
        text: msg.text,
        lines: msg.lines,
        character_id: msg.character_id,
        character_name: msg.character_name,
        character_avatar: msg.character_avatar,
        user: msg.user,
        ts: msg.ts
      };
      if (CHAT_API_OK){
        try{
          await api(`/campaigns/${encodeURIComponent(CID)}/chat`, {
            method:'POST',
            headers:{ 'content-type':'application/json' },
            body: JSON.stringify(payload)
          });
          await loadChat();
          return;
        }catch{
          CHAT_API_OK = false;
          closeChatSocket();
          chatStatus.textContent = 'Chat API unavailable, using local log.';
        }
      }
      addChatMessage(payload);
      saveChatLocal();
      renderChat();
    }

    function setChatVisibilityPref(val){
      localStorage.setItem(CHAT_VIS_KEY, val);
    }

    function getChatVisibilityPref(){
      return localStorage.getItem(CHAT_VIS_KEY) || 'public';
    }

    function pickSpeaker(){
      const charId = chatSpeaker.value || '';
      const c = (CAMPAIGN?.characters || []).find(x=> (x.character_id || x.id || '') === charId);
      if (!c) return { character_id:'', character_name:'Character', character_avatar:'' };
      return {
        character_id: c.character_id || c.id || '',
        character_name: charDisplayName(c),
        character_avatar: avatarUrlForCharacter(c)
      };
    }

    function startChatPolling(){
      if (CHAT_POLL) return;
      CHAT_POLL = setInterval(loadChat, 5000);
    }

    function stopChatPolling(){
      if (!CHAT_POLL) return;
      clearInterval(CHAT_POLL);
      CHAT_POLL = null;
    }

    function chatSocketUrl(){
      const token = localStorage.getItem('auth_token') || '';
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      return `${proto}://${location.host}/campaigns/${encodeURIComponent(CID)}/chat/ws?token=${encodeURIComponent(token)}`;
    }

    function closeChatSocket(){
      if (CHAT_WS){
        CHAT_WS.close();
        CHAT_WS = null;
      }
      if (CHAT_WS_RETRY){
        clearTimeout(CHAT_WS_RETRY);
        CHAT_WS_RETRY = null;
      }
    }

    function scheduleChatSocketReconnect(){
      if (CHAT_WS_RETRY) return;
      CHAT_WS_RETRY = setTimeout(()=>{
        CHAT_WS_RETRY = null;
        connectChatSocket();
      }, 2000);
    }

    function connectChatSocket(){
      if (!CID || !CHAT_API_OK) return;
      if (CHAT_WS && (CHAT_WS.readyState === WebSocket.OPEN || CHAT_WS.readyState === WebSocket.CONNECTING)) return;
      const token = localStorage.getItem('auth_token') || '';
      if (!token){
        startChatPolling();
        return;
      }
      CHAT_WS = new WebSocket(chatSocketUrl());
      CHAT_WS.onopen = ()=>{
        chatStatus.textContent = 'Live';
        stopChatPolling();
      };
      CHAT_WS.onmessage = (event)=>{
        let payload = null;
        try{
          const data = JSON.parse(event.data || '{}');
          payload = data.message || data;
        }catch{
          return;
        }
        if (!payload) return;
        if (addChatMessage(payload)){
          renderChat();
        }
      };
      CHAT_WS.onclose = ()=>{
        CHAT_WS = null;
        if (CHAT_API_OK){
          chatStatus.textContent = 'Reconnecting...';
          scheduleChatSocketReconnect();
          startChatPolling();
        }
      };
      CHAT_WS.onerror = ()=>{};
    }

    function rollDice(count, sides){
      const rolls = [];
      for (let i=0; i<count; i++) rolls.push(Math.floor(Math.random() * sides) + 1);
      const total = rolls.reduce((a,b)=>a+b,0);
      return { rolls, total };
    }

    function parseRoll(expr){
      const raw = expr.trim();
      if (!raw) return null;
      const adv = /\badv\b/i.test(raw);
      const dis = /\bdis\b/i.test(raw);
      const cleaned = raw.replace(/\badv\b/ig,'').replace(/\bdis\b/ig,'').trim();
      const match = cleaned.match(/^(\d+)?d(\d+)([+-]\d+)?$/i);
      if (!match) return null;
      const count = Math.max(1, Number(match[1] || 1));
      const sides = Math.max(2, Number(match[2] || 6));
      const mod = Number(match[3] || 0);
      return { count, sides, mod, adv, dis, label: `${count}d${sides}${mod ? (mod > 0 ? `+${mod}` : mod) : ''}` };
    }

    function buildRollMessage(expr, visibility){
      const parsed = parseRoll(expr);
      if (!parsed) return { error:'Invalid roll format. Use /r XdY +Z adv|dis.' };
      const attempt = () => {
        const dice = rollDice(parsed.count, parsed.sides);
        return { rolls: dice.rolls, subtotal: dice.total, total: dice.total + parsed.mod };
      };
      let picked = attempt();
      let alt = null;
      if ((parsed.adv || parsed.dis) && !(parsed.adv && parsed.dis)){
        alt = attempt();
        picked = parsed.adv ? (picked.total >= alt.total ? picked : alt) : (picked.total <= alt.total ? picked : alt);
      }
      const lines = [];
      lines.push(`Expression: ${parsed.label}${parsed.adv ? ' adv' : ''}${parsed.dis ? ' dis' : ''}`.trim());
      lines.push(`Rolls: ${picked.rolls.join(' + ')} = ${picked.subtotal} ${parsed.mod ? (parsed.mod > 0 ? `+ ${parsed.mod}` : `- ${Math.abs(parsed.mod)}`) : ''}`.trim());
      lines.push(`Total: ${picked.total}`);
      if (alt){
        lines.push(`Other: ${alt.rolls.join(' + ')} = ${alt.subtotal} ${parsed.mod ? (parsed.mod > 0 ? `+ ${parsed.mod}` : `- ${Math.abs(parsed.mod)}`) : ''}`.trim());
      }
      return { text:`Roll ${parsed.label}`, lines, visibility };
    }

    async function handleChatSend(){
      const raw = (chatInput.value || '').trim();
      if (!raw) return;
      let visibility = chatVisibility.value;
      let content = raw;
      if (content.startsWith('/w')){
        visibility = 'whisper';
        content = content.slice(2).trim();
      }else if (content.startsWith('/s')){
        visibility = 'self';
        content = content.slice(2).trim();
      }
      const speaker = pickSpeaker();
      if (content.startsWith('/r')){
        const expr = content.slice(2).trim();
        const roll = buildRollMessage(expr, visibility);
        if (roll.error){
          alert(roll.error);
          return;
        }
        await postChatMessage({
          type:'roll',
          text: roll.text,
          lines: roll.lines,
          visibility,
          ts: Date.now(),
          user: ME?.username || 'Unknown',
          ...speaker
        });
      }else{
        await postChatMessage({
          type:'message',
          text: content,
          lines: [],
          visibility,
          ts: Date.now(),
          user: ME?.username || 'Unknown',
          ...speaker
        });
      }
      chatInput.value = '';
    }

    chatSend.addEventListener('click', handleChatSend);
    chatInput.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && !e.shiftKey){
        e.preventDefault();
        handleChatSend();
      }
    });

    chatVisibility.addEventListener('change', ()=> setChatVisibilityPref(chatVisibility.value));

    document.getElementById('gm-add-char').addEventListener('click', ()=>{
      addCharStatus.textContent = '';
      addCharName.value = '';
      addCharSelect.innerHTML = (MY_CHARS || []).map(c=>`<option value="${c.id}">${c.name || 'Character'}</option>`).join('');
      openModal(addCharBackdrop);
    });
    addCharClose.addEventListener('click', ()=> closeModal(addCharBackdrop));
    addCharBackdrop.addEventListener('click', (e)=>{ if (e.target === addCharBackdrop) closeModal(addCharBackdrop); });

    addCharConfirm.addEventListener('click', async ()=>{
      const character_id = addCharSelect.value || '';
      if (!character_id){ alert('Pick a character'); return; }
      try{
        addCharStatus.textContent = 'Adding...';
        await api(`/campaigns/${encodeURIComponent(CID)}/assign_character`, {
          method:'POST',
          headers:{ 'content-type':'application/json' },
          body: JSON.stringify({ character_id, duplicate: true, name: addCharName.value || '' })
        });
        await loadCampaign();
        addCharStatus.textContent = 'Added.';
        closeModal(addCharBackdrop);
      }catch(e){
        addCharStatus.textContent = e.message;
      }
    });

    document.getElementById('gm-create-char').addEventListener('click', ()=>{
      createCharStatus.textContent = '';
      createCharName.value = '';
      openModal(createCharBackdrop);
    });
    createCharClose.addEventListener('click', ()=> closeModal(createCharBackdrop));
    createCharBackdrop.addEventListener('click', (e)=>{ if (e.target === createCharBackdrop) closeModal(createCharBackdrop); });

    createCharConfirm.addEventListener('click', async ()=>{
      const name = (createCharName.value || '').trim() || 'New Campaign Character';
      try{
        createCharStatus.textContent = 'Creating...';
        const res = await api('/characters', {
          method:'POST',
          headers:{ 'content-type':'application/json' },
          body: JSON.stringify({ name })
        });
        const character_id = res.id || res.character?.id || '';
        if (!character_id) throw new Error('Character id missing.');
        await api(`/campaigns/${encodeURIComponent(CID)}/assign_character`, {
          method:'POST',
          headers:{ 'content-type':'application/json' },
          body: JSON.stringify({ character_id })
        });
        await loadCampaign();
        createCharStatus.textContent = 'Added.';
        closeModal(createCharBackdrop);
      }catch(e){
        createCharStatus.textContent = e.message;
      }
    });

    async function init(){
      if (!CID){ statusEl.textContent = 'Missing campaign id.'; return; }
      await loadMe();
      await loadMyCharacters();
      await loadCampaign();
      chatVisibility.value = getChatVisibilityPref();
      await loadChat();
      if (CHAT_API_OK){
        connectChatSocket();
      }else{
        window.addEventListener('storage', (e)=>{
          if (e.key === CHAT_STORAGE_KEY){
            setChatMessages(loadChatLocal());
            renderChat();
          }
        });
      }
    }

    init().catch(e=>{ statusEl.textContent = e.message; });
  </script>
</body>
</html>
