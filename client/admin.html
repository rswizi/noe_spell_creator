<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spell Creator — Modify Database</title>
  <link rel="stylesheet" href="/static/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{display:inline-block;border:1px solid #444;border-radius:999px;padding:2px 8px;font-size:.85rem}
    .pill-green{background:#123d12;border-color:#1f7a1f}
    .pill-yellow{background:#3d3a12;border-color:#a88f1e}
    .pill-red{background:#3d1212;border-color:#7a1f1f}
    .scrollbox{max-height:60vh;overflow:auto}
    .effect-entry{display:flex;gap:12px;border:1px solid #222;border-radius:10px;padding:10px;margin:10px 0}
    .btn-approve{background:#1f7a1f;border:1px solid #145814}
    .btn-review{background:#a88f1e;border:1px solid #7a6716}
    .btn-flag{background:#7a1f1f;border:1px solid #5a1515}
    .btn-ghost{background:transparent;border:1px dashed #444}
  </style>
</head>
<body>
  <div class="container">
    <h1>Modify Database</h1>

    <div class="home-card" style="margin-bottom:18px;">
      <div class="filter-bar row">
        <input id="filter-name" type="text" placeholder="Filter by name..." />
        <select id="filter-category">
          <option value="">All Categories</option>
          <option>Novice</option><option>Apprentice</option><option>Disciple</option>
          <option>Adept</option><option>Mage</option><option>Magister</option>
          <option>High Mage</option><option>Master</option><option>Grand Master</option>
          <option>Archmage</option><option>Supreme Archmage</option><option>Avant-garde</option>
        </select>
        <select id="filter-school">
          <option value="">All Schools</option>
        </select>
        <select id="filter-status" title="Filter by tag">
          <option value="">All Tags</option>
          <option value="green">Approved</option>
          <option value="yellow">Review</option>
          <option value="red">Flagged</option>
        </select>

        <button id="clear-filters">Reset</button>

        <span style="flex:1"></span>

        <!-- NEW: Recompute all + Delete flagged -->
        <button id="recompute-all" class="btn">Recompute All</button>
        <button id="delete-flagged" class="btn btn-flag">Delete All Flagged</button>
      </div>
    </div>

    <!-- NEW: Patch note card -->
    <div id="patch-card" class="home-card" style="display:none;margin-bottom:18px;">
      <div class="row" style="justify-content:space-between;">
        <div>
          <strong>Patch Notes</strong>
          <span class="pill" id="patch-summary"></span>
        </div>
        <div class="row">
          <button id="patch-copy" class="btn btn-secondary">Copy</button>
          <button id="patch-dl" class="btn btn-secondary">Download</button>
          <button id="patch-hide" class="btn btn-ghost">Hide</button>
        </div>
      </div>
      <pre id="patch-text" class="scrollbox" style="white-space:pre-wrap;"></pre>
    </div>

    <div class="home-card">
      <div id="results" class="scrollbox"></div>
    </div>

    <div style="margin-top:16px;">
      <a class="btn btn-secondary" href="home.html">← Back Home</a>
    </div>
  </div>

<script>
(() => {
  const API_BASE = "";
  const $  = (s) => document.querySelector(s);

  // Auth (from login flow)
  const token = localStorage.getItem("auth_token") || "";
  const role  = localStorage.getItem("auth_role") || "";


// Caches for details & type computation
const SCHOOL_BY_ID = {};
const EFFECTS_BY_ID = {};
const DETAIL_CACHE = {}; // id -> { spell, costs }

async function loadEffects() {
  try {
    const res = await fetch(`${API_BASE}/effects`);
    const data = await res.json();
    const list = data.effects || [];
    for (const e of list) {
      EFFECTS_BY_ID[String(e.id)] = e;
    }
  } catch (e) {
    console.error("loadEffects error:", e);
  }
}

function computeKnobTypesFromEffects(effectIds) {
  const TYPE_ORDER = { A:1, B:2, C:3 };
  let rBest = "A", aBest = "A";
  for (const eid of (effectIds || [])) {
    const e = EFFECTS_BY_ID[String(eid)] || null;
    const sid = e ? (e.school || e.school_id || "") : "";
    const sch = SCHOOL_BY_ID[String(sid)] || null;
    const r = String(sch?.range_type || "A").toUpperCase();
    const a = String(sch?.aoe_type   || "A").toUpperCase();
    if (TYPE_ORDER[r] > TYPE_ORDER[rBest]) rBest = r;
    if (TYPE_ORDER[a] > TYPE_ORDER[aBest]) aBest = a;
  }
  return { range_type: rBest, aoe_type: aBest };
}

async function fetchCostsForSpell(sp) {
  // Build payload for /costs using the spell values and derived knob types
  const effIds = (sp.effects || []).map(String);
  const { range_type, aoe_type } = computeKnobTypesFromEffects(effIds);
  const payload = {
    activation: sp.activation,
    range: sp.range,
    aoe: sp.aoe,
    duration: sp.duration,
    effects: effIds,
    range_type, aoe_type,
  };
  try {
    const r = await fetch(`${API_BASE}/costs`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    return await r.json();
  } catch (e) {
    console.error("fetchCostsForSpell error:", e);
    return {};
  }
}

async function ensureSpellDetails(id) {
  if (DETAIL_CACHE[id]) return DETAIL_CACHE[id];
  try {
    const r = await fetch(`${API_BASE}/spells/${encodeURIComponent(id)}`);
    const j = await r.json();
    const sp = j.spell || j;
    const costs = await fetchCostsForSpell(sp);
    const pack = { spell: sp, costs };
    DETAIL_CACHE[id] = pack;
    return pack;
  } catch (e) {
    console.error("ensureSpellDetails error:", e);
    return null;
  }
}

function renderSpellDetailsHTML(id, sp, costs) {
  // Effects as list with counts
  const counts = {};
  (sp.effects || []).forEach(eid => { const k = String(eid); counts[k] = (counts[k]||0) + 1; });
  const effectLines = Object.entries(counts).map(([eid, n])=>{
    const e = EFFECTS_BY_ID[String(eid)] || { name: `[${eid}]` };
    const mult = n > 1 ? ` [x${n}]` : "";
    return `<div><b>${escapeHtml(e.name || String(eid))}${mult}</b>${e.description ? `: ${escapeHtml(e.description)}` : ""}</div>`;
  }).join("");
  const mp = costs?.mp_cost ?? sp.mp_cost ?? "—";
  const en = costs?.en_cost ?? sp.en_cost ?? "—";
  const cat = costs?.category || sp.category || "—";
  const mpNext = costs?.mp_to_next_category;
  const mpNextTxt = (mpNext==null ? "—" : String(mpNext));

  return `
    <div class="spell-details-inner" style="margin-top:8px; border-top:1px dashed #333; padding-top:8px;">
      <div class="row" style="justify-content:space-between; align-items:flex-start;">
        <div style="flex:1; min-width:0;">
          <div style="opacity:.9; margin-bottom:6px;"><b>Effects</b></div>
          <div style="font-size:.95rem; opacity:.9">${effectLines || "<span class='tiny'>No effects.</span>"}</div>
        </div>
        <div style="flex:0 0 260px;">
          <div><b>MP Cost:</b> ${escapeHtml(String(mp))}</div>
          <div><b>EN Cost:</b> ${escapeHtml(String(en))}</div>
          <div><b>Category:</b> ${escapeHtml(String(cat))}</div>
          <div><b>MP to next Category:</b> ${escapeHtml(mpNextTxt)}</div>
        </div>
      </div>
    </div>
  `;
}


  // UI elements
  const resultsEl  = $("#results");
  const nameEl     = $("#filter-name");
  const categoryEl = $("#filter-category");
  const schoolEl   = $("#filter-school");
  const statusEl   = $("#filter-status");
  const clearBtn   = $("#clear-filters");

  const delFlagBtn = $("#delete-flagged");
  const recomputeBtn = $("#recompute-all");

  // Patch UI
  const patchCard = $("#patch-card");
  const patchText = $("#patch-text");
  const patchSummary = $("#patch-summary");
  const patchCopy = $("#patch-copy");
  const patchDL = $("#patch-dl");
  const patchHide = $("#patch-hide");

  // Gate access
  document.addEventListener("DOMContentLoaded", () => {
    if (role !== "admin" && role !== "moderator") {
      alert("Forbidden: admin/moderator only.");
      window.location.href = "home.html";
      return;
    }
    init();
  });

  async function init() {
    await loadSchools();
    await loadEffects();
    await fetchSpells();

    const run = debounce(fetchSpells, 300);
    nameEl.addEventListener("input", run);
    categoryEl.addEventListener("change", run);
    schoolEl.addEventListener("change", run);
    statusEl.addEventListener("change", run);

    clearBtn.addEventListener("click", () => {
      nameEl.value = "";
      categoryEl.value = "";
      schoolEl.value = "";
      statusEl.value = "";
      fetchSpells();
    });

    delFlagBtn.addEventListener("click", deleteFlagged);


// Delegated click for details
resultsEl.addEventListener("click", async (e) => {
  const t = e.target.closest("[data-toggle-details]");
  if (!t) return;
  const id = t.getAttribute("data-toggle-details");
  const holder = document.getElementById(`details-${id}`);
  if (!holder) return;

  // Load once
  if (!holder.getAttribute("data-loaded")) {
    const pack = await ensureSpellDetails(id);
    if (pack) {
      holder.innerHTML = renderSpellDetailsHTML(id, pack.spell, pack.costs);
      holder.setAttribute("data-loaded", "1");

      // Set the ❓ flag if mp_to_next_category >= 4
      const mpNext = (pack.costs && typeof pack.costs.mp_to_next_category !== "undefined")
        ? Number(pack.costs.mp_to_next_category) : NaN;
      if (!isNaN(mpNext) && mpNext >= 4) {
        const flag = document.getElementById(`mpflag-${id}`);
        if (flag) flag.style.display = "inline";
      }
    } else {
      holder.innerHTML = `<div class="tiny" style="color:#ff8080;margin-top:6px;">Failed to load details.</div>`;
      holder.setAttribute("data-loaded", "1");
    }
  }

  // Toggle visibility
  holder.style.display = (holder.style.display === "none" || !holder.style.display) ? "block" : "none";
});


    // NEW: recompute-all handler
    recomputeBtn.addEventListener("click", async () => {
      if (!token){ alert("You must be logged in."); return; }
      if (role !== "admin" && role !== "moderator"){ alert("Forbidden."); return; }
      if (!confirm("Recompute costs for ALL spells and generate patch notes?")) return;

      try {
        recomputeBtn.disabled = true;
        const txtBefore = recomputeBtn.textContent;
        recomputeBtn.textContent = "Recomputing…";

        const res = await fetch(`${API_BASE}/admin/spells/recompute_all`, {
          method: "POST",
          headers: { "Authorization": `Bearer ${token}` }
        });
        const data = await res.json().catch(()=>({}));

        if (data.status !== "success") {
          alert(data.message || "Recompute failed.");
        } else {
          // Show patch note
          const lines = Array.isArray(data.lines) ? data.lines : (data.note ? String(data.note).split("\n") : []);
          const changed = Number(data.changed || 0);
          const total   = Number(data.total   || 0);

          patchText.textContent = lines.join("\n") || "No MP/EN/category changes after recompute.";
          patchSummary.textContent = `${changed} changed / ${total} total`;
          patchCard.style.display = "block";

          // refresh list to reflect updated costs/categories
          await fetchSpells();
        }
        recomputeBtn.textContent = txtBefore;
        recomputeBtn.disabled = false;
      } catch (e) {
        console.error("recompute_all error:", e);
        recomputeBtn.disabled = false;
        recomputeBtn.textContent = "Recompute All";
        alert("Request failed.");
      }
    });

    // Patch actions
    patchHide.addEventListener("click", ()=> { patchCard.style.display = "none"; });
    patchCopy.addEventListener("click", async ()=>{
      try {
        await navigator.clipboard.writeText(patchText.textContent || "");
        patchCopy.textContent = "Copied!";
        setTimeout(()=> patchCopy.textContent = "Copy", 900);
      } catch { /* ignore */ }
    });
    patchDL.addEventListener("click", ()=>{
      const blob = new Blob([patchText.textContent || ""], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      const ts = new Date().toISOString().replace(/[:.]/g,"-");
      a.href = url;
      a.download = `spell_patch_notes_${ts}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });
  }

  function debounce(fn, ms = 300) {
    let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  }

  // -------- Data --------

  async function loadSchools() {
    try {
      const res = await fetch(`${API_BASE}/schools`);
      const data = await res.json();
      if (!data || !Array.isArray(data.schools)) return;
      for (const s of data.schools) {
        SCHOOL_BY_ID[String(s.id)] = s;
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = `${s.name} [${s.id}]`;
        schoolEl.appendChild(opt);
      }
    } catch (e) {
      console.error("loadSchools error:", e);
    }
  }

  function buildQuery() {
    const params = new URLSearchParams();
    const name = (nameEl.value || "").trim();
    const cat  = categoryEl.value || "";
    const sch  = schoolEl.value || "";
    const st   = statusEl.value || "";

    if (name) params.set("name", name);
    if (cat)  params.set("category", cat);
    if (sch)  params.set("school", sch);
    if (st)   params.set("status", st);

    return params.toString();
  }

  async function fetchSpells() {
    try {
      const q = buildQuery();
      const url = q ? `${API_BASE}/spells?${q}` : `${API_BASE}/spells`;
      const res = await fetch(url);
      const data = await res.json();

      if (data.error) {
        resultsEl.innerHTML = `<p style="color:#ff4a4a">Error: ${escapeHtml(data.error)}</p>`;
        return;
      }
      renderList(data.spells || []);
    } catch (e) {
      console.error("fetchSpells error:", e);
      resultsEl.innerHTML = `<p style="color:#ff4a4a">Failed to load spells.</p>`;
    }
  }

  // -------- Render --------

  function renderList(spells) {
    if (!spells.length) {
      resultsEl.innerHTML = `<p>No spells found.</p>`;
      return;
    }
    resultsEl.innerHTML = spells.map(spellRow).join("");
  }

  function spellRow(s) {
    const schoolNames = (s.schools || []).map(sc => sc.name).join(", ") || "—";
    const meta = [
      s.category || "—",
      s.activation ?? "—",
      s.range ?? "—",
      s.aoe ?? "—",
      `dur ${s.duration ?? "—"}`
    ].join(" · ");

    const status = (s.status || "yellow");
    const pillClass =
      status === "green" ? "pill pill-green" :
      status === "red"   ? "pill pill-red"   :
                           "pill pill-yellow";

    return `
      <div class="effect-entry" style="justify-content:space-between; align-items:flex-start;">
        <div style="flex:1; min-width:0;">
          <div style="font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
            ${escapeHtml(s.name || "Untitled")} <span style="opacity:.7">[${s.id}]</span>
          </div>
          <div style="opacity:.8;font-size:.95rem">${escapeHtml(meta)}</div>
          <div style="opacity:.7;font-size:.9rem">Schools: ${escapeHtml(schoolNames)}</div>
          <div style="margin-top:6px;"><span class="${pillClass}">${status.toUpperCase()}</span></div>
        </div>

        <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-end; flex-shrink:0;">
          <div class="action-row">
            <button class="btn btn-approve" onclick="setStatus('${s.id}','green')">Approve</button>
            <button class="btn btn-review"  onclick="setStatus('${s.id}','yellow')">Review</button>
            <button class="btn btn-flag"    onclick="setStatus('${s.id}','red')">Flag</button>
          </div>
          <div class="action-row">
            <button class="btn"               onclick="adminEditSpell('${s.id}')">Edit</button>
            <button class="btn btn-secondary" onclick="adminDeleteSpell('${s.id}')">Delete</button>
          </div>
        </div>
      </div>
    `;
  }

  function escapeHtml(str) {
    return String(str)
      .replace(/&/g, "&amp;").replace(/</g, "&lt;")
      .replace(/>/g, "&gt;").replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // -------- Actions (exposed globally for inline onclick) --------

  window.adminEditSpell = function(id) {
    window.location.href = `index.html?edit_id=${encodeURIComponent(id)}`;
  };

  window.adminDeleteSpell = async function(id) {
    if (!token) { alert("You must be logged in."); return; }
    if (!confirm(`Delete spell ${id}? This cannot be undone.`)) return;

    try {
      const res = await fetch(`${API_BASE}/spells/${encodeURIComponent(id)}`, {
        method: "DELETE",
        headers: { "Authorization": `Bearer ${token}` }
      });
      const data = await res.json();
      if (data.status === "success") {
        await fetchSpells();
      } else {
        alert(data.message || "Delete failed.");
      }
    } catch (e) {
      console.error("delete error:", e);
      alert("Delete request failed.");
    }
  };

  window.setStatus = async function(id, status) {
    if (!token) { alert("You must be logged in."); return; }
    try {
      const res = await fetch(`${API_BASE}/admin/spells/${encodeURIComponent(id)}/status`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`
        },
        body: JSON.stringify({ status })
      });
      const data = await res.json();
      if (data.status === "success") {
        await fetchSpells();
      } else {
        alert(data.message || "Failed to update status.");
      }
    } catch (e) {
      console.error("setStatus error:", e);
      alert("Request failed.");
    }
  };

  async function deleteFlagged() {
    if (!token)  { alert("You must be logged in."); return; }
    if (role !== "admin") { alert("Admin only."); return; }
    if (!confirm("Delete ALL flagged (red) spells? This cannot be undone.")) return;

    try {
      const res = await fetch(`${API_BASE}/admin/spells/flagged`, {
        method: "DELETE",
        headers: { "Authorization": `Bearer ${token}` }
      });
      const data = await res.json();
      if (data.status === "success") {
        alert(`Deleted ${data.deleted} flagged spell(s).`);
        await fetchSpells();
      } else {
        alert(data.message || "Failed to delete flagged spells.");
      }
    } catch (e) {
      console.error("deleteFlagged error:", e);
      alert("Request failed.");
    }
  }
})();
</script>
</body>
</html>